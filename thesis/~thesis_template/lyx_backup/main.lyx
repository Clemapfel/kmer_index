#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\definecolor{gray}{rgb}{0.5, 0.5, 0.5}
\definecolor{keyword}{RGB}{243, 60, 114}
\definecolor{comment}{RGB}{0, 200, 101}
\definecolor{background}{rgb}{0.9, 0.9, 0.9}

\usepackage{listings}
\usepackage{xparse}

\usepackage{mathtools}
\usepackage{algorithm,algpseudocode}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams-chap-bytype
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "beramono" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "keywordstyle={\bfseries \color{keyword}},commentstyle={\color{comment}},caption={Search function for exact matches for a query of size 0 < m < k $^{[1]}$},captionpos=b,backgroundcolor={\color{background}},basicstyle={\ttfamily\small},language={C++},numbers=none,captionpos=b,tabsize=2"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Implementation and Performance Evaluation of a k-mer Index for Exact String
 Matching
\end_layout

\begin_layout Author
Author: Clemens Cords, FU Berlin
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Abstract
As demand for large-scale genomic sequence matching rises, so does the ability
 to efficiently get the positions or number of occurrences of a query of
 length k called a kmer.
 A kmer-index optimized for this purposes was implemented and it's performance
 evaluated.
 The implementation is capable of searching kmers of arbitrary length specified
 at runtime, utilizes parallelization for faster construction and it's internal
 structure can be further customized at compile time to achieve greater
 performance for certain query sizes.
 The nature of the internal structure and search functions are explained
 and their performant nature demonstrated through benchmarks.
 Results indicate that for the purpose of finding positions or number of
 occurrences for queries of the commonly used length
\begin_inset Formula $k\in\{3,4,...,30\}$
\end_inset

 compared to the fm-index the kmer-index performs up to 60% faster and is
 thus recommended for use.
 For arbitrarily long queries the kmer-index was shown to exhibit speedup
 or slowdown of
\begin_inset Formula $\pm5$
\end_inset

% depending on text length and is therefore in it's current iteration applicable
 if not necessarily better suited for this purpose.
\end_layout

\begin_layout Abstract
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setcounter{page}{1}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
A k-mer (also known as
\begin_inset Quotes eld
\end_inset

q-gram
\begin_inset Quotes erd
\end_inset

, henceforth written as
\begin_inset Quotes eld
\end_inset

kmer
\begin_inset Quotes erd
\end_inset

) is any genomic sequence of length
\begin_inset Formula $k$
\end_inset

, usually in the context of a sub-sequence of a longer genome.
 Analysis of kmers is used in a wide variety of contexts such as in de novo
 genome assembly
\begin_inset CommandInset citation
LatexCommand cite
key "kmer: megahit,kmer: soapdenovo assembly"
literal "false"

\end_inset

, taxonomic profiling
\begin_inset CommandInset citation
LatexCommand cite
key "kmer: taxonomical profiling"
literal "false"

\end_inset

 and sequence classification
\begin_inset CommandInset citation
LatexCommand cite
key "kmer: kraken LCA"
literal "false"

\end_inset

.
 Furthermore kmer spectra (a graph of the multiplicity of each kmer in the
 set of pairwise different kmer in the reference) have been used to assess
 genome similarity
\begin_inset CommandInset citation
LatexCommand cite
key "kmer: spectrum dissimilarity"
literal "false"

\end_inset

 and to correct errors in sequence data
\begin_inset CommandInset citation
LatexCommand cite
key "kmer: spectrum error correction"
literal "false"

\end_inset

.

\begin_inset CommandInset href
LatexCommand href
name "Seqan3"
target "https://github.com/seqan/seqan3"
literal "false"

\end_inset

, a newly released version of the C++ API for sequence analysis has yet
 to implement a purpose-build index for kmer searching.
 This paper aims to access the viability of substituting seqan3s fm-index
\begin_inset CommandInset citation
LatexCommand cite
key "seqan3 fm-index master"
literal "false"

\end_inset

 with the presented kmer-index implementation not only for the purpose of
 searching small kmers but for exact string matching in general by comparing
 the indices performance to each other.
\end_layout

\begin_layout Section
Construction
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Verse

\series bold
Input
\series default
: text
\end_layout

\begin_layout Verse

\series bold
let
\series default

\begin_inset Formula $n$
\end_inset


\begin_inset Formula $\leftarrow$
\end_inset

 text.size()
\end_layout

\begin_layout Verse

\series bold
for
\series default

\begin_inset Formula $i$
\end_inset


\series bold
in
\series default

\begin_inset Formula $\{1,2,...,n\}$
\end_inset


\series bold
do
\end_layout

\begin_deeper
\begin_layout Verse

\series bold
let
\series default

\begin_inset Formula $h$
\end_inset


\begin_inset Formula $\leftarrow$
\end_inset

 hash(text.substring(
\begin_inset Formula $i,\:i+k$
\end_inset

))
\end_layout

\begin_layout Verse
index[
\begin_inset Formula $h$
\end_inset

]
\begin_inset Formula $\leftarrow$
\end_inset


\begin_inset Formula $(\text{index}[h],\:i)$
\end_inset


\end_layout

\end_deeper
\begin_layout Verse

\series bold
end
\end_layout

\begin_layout Verse

\series bold
return
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Construction of the kmer index.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The kmer-index utilizes an unordered map as it's central data structure
 which for each kmer saves the position of all occurrences in the text.
 To save on memory the kmers are converted to an unsigned integer via the
 following hash function:
\end_layout

\begin_layout Verse
let
\begin_inset Formula $kmer$
\end_inset

 =
\begin_inset Formula $(q_{1},\,q_{2},\,...,q_{k})$
\end_inset

 where
\begin_inset Formula $q\in A$
\end_inset


\end_layout

\begin_layout Verse
\begin_inset Formula $hash(kmer)$
\end_inset

 =
\begin_inset Formula $\sum_{i=0}^{k}\:r(q_{i})\:\sigma^{k-i-1}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Verse
where
\begin_inset Formula $\sigma=\#A$
\end_inset

 ,
\begin_inset Formula $r(q_{i})\in\{0,1,...,\sigma-1\}$
\end_inset

 the rank of
\begin_inset Formula $q_{i}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
This hash guarantees no hash collisions and was furthermore chosen because
 the kmer-index is to be integrated and compared to the Seqan3 library which
 uses the same
\begin_inset CommandInset href
LatexCommand href
name "hash function"
target "http://docs.seqan.de/seqan/3-master-user/group__views.html#ga6e598d6a021868f704d39df73252974f"
literal "false"

\end_inset

.
 Constructing the kmer index is fairly straight-forward: We can simply iterate
 through the text while keeping track of the current position and adding
 it to the end of the appropriate entry for the current kmer.
 Given a text of length
\begin_inset Formula $n$
\end_inset

,
\begin_inset Formula $n-k$
\end_inset

 hashes will be generated and inserted into the index.
 Construction therefore has linear amortized complexity which is acceptable
 because for genomic data index construction will usually be done only once
 after which the index is serialized and can then be loaded directly if
 needed at a later point.
\end_layout

\begin_layout Section
Searching
\end_layout

\begin_layout Standard
To achieve greater flexibility the kmer-index implementation is capable
 of searching queries of arbitrary length regardless of the
\begin_inset Formula $k$
\end_inset

 that is used to create it.
 While a
\begin_inset Formula $k$
\end_inset

 still needs to be specified at compile time, at runtime any query can be
 searched; however the search functions performance will vary drastically
 depended on the queries length in relation to
\begin_inset Formula $k$
\end_inset

.

\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "section 3.1"

\end_inset

Query Size m = k
\end_layout

\begin_layout Standard
The best performing cases are queries of length exactly
\begin_inset Formula $k$
\end_inset

.
 For these a simple lookup in the indices unordered map will return all
 results at once:
\begin_inset Foot
status open

\begin_layout Plain Layout
All code examples henceforth are edited for brevity and only meant for the
 purpose of demonstrating the programs behavior unless otherwise specified.
 The actual implementations makes many concessions for the sake of performance
 and would be too lengthy to print here.
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset listings
lstparams "language={[GNU]C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

unordered_map<size_t, std::vector<uint32_t>> _data;
\end_layout

\begin_layout Plain Layout

uint64_t hash((...) query) const {(...)};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template<std::ranges::range query_t>
\end_layout

\begin_layout Plain Layout

std::vector<size_t>& search_k(query_t& query) const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	const auto* it = _data.at(hash(query));
\end_layout

\begin_layout Plain Layout

	if (it == _data.end())
\end_layout

\begin_layout Plain Layout

		return std::vector<size_t>();
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

		return *it;
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Search function for queries of size k.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
By nature of using an unordered map, querying a single entry has constant-time
 amortized complexity dependent on the number of pairwise different kmers
 in the text and therefore the number of different entries in
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{_data}
\end_layout

\end_inset

.
 C++s
\begin_inset CommandInset href
LatexCommand href
name "return value optimization"
target "https://en.cppreference.com/w/cpp/language/copy_elision"
literal "false"

\end_inset

 ensures that the positions are never actually copied and only a reference
 to them is moved between functions which other than the time it takes for
 the hash-function to return,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{search_k}
\end_layout

\end_inset

s runtime is very close to that of a single lookup in the map.
 This is the kmer-indices main strength and queries of length
\begin_inset Formula $k$
\end_inset

 should be considered a best-case scenario.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "Lemma 1"

\end_inset

Search performance for queries of size
\begin_inset Formula $m:\,m=k$
\end_inset

 is dependent on the absolute number of pairwise different hashes in the
 text
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "section m < k"

\end_inset

Query Size m < k
\end_layout

\begin_layout Standard
To be able to search queries of arbitrary length without modifying the indices
 internal structure for queries of length
\begin_inset Formula $m<k$
\end_inset

 we need to apply a different approach: As we cannot get the results for
 the query directly we instead return the positions of all kmers that have
 the query as a prefix.
\end_layout

\begin_layout Verse
let
\begin_inset Formula $query=(q_{1},q_{2},...,q_{m})$
\end_inset

 where
\begin_inset Formula $m<k$
\end_inset


\end_layout

\begin_layout Verse
for an arbitrary
\begin_inset Formula $kmer=(s_{1},...,s_{k})$
\end_inset

 it holds true that:
\end_layout

\begin_layout Verse
iff
\begin_inset Formula $\forall i\leq m:\:q_{i}=s_{i}$
\end_inset

 then any position
\begin_inset Formula $pos$
\end_inset

 of
\begin_inset Formula $kmer$
\end_inset

 is also a position of
\begin_inset Formula $query$
\end_inset


\end_layout

\begin_layout Verse
because the
\begin_inset Formula $m$
\end_inset

 characters proceeding
\begin_inset Formula $pos$
\end_inset

 are
\end_layout

\begin_layout Verse
\begin_inset Formula $s_{0},...,s_{m},...,s_{k}$
\end_inset

 and
\begin_inset Formula $s_{0},...,s_{m}=q_{0},...,\,q_{m}=query$
\end_inset


\end_layout

\begin_layout Standard
\noindent
To avoid generating all kmers that contain
\begin_inset Formula $query$
\end_inset

 as a prefix and then hashing them we instead generate the hashes directly.
\end_layout

\begin_layout Verse
let
\begin_inset Formula $hash(q_{1},q_{1},...,q_{m})=\sum_{i=0}^{k}\:r(q_{i})\:\sigma^{k-i}=h_{q}$
\end_inset

 constant as given by
\begin_inset Formula $query$
\end_inset


\end_layout

\begin_layout Verse
let
\begin_inset Formula $H\subset\mathbb{Z}^{+}\coloneqq$
\end_inset

 set of all hashes of kmer with a prefix equal to
\begin_inset Formula $query$
\end_inset


\end_layout

\begin_layout Verse
let
\begin_inset Formula $h_{min},\:h_{max}:\:\forall h_{i}\in H:\:h_{min}\leq h_{i}<h_{max}$
\end_inset

 be the lower and upper bound of
\begin_inset Formula $H$
\end_inset


\end_layout

\begin_layout Verse
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Verse
to find
\begin_inset Formula $h_{min}$
\end_inset

 we observe that as the query
\begin_inset Formula $q_{min}:\,r(q_{min})=h_{min}$
\end_inset

 has a prefix equal to
\begin_inset Formula $query$
\end_inset

 it holds true that
\end_layout

\begin_layout Verse
\begin_inset Formula $hash(h_{min})\geq h_{p}$
\end_inset

 because the first
\begin_inset Formula $m$
\end_inset

 summands
\begin_inset Formula $r(q_{min,j})\:\sigma^{k-j-1}:1\leq j\leq m$
\end_inset

 of the hash are given by the prefix
\end_layout

\begin_layout Verse
we choose the other summands
\begin_inset Formula $r(q_{i})\:\sigma^{k-i-1}:i>m$
\end_inset

 to all be as small as possible by choosing characters such that
\begin_inset Formula $\forall q_{i}:\:r(q_{i})=0$
\end_inset


\end_layout

\begin_layout Verse
thus
\begin_inset Formula $h_{min}=h_{p}+\sum_{i=m+1}^{k}\:0*\sigma^{k-i-1}=h_{p}$
\end_inset


\end_layout

\begin_layout Verse
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Verse
to find
\begin_inset Formula $h_{max}$
\end_inset

 we observe that
\begin_inset Formula $\#H=\sigma^{k-m}$
\end_inset

 because
\begin_inset Formula $m$
\end_inset

 characters of each query are given by the prefix
\end_layout

\begin_layout Verse
we furthermore observe that for two hashes
\begin_inset Formula $h_{a},\,h_{b}\in H:\,h_{a}<h_{b}$
\end_inset

the difference between the hashes
\begin_inset Formula $h_{a}-h_{b}\geq1$
\end_inset


\end_layout

\begin_layout Verse
this is because given
\begin_inset Formula $q_{a}=(a_{1},\,...,\,a_{k-1},\,a_{k})\::hash(q_{a})=h_{a}\neq h_{max}-1$
\end_inset

 to find the next smallest hash that is also in
\begin_inset Formula $H$
\end_inset

, we replace the last letter
\begin_inset Formula $a_{k}$
\end_inset

 with
\begin_inset Formula $\alpha_{k}$
\end_inset

 such that
\begin_inset Formula $r(a_{k})=r(\alpha_{k})+1$
\end_inset

.
 If
\begin_inset Formula $r(a_{k})=\sigma-1$
\end_inset

 we instead substitute
\begin_inset Formula $a_{k-1}$
\end_inset

, etc.
\end_layout

\begin_layout Verse
this means
\begin_inset Formula $hash(q_{a})$
\end_inset

 increases by
\begin_inset Formula $(r(a_{k})\:\sigma^{k-(k-1)})-(r(\alpha_{k})\:\sigma^{k-(k-1)})=1$
\end_inset


\end_layout

\begin_layout Verse
Given this information we can conclude
\begin_inset Formula $H=\{h_{p},\,h_{p}+1,\,...,\,h_{p}+\sigma^{k-m}-1\}$
\end_inset


\end_layout

\begin_layout Standard
This gives us far less costly way to generate all hashes in a simple for-loop:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={[GNU]C++},tabsize=2"
inline false
status open

\begin_layout Plain Layout

std::vector<size_t> check_last_kmer((...)) const;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template<std::ranges::range range_t>
\end_layout

\begin_layout Plain Layout

std::vector<size_t> search_sub_k(range_t& query) const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	size_t h_p = hash(query);
\end_layout

\begin_layout Plain Layout

	size_t h_min = 0 + h_p;
\end_layout

\begin_layout Plain Layout

	size_t h_max = h_p + pow(_sigma, k-query.size());
\end_layout

\begin_layout Plain Layout


\end_layout

\begin_layout Plain Layout

	// lookup each hash
\end_layout

\begin_layout Plain Layout

	std::vector<size_t> output_positions;
\end_layout

\begin_layout Plain Layout

	for (size_t h = h_min; h < h_max; ++h)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		for (size_t pos : _data.at(h))
\end_layout

\begin_layout Plain Layout

			output_positions.push_back(pos);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout


\end_layout

\begin_layout Plain Layout

	// cover edge case for last kmer
\end_layout

\begin_layout Plain Layout

	for (size_t pos : check_last_kmer(query))
\end_layout

\begin_layout Plain Layout

		output_positions.push_back(pos);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return output_positions;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Search function for queries of size 0 < m < k
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that after looking up all hashes depended on the query we also need
 to call
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{check_last_kmer}
\end_layout

\end_inset

.
 This is to cover an edge case were the query happens to be a sub-string
 of the last kmer in the text.
 As the query is compared against prefixes of all kmers and there is no
 kmer with a position
\begin_inset Formula $p>text.size()-k$
\end_inset

 the query is instead manually compared against the last
\begin_inset Formula $k-1$
\end_inset

 letters of the text.
\end_layout

\begin_layout Standard
While searching queries of length
\begin_inset Formula $m<k$
\end_inset

 is more costly than just a simple lookup it is feasible to search queries
 in a adequately fast manner if
\begin_inset Formula $k-m$
\end_inset

 is sufficiently small as this means the given prefix is in turn longer
 which means
\begin_inset Formula $\#H$
\end_inset

 and thus the number of hashes that need to be searched is minimal.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "Lemma 2"

\end_inset

search performance for queries of size
\begin_inset Formula $m:\,(k\mod m)\neq0\:\land m<k$
\end_inset

 is inversely proportional to
\begin_inset Formula $k-m$
\end_inset


\end_layout

\begin_layout Standard
The actual implementation throws an exception if
\begin_inset Formula $\sigma^{k-m}>10^{7}$
\end_inset

 in order to avoid a badly chosen
\begin_inset Formula $m$
\end_inset

 and
\begin_inset Formula $k$
\end_inset

 combination taking hours to complete given the amount of hashes that would
 have to be looked up.

\begin_inset Foot
status open

\begin_layout Plain Layout
While somewhat arbitrarily chosen,
\begin_inset Formula $10^{7}$
\end_inset

represents the case of
\begin_inset Formula $k-m>11$
\end_inset

 for the nucleotide alphabet (
\begin_inset Formula $\sigma=4$
\end_inset

) which should allow most users to be able to not encounter the exception
 during proper usage of the kmer-index and notably will mean for
\begin_inset Formula $k=10$
\end_inset

 queries of all length be accepted.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "section 3.3"

\end_inset

Query Size m > k
\end_layout

\begin_layout Standard
To search queries of length
\begin_inset Formula $m>k$
\end_inset

 the query is split into parts of length
\begin_inset Formula $k$
\end_inset

 which will then be searched individually.
 If
\begin_inset Formula $m\mod k\neq0$
\end_inset

 there will also be a part at the end (
\begin_inset Quotes eld
\end_inset

rest
\begin_inset Quotes erd
\end_inset

) with a length smaller than
\begin_inset Formula $k$
\end_inset

.

\end_layout

\begin_layout Standard
We observe that the set of positions for a specific query of length
\begin_inset Formula $m>k$
\end_inset

 is a subset of the positions of the first kmer
\begin_inset Formula $p_{1}$
\end_inset

, the queries prefix of length
\begin_inset Formula $k$
\end_inset

.
 To confirm whether a specific position of
\begin_inset Formula $p_{1}$
\end_inset

 is valid we cross-reference the positions of the following parts as such:
\end_layout

\begin_layout Verse
let query
\begin_inset Formula $q=(q_{1},\,q_{1},\,...,\,q_{m})$
\end_inset

 be of length
\begin_inset Formula $m:\:(m>k)\,\land(\,m\mod k\neq\text{0})$
\end_inset


\end_layout

\begin_layout Verse
let
\begin_inset Formula $p_{i}=(q_{i},\,...,q_{i+k})$
\end_inset

 with
\begin_inset Formula $i\in[1,\,(m-(m\mod k))/k]\subset\mathbb{N}$
\end_inset

 be the
\begin_inset Formula $i$
\end_inset

-th
\begin_inset Formula $k$
\end_inset

-long part of the query
\end_layout

\begin_layout Verse
let
\begin_inset Formula $r=(q_{m-(m\mod k)/k},\,...,q_{m})$
\end_inset

 be the rest of length
\begin_inset Formula $(m\mod k)$
\end_inset


\end_layout

\begin_layout Verse
then the query occurs at positions
\begin_inset Formula $\rho_{seed}\in pos(q_{1},...q_{k})=pos(p_{1})$
\end_inset

 iff
\end_layout

\begin_layout Verse
for all
\begin_inset Formula $i$
\end_inset

 there exists a position
\begin_inset Formula $\rho_{2}\in pos(p_{2})$
\end_inset

 such that
\begin_inset Formula $\rho_{2}=\rho_{seed}+k$
\end_inset

, and there exists a position
\begin_inset Formula $\rho_{3}\in pos(p_{3})$
\end_inset

 such that
\begin_inset Formula $\rho_{3}=\rho_{2}+k$
\end_inset

, etc.
\end_layout

\begin_layout Verse
For
\begin_inset Formula $\rho_{(m-(m\mod k))/k}\in pos(p_{last})$
\end_inset

 we need to check for a position
\begin_inset Formula $\rho_{rest}\in pos(rest)$
\end_inset

 so that
\begin_inset Formula $\rho_{rest}=\rho_{(m-(m\mod k))/k}+k$
\end_inset


\end_layout

\begin_layout Verse
If a
\begin_inset Formula $\rho$
\end_inset

 is found for all parts of the query is confirmed to occur at
\begin_inset Formula $\rho_{seed}$
\end_inset


\end_layout

\begin_layout Standard
For performance purposes if at any point the program does not find a fitting

\begin_inset Formula $\rho_{i}$
\end_inset

, the current position
\begin_inset Formula $\rho_{seed}$
\end_inset

 is marked as invalid and the loop moves onto the next.
 While in the worst-case (all position in
\begin_inset Formula $\rho_{seed}$
\end_inset

 are valid) performance would be relatively costly, in praxis this is rarely
 the case, especially for longer queries.
 We observe:
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "Lemma 3"

\end_inset

Search time for queries of size
\begin_inset Formula $m:\,m>k$
\end_inset

 scales inversely proportional to the number of results for the corresponding

\begin_inset Formula $p_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
Searching queries of length
\begin_inset Formula $m:m\mod k=0$
\end_inset

 (which do not have a rest) should be preferred as to find the positions
 of the rest we will need to employ
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{search_subk}
\end_layout

\end_inset

 which can result in a significant runtime increase, especially if the rest
 is short.

\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Multi kmer-Index
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec: multi k overview"

\end_inset

Overview
\end_layout

\begin_layout Standard
To further investigate the behavior implied by Lemmas 1 to 3 a benchmark
 was conducted.
 Queries of length
\begin_inset Formula $\{6,7,...,50\}$
\end_inset

 were searched by a kmer-index with a single
\begin_inset Formula $k=10$
\end_inset

 and the search calls duration to return was measured:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/multi_vs_single/single_only.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "figure 1"

\end_inset

Average duration to get all occurences of a query of given length using
 a kmer-index for
\begin_inset Formula $k=\{10\}$
\end_inset

.
 The inset graph shows a
\begin_inset Quotes eld
\end_inset

zoomed in
\begin_inset Quotes erd
\end_inset

 view of the area of query lengths
\begin_inset Formula $[16,29]$
\end_inset

.
 The dotted lines mark query lengths that are a multiples of
\begin_inset Formula $k$
\end_inset

.

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The results show a predictable pattern substantiating the above mentioned
 lemmas.
 Best performance is only achieved for query sizes
\begin_inset Formula $m:\:m\mod k=0$
\end_inset

 as this avoids having to search a rest with
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{search_subk}
\end_layout

\end_inset

.
 While queries of length
\begin_inset Formula $(n*k)-1,\,(n*k)-2:\:n\in\{1,2,...\}$
\end_inset

 still show acceptable performance, as the absolute difference between
\begin_inset Formula $m$
\end_inset

 and
\begin_inset Formula $k$
\end_inset

 increases the performance becomes worse (in accordance with Lemma
\begin_inset CommandInset ref
LatexCommand ref
reference "Lemma 2"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 For queries of length
\begin_inset Formula $m=(n*k)+1$
\end_inset

 results suggest a runtime increase of up to
\begin_inset Formula $6⁷\approx280\,000$
\end_inset

 times compared to best-case performance.
 Note that the peaks at
\begin_inset Formula $(n*k)+1$
\end_inset

 reduce in severity as query length increases.
 This is because with an increase in query length given a text of fixed
 size the number of results per query decreases and as stated in Lemma
\begin_inset CommandInset ref
LatexCommand ref
reference "Lemma 3"
plural "false"
caps "false"
noprefix "false"

\end_inset

 performance will improve slightly.
\end_layout

\begin_layout Standard
Given this behavior if we want to choose more
\begin_inset Formula $k$
\end_inset

 to improve average performance the most obvious addition would be to cover
 the previous
\begin_inset Formula $k$
\end_inset

s worst case performance: for example for
\begin_inset Formula $k_{1}=10$
\end_inset

 we would additionally choose
\begin_inset Formula $k_{2}=k_{1}+1=11$
\end_inset

,
\begin_inset Formula $k_{3}=k_{2}+1$
\end_inset

 and so on.
 Ideally we would just use every possible
\begin_inset Formula $k$
\end_inset

 in one index however due to memory limitations this is sometimes not feasible.
 As observed above, runtime for
\begin_inset Formula $m=k-1$
\end_inset

 was still satisfactory and thus
\begin_inset Formula $k_{i}=\{5,7,9,...,27,29,31\}$
\end_inset

 was chosen as a substitute to a multi kmer-index with perfect coverage:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/multi_vs_single/multi_vs_single.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Average search performance of multi and single kmer-index to find all occurrence
s of a query of given length in a text of size
\begin_inset Formula $10^{6}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Despite the sub-optimal coverage of the multi kmer-index, performance is
 still very close to optimal.
 Note how at query length 10 the single kmer-index shows faster performance
 than the multi kmer-index (c.f.
 the red vertical line in Figure 2).
 This illustrates the slight difference in performance between
\begin_inset Formula $k=m$
\end_inset

 (which is true for the single kmer-index for
\begin_inset Formula $m=10$
\end_inset

) and
\begin_inset Formula $k=m+1$
\end_inset

 (which is true for the multi kmer-index).
 Note further how after
\begin_inset Formula $m=33$
\end_inset

 (which results in 3 search calls with
\begin_inset Formula $k=11$
\end_inset

 and no rest and thus still performs adequately) runtime increases significantly.
 To investigate the multi-kmers index behavior for queries that cannot be
 searched as a single kmer we first need to detail how longer queries are
 handled outside of a single-k context.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "section 4.2"

\end_inset

How to choose the appropriate k
\end_layout

\begin_layout Standard
The success of the multi kmer-index relies heavily on both being provided
 a well-chosen set
\begin_inset Formula $ks$
\end_inset

 of
\begin_inset Formula $k_{i}$
\end_inset

 and furthermore using the appropriate
\begin_inset Formula $k_{i}$
\end_inset

 for a given query length.
 The latter is achieved by a table that at construction computes for every
 possible query length
\begin_inset Formula $m$
\end_inset

 a set of
\begin_inset Formula $\{k_{a},k_{b},...\}$
\end_inset

 such that
\begin_inset Formula $k_{a}+k_{b}+...=m$
\end_inset

.
 To achieve best performance we want the minimal set (in regards to cardinality)
 of
\begin_inset Formula $k_{i}$
\end_inset

 for and we furthermore want the
\begin_inset Formula $k_{i}$
\end_inset

 are chosen as big as possible which accordant with Lemma
\begin_inset CommandInset ref
LatexCommand ref
reference "Lemma 3"
plural "false"
caps "false"
noprefix "false"

\end_inset

 reduces runtime for longer queries.
 The table is constructed with a simple dynamic programming approach where
 to find the set of
\begin_inset Formula $k_{i}$
\end_inset

 for a given query
\begin_inset Formula $m_{j}$
\end_inset

 the already computed set for a queries
\begin_inset Formula $m_{a},m_{b}<m_{j}:m_{a}+m_{b}=m_{j}$
\end_inset

 are referenced back to.

\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Set of
\begin_inset Formula $k_{i}$
\end_inset

 for certain query lengths chosen from
\begin_inset Formula $k\in\{9,11,13,17\}$
\end_inset

 by the multi kmer-index.
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features booktabs="true" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
query length
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
summands
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
29
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9+9+11
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13+17
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
31
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9+9+13
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n/a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
33
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9+11+13
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Depending on the set of
\begin_inset Formula $k_{i}$
\end_inset

 supplied, not all query lengths may be possible to be represented with
 the supplied summands.
 In this case the kmer index falls back on calling
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{search_subk}
\end_layout

\end_inset

 for one of the summands.
 To find a set of
\begin_inset Formula $k_{i}$
\end_inset

 that covers most of the queries supplied by the user, the following recommendat
ions should be kept in mind:
\end_layout

\begin_layout Itemize
no
\begin_inset Formula $k_{i}$
\end_inset

 should be a multiple of another:
\begin_inset Formula $\lnot\exists k_{j}:k_{i}\mod k_{j}=0$
\end_inset

.
 This is to avoid redundancy as the higher
\begin_inset Formula $k_{i}$
\end_inset

will always be chosen
\end_layout

\begin_layout Itemize
all
\begin_inset Formula $k_{i}$
\end_inset

 should be as big as possible.
 As stated above this will decrease runtime however depending on memory
 limitations it may not always be possible
\end_layout

\begin_layout Itemize
small
\begin_inset Formula $k_{i}$
\end_inset

 should be avoided completey.
 If
\begin_inset Formula $k_{1}=3$
\end_inset

 is provided and is used for a sum, the index will have to crossreference
 all results for a single 3mer which depending on the text length may be
 far slower than just searching that query with
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{search_subk}
\end_layout

\end_inset

.
 Initial results suggest to not use any
\begin_inset Formula $k_{i}<10$
\end_inset

 and while they can still be supplied, the index will not use them for searching
 queries of bigger lengths unless unavoidable.
\end_layout

\begin_layout Standard
The author recommends for the set of
\begin_inset Formula $k_{i}$
\end_inset

 to be a subset of
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
{9, 11, 13, 17, 19, 21, 23, 27, 29, 31}
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
, primes are preferable because most queries will be able to be factorized
 into a subset of them.
 For example
\begin_inset Formula $\{11,13,17,19,21\}$
\end_inset

 will cover every query length
\begin_inset Formula $31<m\leq10000$
\end_inset

 and the
\begin_inset Formula $k$
\end_inset

 are small enough to be stored on less capable machines even with bigger
 texts such as an entire genome.
 Note that if searching for occurences of queries of length
\begin_inset Formula $m\in[3,31]$
\end_inset

 the query length should be directly supplied to the set of
\begin_inset Formula $k_{i}$
\end_inset

 as a length smaller than
\begin_inset Formula $min(ks)$
\end_inset

 cannot be represented as a sum of
\begin_inset Formula $k_{i}$
\end_inset

s.

\end_layout

\begin_layout Subsection
Comparison with fm-Index
\end_layout

\begin_layout Standard
To put the absolute values of the above figures into perspective, a comparative
 analysis of the fm-index
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that for exact string matching there's is no relevant performance differenc
e between the fm- and bi-fm-index.
\end_layout

\end_inset

 and a multi kmer-index was conducted and the relative speedup measured:
\end_layout

\begin_layout Verse
let
\begin_inset Formula $t_{fm<i>},t_{kmer<i>}$
\end_inset

 the search runtime for searching a query of length
\begin_inset Formula $i$
\end_inset

 with the corresponding index
\end_layout

\begin_layout Verse
then
\begin_inset Formula $\text{{speedup}}(i)=\begin{cases}
+(1-(t_{kmer<i>}/t_{fm<i>})) & \text{{if}\;}t_{kmer<i>}>t_{fm<i>}\\
-(1-(t_{fm<i>}/t_{kmer<i>})) & \text{{if}\;}t_{kmer<i>}<t_{fm<i>}\\
\,0 & \text{{else}}
\end{cases}$
\end_inset

|
\begin_inset Foot
status open

\begin_layout Plain Layout
To clarify, if
\begin_inset Formula $speedup(a,b)=+75\%$
\end_inset

 then
\begin_inset Formula $b$
\end_inset

 has a runtime of 1.75 the runtime of
\begin_inset Formula $a$
\end_inset

,
\begin_inset Formula $a$
\end_inset

 is 75% faster than
\begin_inset Formula $b$
\end_inset

; if
\begin_inset Formula $speedup(x,y)=-30\%$
\end_inset

 then
\begin_inset Formula $y$
\end_inset

 has a runtime fo 0.7 the runtime of
\begin_inset Formula $x$
\end_inset

,
\begin_inset Formula $x$
\end_inset

 is 30% slower than
\begin_inset Formula $y$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
For Query Lengths
\begin_inset Formula $m\in[3,30]$
\end_inset


\end_layout

\begin_layout Standard
When searching for smaller queries the approriate
\begin_inset Formula $k$
\end_inset

 should be directly supplied.
 The relative performance for a multi kmer-index with all
\begin_inset Formula $k\in$
\end_inset

 {3,4,...,30,31} was
\begin_inset CommandInset href
LatexCommand href
name "benchmarked"
target "https://github.com/google/benchmark"
literal "false"

\end_inset

 and compared against the fm-index:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/just_k/relative_speedup.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Relative speedup (in %) for search calls of the kmer-index vs.
 the fm-index per query length with a text size of
\begin_inset Formula $10⁸$
\end_inset

.
 The inset plot shows the absolute runtime (in ns).
 The multi kmer-index use
\begin_inset Formula $k\in$
\end_inset

 {3, 4, ..., 9, 10, 11, 12, ..., 31}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Results indicate that for bigger texts the kmer index will only perform
 better for relatively small
\begin_inset Formula $k$
\end_inset

.
 This is because the indices map is limited to a size of
\begin_inset Formula $\sigma^{k}$
\end_inset

 and as the kmer indices runtime for searching a single kmer is indepent
 from the number of results for that query, for bigger text higher
\begin_inset Formula $k$
\end_inset

 will vastly increase the maps size and thus the time it takes to traverse
 it.
 For sufficiently small texts however, all
\begin_inset Formula $k\in\{3,30\}$
\end_inset

will be faster to search and the overall speedup for short queries like
 these suggests that the kmer index should be preferred to search small
 kmers.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "table kmer faster while"

\end_inset

Average
\begin_inset Formula $speedup(t_{kmer},t_{fm})$
\end_inset

 in the interval
\begin_inset Formula $[3,30]$
\end_inset

 per text length.
 Results rounded to 1 decimal digit to account for noise in benchmark results.
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="5">
<features booktabs="true" tabularvalignment="middle" tabularwidth="100text%">
<column alignment="center" valignment="top" width="15text%">
<column alignment="right" valignment="top" width="10text%">
<column alignment="right" valignment="top" width="15text%">
<column alignment="right" valignment="top" width="15text%">
<column alignment="center" valignment="top" width="25text%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
text size
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mean
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
maximum
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mininum
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kmer faster while
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10³$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
21%
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64.9%
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.0%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 31
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10⁴$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19.3%
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64.2%
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.2%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 31
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10⁵$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17.3%
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
65.7%
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.4%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 31
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10⁶$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16.7%
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
58.8%
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.0%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 31
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10⁷$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9.4%
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
54.5%
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-4.6%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 22
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10⁸$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8.2%
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
62.1%
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-11.3%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 17
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10⁹$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
< 7%
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
48.9%
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
< -16.5%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 11
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
For arbitrary Query Lengths
\end_layout

\begin_layout Standard
To investigate the multi kmer-indices ability to be applied in general-purpose
 exact string matching scenarios a large-scale benchmark was conducted.
 For different text sizes, queries were searched with both indices and their
 relative performance measured:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/multi_kmer_vs_fm/5_1000/runtime_diff_over_text_size.png
	lyxscale 40
	width 100text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "figure 5_100"

\end_inset

Graphs showing
\begin_inset Formula $speedup(t_{kmer},t_{fm})$
\end_inset

 over query lengths for different text sizes.
 The grey area highlights query lengths [5, 30] which were excluded for
 the depicted median speedup.
 The multi kmer-index used all
\begin_inset Formula $k\in$
\end_inset

 {5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31}.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The benchmark suggests that for longer queries the kmer-index provides a
 slight speedup over the fm-index.
 With increasing text size this speedup decreases however.
 This is because as mentioned in section
\begin_inset CommandInset ref
LatexCommand ref
reference "section 3.3"
plural "false"
caps "false"
noprefix "false"

\end_inset

 the kmer at the higher end of [3,30] take a longer time to search for bigger
 texts which in turn means that the individuals kmers the queries are made
 for whom the multi kmer-index prioritizes the bigger k will take longer
 as well.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
In summary, the kmer-index has proofed superior for searching appropriately
 small kmers given the text length detailed in Table
\begin_inset CommandInset ref
LatexCommand ref
reference "table kmer faster while"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 While more testing will have to be done it seems reasonable to assume that
 kmer-index will always performa better for queries of length
\begin_inset Formula $m<10$
\end_inset

.
 For exact string matching of queries of arbitrary length the kmer index
 in it's current iteration should be preferred for smaller text sizes (
\begin_inset Formula $<10⁸$
\end_inset

) while the fm-index should proof more consistently performant for larger
 texts.
 However it may be possible to improve the kmer index with further features
 and if that achieves for example an additional speedup of 5% for longer
 queries, the kmer index may perform better than the fm-index for all relevant
 text sizes such as entire genomes.

\end_layout

\begin_layout Section
Outlook
\end_layout

\begin_layout Standard
To further improve performance and make the implementation generally more
 consistentlsapplicable the following additional features are proposed:
\end_layout

\begin_layout Subsection
>64 bit Hash
\end_layout

\begin_layout Standard
As mentioned above the datatype of the hashes is currently
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{uint64_t}
\end_layout

\end_inset

.
 64 bit integers were chosen because the standard C++ library does not currently
 support >64 bit integers natively and seqan3s kmer hash
\begin_inset CommandInset href
LatexCommand href
name "also uses them"
target "http://docs.seqan.de/seqan/3-master-user/group__views.html#ga6e598d6a021868f704d39df73252974f"
literal "false"

\end_inset

.
 However the size of the integer used for the hashes is arbitrary and expanding
 it to 128 or 256 bit would improve the maximum k that can still be searched
 with the overall faster
\begin_inset Formula $m=k$
\end_inset

 search function as it is currently limited to
\begin_inset Formula $<31$
\end_inset

 for the smallest relevant nucleotide alphabet.
 This may be especially important when working with bigger alphabets such
 as the complete list of
\begin_inset CommandInset href
LatexCommand href
name "IUPAC codes"
target "https://www.bioinformatics.org/sms/iupac.html"
literal "false"

\end_inset

 for nucleotides or clear text for which
\begin_inset Formula $\sigma=255$
\end_inset

.
 Furthermore in the application of read-mapping, reads are
\begin_inset CommandInset href
LatexCommand href
name "often of relatively short length"
target "https://www.illumina.com/science/technology/next-generation-sequencing/plan-experiments/read-length.html"
literal "false"

\end_inset

 and being able to for example find all positions of a 50mer or 75mer could
 give programs in this application a significant speedup compared to factorizing
 these queries into multiple smaller kmer.
 Further research will have to be done to verify wether abstracting the
 hash type for the kmer-index to use for example integers of up to 1024
 bit from boosts
\begin_inset CommandInset href
LatexCommand href
name "multiprecision header"
target "https://www.boost.org/doc/libs/1_62_0/libs/multiprecision/doc/html/boost_multiprecision/tut/ints/cpp_int.html"
literal "false"

\end_inset

 could proof valuable as it may not be feasible due to memory limitation
 or runtime overhead inherent to these integer types.
 Furthermore as
\begin_inset Formula $k$
\end_inset

 and thus the number of possible hashes increases the indices maps maximum
 size will also increase and as observed from Table
\begin_inset CommandInset ref
LatexCommand ref
reference "table kmer faster while"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for larger texts bigger k do not neccessarily result in a significane speedup.

\end_layout

\begin_layout Subsection
Multi kmer-index Compression
\end_layout

\begin_layout Standard
As has been shown in section
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec: multi k overview"
plural "false"
caps "false"
noprefix "false"

\end_inset

 using multiple k for the same index vastly increases the search performance
 for a broad variety of queries.
 Ideally we would want to just choose every possible k however memory limitation
s make this difficult.
 The kmer-index from Figure
\begin_inset CommandInset ref
LatexCommand ref
reference "figure 5_100"
plural "false"
caps "false"
noprefix "false"

\end_inset

 offered decent coverage by choosing about every second
\begin_inset Formula $k$
\end_inset

 in {9,10,...31} but for a text size of 10⁸ already occupied about 80gb of
 memory.
 While this is not unfeasible for stronger machines, as each map uses about

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\#H*64*n*32$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 (where
\begin_inset Formula $H$
\end_inset

 is the set of all pairwise different hashes,
\begin_inset Formula $n$
\end_inset

 is the text size) many bytes which for bigger text such as an entire genome
 means using every possible
\begin_inset Formula $k$
\end_inset

 is currently not practical.
 To remedy this it could be possible to implement a way to compress the
 single kmer-indices contained in the multi kmer-index.
 Each index contains all positions of the text in it's map exactly once
 which means in a multi kmer-index with 5 ks, the individual indices contain
 at least
\begin_inset Formula $(5-1)n*32$
\end_inset

 many bits of redundant entries in the form of the vectors of positions
 for each hash.
 If a version of the kmer-index is implemented that only contains all the
 texts positions once while still allowing for adequate runtime performance
 an all-purpose kmer-index could be proposed that simply holds information
 for all possible ks regardless of user configuration and thus achieves
 optimal performance in all cases.
\end_layout

\begin_layout Subsection
Hybrid Approach
\end_layout

\begin_layout Standard
As detailed above the performance peaks of the kmer-index are fairly consistentl
y predictable.
 A two-pronged approach is proposed in which for queries for whom we know
 the kmer-index will perform poorly the searching is instead done by a desperate
 fm-index.
 This allows for the now hybrid-index to have the speedup the kmer offers
 while also covering the inherent inconsistency by instead using the fm-index
 which performs highly consistently if sometimes worse.
 We can thus precalculate which queries should be searched with which index.
 The fm-index should be used to search a query of length
\begin_inset Formula $m$
\end_inset

 if and only if at least one of the following is true:
\end_layout

\begin_layout Itemize
the text size is
\begin_inset Formula $>10⁸$
\end_inset

 (c.f.
 Table
\begin_inset CommandInset ref
LatexCommand ref
reference "table kmer faster while"
plural "false"
caps "false"
noprefix "false"

\end_inset

)
\end_layout

\begin_layout Itemize
there is no set of
\begin_inset Formula $\{k_{a},k_{b},...\}$
\end_inset

 such that
\begin_inset Formula $k_{a}+k_{b}+...=m$
\end_inset


\end_layout

\begin_layout Standard
In all other cases preferring the kmer-index component may result in an
 overall speedup, however further research is needed to develop a better
 tested heuristic that substantiates these recommendations and is capable
 of determining a more exact text size (which may also be dependent on the
 alphabet used) which when exceeded might proof use of the hybrid index
 to be more trouble than it is worth given the need for increased memory
 capacity.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
The current kmer-index implementation is stable (c.f.
 Section
\begin_inset CommandInset ref
LatexCommand ref
reference "Addendum: Correctness"
plural "false"
caps "false"
noprefix "false"

\end_inset

 below), reasonably well optimized and the indices performance is superior
 for searching kmers of relatively small length
\begin_inset Formula $m<30$
\end_inset

 (or less than 30 for bigger texts as detailed in Table
\begin_inset CommandInset ref
LatexCommand ref
reference "table kmer faster while"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 For this purpose it achieved a performance increase of up to 65% and is
 thus well-suited and should be preferred to more generalist indices like
 the fm-index if runtime performance is important.
 For query lengths past 30 the kmer-index has been shown to have a performance
 increase between 5 and 10% for smaller texts of length
\begin_inset Formula $m<10⁸$
\end_inset

 while for bigger texts an overall performance change of
\begin_inset Formula $\pm2\%$
\end_inset

 depending on query length was observed.
 With further optimization and features the kmer-index may become the decidedly
 more performant index for exact string matching purposes in all situations
 however in it's current iterations it is only recommended for use with
 appropriately small text sizes.

\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Addendum
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "Addendum: Correctness"

\end_inset

Assuring Correctness
\end_layout

\begin_layout Standard
To assure that the kmer index returns the correct positions a
\begin_inset CommandInset href
LatexCommand href
name "test function"
target "https://github.com/google/googletest"
literal "false"

\end_inset

 was written that repeatedly compares results of the kmer-index and the
 fm-index for randomized queries and texts.
 This asserts that the fm-index itself is bug-free and as both indices are
 meant to be used in the same library this assertion was presumed to be
 reasonable.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Verse

\series bold
Input
\series default
: seed,
\begin_inset Formula $n$
\end_inset

,
\begin_inset Formula $m$
\end_inset


\end_layout

\begin_layout Verse

\series bold
while
\series default

\begin_inset Formula $(n>0)$
\end_inset


\series bold
do
\end_layout

\begin_deeper
\begin_layout Verse

\series bold
let
\series default
 text
\begin_inset Formula $\leftarrow$
\end_inset

 generate_sequence(
\begin_inset Formula $m$
\end_inset

, seed)
\end_layout

\begin_layout Verse

\series bold
let
\series default
 fm
\begin_inset Formula $\leftarrow$
\end_inset

 kmer_index(text)
\end_layout

\begin_layout Verse

\series bold
let
\series default
 kmer
\begin_inset Formula $\leftarrow$
\end_inset

 fm_index(text)
\end_layout

\begin_layout Verse

\series bold
for
\series default

\begin_inset Formula $q$
\end_inset


\series bold
in
\series default
 {k-1, k, k+1, ..., 2*k}
\series bold
do
\end_layout

\begin_deeper
\begin_layout Verse

\series bold
let
\series default
 query
\begin_inset Formula $\leftarrow$
\end_inset

 generate_sequence(q, seed)
\end_layout

\begin_layout Verse

\series bold
let
\series default
 result
\begin_inset Formula $_{fm}$
\end_inset


\begin_inset Formula $\leftarrow$
\end_inset

 fm.search(query)
\end_layout

\begin_layout Verse

\series bold
let
\series default
 result
\begin_inset Formula $_{kmer}$
\end_inset


\begin_inset Formula $\leftarrow$
\end_inset

 kmer.search(query)
\end_layout

\begin_layout Verse

\series bold
assert
\series default
 (result
\begin_inset Formula $_{fm}$
\end_inset

 = result
\begin_inset Formula $_{kmer}$
\end_inset

)
\end_layout

\end_deeper
\begin_layout Verse

\series bold
end
\end_layout

\begin_layout Verse
seed
\begin_inset Formula $\leftarrow$
\end_inset

 seed + 1
\end_layout

\begin_layout Verse
n
\begin_inset Formula $\leftarrow$
\end_inset

 n-1
\end_layout

\end_deeper
\begin_layout Verse

\series bold
end
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Test function comparing kmer- and fm-index results to assure correctness.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
While given enough iterations and a big enough text size it is reasonable
 to assume that this function will uncover possible bugs itself the text
 was furthermore manually modified to account for edge cases (such as the
 query happening at the very end of the text as detailed in Section
\begin_inset CommandInset ref
LatexCommand ref
reference "section m < k"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 If a discrepancy between the fm- and kmer-index was uncovered the function
 furthermore reported the exact seed and query size.
 The randomness in
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{generate_sequence}
\end_layout

\end_inset

 was implemented to be deterministic which made reproducing possible errors
 and what caused them reliable and easy.
 Before each benchmark presented in this paper correctness was assured with

\begin_inset Formula $n>10⁶$
\end_inset

 iterations using text sizes
\begin_inset Formula $m$
\end_inset

 as large as the machines memory allowed for.

\end_layout

\begin_layout Subsection
Performance Optimization
\end_layout

\begin_layout Standard
Implementation of the kmer-index was guided at every step by benchmarking
 newly implemented components and comparing their performance against other
 possible implementations.
 In this section the most relevant of these decisions are explained.
 Note that C++20 was used for all performance relevant code.
\end_layout

\begin_layout Subsubsection
Choosing the fastest Pow Implementation
\end_layout

\begin_layout Standard
By the nature of the hash, exponentiation (henceforth referred to as
\begin_inset Quotes eld
\end_inset

pow
\begin_inset Quotes erd
\end_inset

 in reference to the commonly used
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::pow}
\end_layout

\end_inset

) is used every search call sometimes multiple times.
 To optimize performance four different versions of pow were implemented
 and their performance evaluated.
 Note that for the purpose of the kmer-index the pow implementation will
 only ever be used with positive integers and has^ to be able to be evaluated
 at compile time.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{trivial_pow(base,n)}
\end_layout

\end_inset

: A trivial implementation calling
\begin_inset Formula $base*base$
\end_inset


\begin_inset Formula $n$
\end_inset

-many times
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{recursive_pow(base,n)}
\end_layout

\end_inset

: Utilizing a recursive approach, this function calls itself recursively

\begin_inset Formula $n$
\end_inset

-many times and then evaluates each call from the inside out to return the
 correct result based on whether the exponent was odd or even
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{bit_pow(base,n)}
\end_layout

\end_inset

: Utilizes bit-operations which are generally more well-optimized on most
 modern machines
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{switch_pow(base,n)}
\end_layout

\end_inset

: Instead of using a loop, this implementation has multiple switch cases
 with identical code, when the function is called a lookup in a pre-calculated
 table produces the correct first switch case to start with.
 The result
\begin_inset Quotes eld
\end_inset

falls through
\begin_inset Quotes erd
\end_inset

 the rest of the switch cases the correct number of times.
 Any exponentiation that would overflow the unsigned 64 bit integer result
 is immediately caught and 0 is returned instead.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
´
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/pow_vs_pow/pow_vs_pow.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Boxplot showing runtime distribution of average time to compute
\begin_inset Formula $x^{y}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Results indicate that the implementation utilizing the fall-through switch
 is overall the fastest and was thus used for the index whenever possible.
\end_layout

\begin_layout Subsubsection
Choosing the fastest Map
\end_layout

\begin_layout Standard
The unordered map is the data structure at the center of the kmer-index
 and as such assuring fast access time even for very large map sizes is
 necessary.
 As
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::unordered_map}
\end_layout

\end_inset

 did not proof sufficiently fast enough, other maps implemented by 3rd parties
 were tested and evaluated specifically in the context of use in a kmer-index:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::unordered_map}
\end_layout

\end_inset

 from the
\begin_inset CommandInset href
LatexCommand href
name "C++17 standard library"
target "https://en.cppreference.com/w/cpp/container/unordered_map"
literal "false"

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{boost::unordered_map}
\end_layout

\end_inset

 from the
\begin_inset CommandInset href
LatexCommand href
name "1.65.1 Boost Library"
target "https://www.boost.org/doc/libs/1_65_0/doc/html/boost/unordered_map.html"
literal "false"

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{absl::node_hash_map}
\end_layout

\end_inset

 from Googles
\begin_inset CommandInset href
LatexCommand href
name "Abseil"
target "https://abseil.io/docs/cpp/guides/container#abslnode_hash_map-and-abslnode_hash_set"
literal "false"

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{robin_hood::unordered_map}
\end_layout

\end_inset

 as provided by
\begin_inset CommandInset href
LatexCommand href
name "Martin Ankerl et. al."
target "https://github.com/martinus/robin-hood-hashing"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
Each map was filled with a fixed number of randomized elements and it's
 time to return a specific element was benchmarked.
 Only retrieval was tested here since after construction in the context
 of the kmer-index no insertion will take place.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/map_vs_map/map_vs_map.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Search performance for different map implementations over size of map.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Results indicate that
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{robin_hood::unordered_map}
\end_layout

\end_inset

 performed best regardless of the number of elements contained and was as
 such used as the central data structure for the kmer-index.
\end_layout

\begin_layout Subsection
Parallelization
\end_layout

\begin_layout Standard
Other than the amount of memory needed the only true disadvantage of using
 the multi kmer-index is the fact that the time it takes to construct increases
 drastically with the number of
\begin_inset Formula $k_{i}$
\end_inset

 specific.
 To address this a general purpose thread pool was implemented that allows
 all of the single kmer-index elements to be constructed in parallel:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

template<std::ranges::range text_t>
\end_layout

\begin_layout Plain Layout

multi_kmer_index(text_t& text)
\end_layout

\begin_layout Plain Layout

	: single_kmer_index<ks>()...
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	auto pool = kmer::detail::thread_pool{(...)};
\end_layout

\begin_layout Plain Layout

	std::vector<std::future<(...)>> futures;
\end_layout

\begin_layout Plain Layout

	(futures.emplace_back(
\end_layout

\begin_layout Plain Layout

		pool.execute(&single_kmer_index<ks>::create, text)), ...);
\end_layout

\begin_layout Plain Layout


\end_layout

\begin_layout Plain Layout

	// wait to finish
\end_layout

\begin_layout Plain Layout

	for (auto& f : futures)
\end_layout

\begin_layout Plain Layout

		f.get();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Paralell invocation of the create function for individual kmer-index elements
 during construction of the multi kmer-index.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As the number of possible
\begin_inset Formula $k$
\end_inset

 is currently restricted to at most 31, modern systems with 32 or more CPUs
 are capable of constructing one multi kmer-index with optimal coverage
 with no additional runtime overhead compared to a single-k index.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: megahit"
literal "false"

\end_inset

Dinghua Li, Chi-Man Liu, Ruibang Luo, Kunihiko Sadakane, Tak-Wah Lam, MEGAHIT:
 an ultra-fast single-node solution for large and complex metagenomics assembly
 via succinct de Bruijn graph, Bioinformatics, Volume 31, Issue 10, 15 May
 2015, Pages 1674–1676,
\begin_inset CommandInset href
LatexCommand href
target "https://academic.oup.com/bioinformatics/article/31/10/1674/177884"
literal "false"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: soapdenovo assembly"
literal "false"

\end_inset

 Yinlong Xie, Gengxiong Wu, Jingbo Tang, Ruibang Luo, Jordan Patterson,
 Shanlin Liu, Weihua Huang, Guangzhu He, Shengchang Gu, Shengkang Li, Xin
 Zhou, Tak-Wah Lam, Yingrui Li, Xun Xu, Gane Ka-Shu Wong, Jun Wang, SOAPdenovo-T
rans: de novo transcriptome assembly with short RNA-Seq reads, Bioinformatics,
 Volume 30, Issue 12, 15 June 2014, Pages 1660–1666,
\begin_inset CommandInset href
LatexCommand href
target "https://doi.org/10.1093/bioinformatics/btu077"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: taxonomical profiling"
literal "false"

\end_inset

A.
 Kishk et al., A Hybrid Machine Learning Approach for the Phenotypic Classificati
on of Metagenomic Colon Cancer Reads Based on Kmer Frequency and Biomarker
 Profiling, 2018 9th Cairo International Biomedical Engineering Conference
 (CIBEC), Cairo, Egypt, 2018, Pages 118-121,
\begin_inset CommandInset href
LatexCommand href
target "https://doi.org/10.1109/CIBEC.2018.8641805"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: kraken LCA"
literal "false"

\end_inset

Wood, D.E., Salzberg, S.L.
 Kraken: ultrafast metagenomic sequence classification using exact alignments.
 Genome Biol 15, R46 (2014),
\begin_inset CommandInset href
LatexCommand href
target "https://doi.org/10.1186/gb-2014-15-3-r46"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: spectrum dissimilarity"
literal "false"

\end_inset

Dubinkina, V.B., Ischenko, D.S., Ulyantsev, V.I.
 et al.
 Assessment of k-mer spectrum applicability for metagenomic dissimilarity
 analysis.
 BMC Bioinformatics 17, 38 (2016),
\begin_inset CommandInset href
LatexCommand href
target "https://doi.org/10.1186/s12859-015-0875-7"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: spectrum error correction"
literal "false"

\end_inset

Yongchao Liu, Jan Schröder, Bertil Schmidt, Musket: a multistage k-mer spectrum-
based error corrector for Illumina sequence data, Bioinformatics, Volume
 29, Issue 3, 1 February 2013, Pages 308–315,
\begin_inset CommandInset href
LatexCommand href
target "https://doi.org/10.1093/bioinformatics/bts690"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "seqan3 fm-index master"
literal "false"

\end_inset

Pockrandt, C.
 M.
 Generic implementation of a bidirectional FM-index in SeqAn and applications.
 Diss.
 Master’s thesis, Freie Universität Berlin, 2015.
\end_layout

\end_body
\end_document