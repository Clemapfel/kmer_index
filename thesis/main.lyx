#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\definecolor{gray}{rgb}{0.5, 0.5, 0.5}
\definecolor{keyword}{RGB}{243, 60, 114}
\definecolor{comment}{RGB}{0, 200, 101}
\definecolor{background}{rgb}{0.9, 0.9, 0.9}

\usepackage{listings}
\usepackage{xparse}

\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams-chap-bytype
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "beramono" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "keywordstyle={\bfseries \color{keyword}},commentstyle={\color{comment}},caption={Search function for exact matches for a query of size 0 < m < k $^{[1]}$},captionpos=b,backgroundcolor={\color{background}},basicstyle={\ttfamily\small},language={C++},numbers=none,captionpos=b,tabsize=2"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Implementation and Performance Evaluation of a k-mer Index for exact String
 Matching
\end_layout

\begin_layout Author
Author: Clemens Cords, FU Berlin
\end_layout

\begin_layout Abstract
As demand for large-scale genomic sequtext ence matching rises so does the
 ability to efficiently get the positions or number of occurences for an
 exact query of length k called a kmer.
 A kmer index optimized for this purposes was implemented and it's performance
 evaluated.
 The implementation is capable of searching kmers of arbitrary length specified
 at run-time, utilizes parallelization for faster construction and searching
 of multiple queries at once and it's internal structure can be further
 customized at compile time to achieve greater performance for certain query
 sizes.
 The exact nature of the implementation-defined optimizations is explained
 and their performant nature demonstrated through benchmarks.
 Results indicate that for the purpose of finding positions or number of
 occurences for queries of abitrary length including the commonly used 
\begin_inset Formula $k\in\{3,4,...,30\}$
\end_inset

 compared to the fm-index the kmer index performs up to 70% times faster
 for smaller text sizes (
\begin_inset Formula $<10โธ$
\end_inset

), for larger texts the kmer index should only be considered to search smaller
 queries of length 
\begin_inset Formula $m\leq17$
\end_inset

.
 Overall the kmer index should provide a more performant alternative for
 searching short kmers and for smaller texts may proof useful for general-purpos
e exact string matching for sequences of arbitrary lengths.
\end_layout

\begin_layout Section*
Motivation
\end_layout

\begin_layout Standard
A k-mer (also known as 
\begin_inset Quotes eld
\end_inset

q-gram
\begin_inset Quotes erd
\end_inset

, henceforth written as 
\begin_inset Quotes eld
\end_inset

kmer
\begin_inset Quotes erd
\end_inset

) is any genomic sequence of length 
\begin_inset Formula $k$
\end_inset

, usually in the context of being a subsequence of a longer text.
 Analysis of kmers is used in a wide variety of contexts such as in denovo
 genome assembly
\begin_inset CommandInset citation
LatexCommand cite
key "kmer: megahit assembly,kmer: soapdenovo assembly"
literal "false"

\end_inset

, taxonomic profiling
\begin_inset CommandInset citation
LatexCommand cite
key "kmer: taxonomical profiling"
literal "false"

\end_inset

 and sequence classification
\begin_inset CommandInset citation
LatexCommand cite
key "kmer: kraken LCA"
literal "false"

\end_inset

.
 Furthermore kmer spectra (number of occurences of each kmer in the set
 of pairwise different kmers in the reference) have been used to assess
 genome similarity
\begin_inset CommandInset citation
LatexCommand cite
key "kmer: spectrum dissimilarity"
literal "false"

\end_inset

 and to correct errors in sequence data
\begin_inset CommandInset citation
LatexCommand cite
key "kmer: spectrum error correction"
literal "false"

\end_inset

.
 Seqan3, a newly released version of the C++ API for sequence analysis has
 yet to implement a purpose-build index for kmer searching.
 This paper aims to access the viability and performance increase of substitutin
g seqan3 fm-index
\begin_inset CommandInset citation
LatexCommand cite
key "seqan3 fm-index master"
literal "false"

\end_inset

 with the presented kmer-index implementation not only for the purpose of
 searching kmers but for exact string matching in general.
\end_layout

\begin_layout Section
Construction
\end_layout

\begin_layout Standard
The kmer index utilizes an unordered map as it's central data structure,
 saving for each kmer the position of all occurences in the text.
 To save on memory the kmer are converted to an unsigned integer via the
 following hash function:
\end_layout

\begin_layout LyX-Code
let 
\begin_inset Formula $kmer$
\end_inset

 = 
\begin_inset Formula $(q_{1},\,q_{2},\,...,q_{k})$
\end_inset

 where 
\begin_inset Formula $q\in A$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $hash(kmer)$
\end_inset

 = 
\begin_inset Formula $\sum_{i=0}^{k}\:r(q_{i})\:\sigma^{k-i-1}$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout LyX-Code
where 
\begin_inset Formula $\sigma=\#A$
\end_inset

 , 
\begin_inset Formula $r(q_{i})\in\{0,1,...,\sigma-1\}$
\end_inset

 is the rank of 
\begin_inset Formula $q_{i}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
This hash guarantees no hash collisions
\begin_inset CommandInset citation
LatexCommand cite
key "seqan2 doctor arbeit"
literal "false"

\end_inset

 and was furthermore chosen because the kmer index is to be integrated and
 compared to the seqan3 library which uses the same hash function
\begin_inset CommandInset citation
LatexCommand cite
key "seqan3 docs: kmer hash"
literal "false"

\end_inset

.
 Constructing the kmer is fairly straight-forward: We can simply iterate
 through the text, adding the current positions to the back of the entry
 for the corresponding kmer:
\begin_inset Foot
status open

\begin_layout Plain Layout
All code examples henceforth used here are edited for brevity and only meant
 for the purpose of demonstrating the programs behavior unless otherwise
 specified.
 The actual implementations makes many concessions for the sake of performance
 that can be viewed in it's entirety in the actual code
\begin_inset CommandInset citation
LatexCommand cite
key "my github"
literal "false"

\end_inset

 and would be too lengthy to print here.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

template<size_t k, typename position_t>
\end_layout

\begin_layout Plain Layout

class kmer_index { 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

private: unordered_map<uint64_t, std::vector<position_t> _data;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template<std::ranges::range text_t>
\end_layout

\begin_layout Plain Layout

public: void create(text_t text)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	auto hashes = text | views::kmer_hash<k>;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	size_t position = 0;
\end_layout

\begin_layout Plain Layout

	for (auto hash : hashes) {
\end_layout

\begin_layout Plain Layout

		if (_data.find(hash) == _data.end())
\end_layout

\begin_layout Plain Layout

			_data.insert(hash, std::vector<position_t>());
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		_data[hash].push_back(position);
\end_layout

\begin_layout Plain Layout

		++position;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
The kmer indices create function is called during construction.
\begin_inset Formula $ยน$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Given a text of length 
\begin_inset Formula $n$
\end_inset

, 
\begin_inset Formula $n-k$
\end_inset

 hashes will be generated and inserted into the index.
 Thus the creation function has linear complexity which is acceptable because
 for genomic data, index construction will usually be done only once and
 then serialized to be loaded directly if needed at a later point.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Searching
\end_layout

\begin_layout Standard
To achieve greater flexibility the kmer index implementation is capable
 of searching queries of arbitary length.
 While a specific k still needs to be specified at compile time, at runtime
 any query can be searched however the search functions performance will
 vary drastically dependend on the queries length in relation to k.
\end_layout

\begin_layout Subsection
Query Size m = k
\end_layout

\begin_layout Standard
The best performing cases are queries of length exactly k.
 For these a simple lookup in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{_data}
\end_layout

\end_inset

 will return all results at once: 
\end_layout

\begin_layout LyX-Code
\begin_inset listings
lstparams "language={[GNU]C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

uint64_t hash((...) query) const {(...)};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template<std::ranges::range query_t>
\end_layout

\begin_layout Plain Layout

std::vector<size_t>& search_k(query_t& query) const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	const auto* it = _data.at(hash(query));
\end_layout

\begin_layout Plain Layout

	if (it == _data.end())
\end_layout

\begin_layout Plain Layout

		return std::vector<size_t>();
\end_layout

\begin_layout Plain Layout

	else 
\end_layout

\begin_layout Plain Layout

		return *it;
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Search function for queries of size k.
\begin_inset Formula $ยน$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
By the nature of using an unordered map, it has average constant-time complexity
 dependent on the number of entries of map 
\begin_inset Formula $\#H_{text}$
\end_inset

 (where 
\begin_inset Formula $H_{text}\coloneqq$
\end_inset

 set of different hashes occurring in text).
 The search calls runtime is nearly completely made up of the runtime of
 hashing the query and the time it takes to traverse it's 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{_data}
\end_layout

\end_inset

.
 C++s return value optimization
\begin_inset CommandInset citation
LatexCommand cite
key "cpp RVO"
literal "false"

\end_inset

 ensures that the positions are never actually copied and only a reference
 to them is moved between functions.
 The exceptional performance of this mode of searching is the kmer indices
 strength and queries of length 
\begin_inset Formula $k$
\end_inset

 should be considered the best-case scenario.
\end_layout

\begin_layout Lemma
Search performance for queries of size 
\begin_inset Formula $m:\,m=k$
\end_inset

 is dependent on the absolute number of pairwise different hashes in the
 text
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Query Size m < k
\end_layout

\begin_layout Standard
To be able to search queries of arbitrary length without modifying the index,
 a different approach than a simple lookup has to be take for queries of
 length 
\begin_inset Formula $m<k$
\end_inset

.
 We do this by instead searching for the positions of all kmer that have
 the query as a prefix:
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $query=(q_{1},\,q_{2},\,...,\,q_{m})$
\end_inset

 where 
\begin_inset Formula $m<k$
\end_inset

 
\end_layout

\begin_layout Verse
for an arbitrary 
\begin_inset Formula $kmer=(s_{1},\,...,\,s_{k})$
\end_inset

 it holds true that 
\end_layout

\begin_layout Verse
iff 
\begin_inset Formula $\forall i\leq m:\:q_{i}=s_{i}$
\end_inset

 then any position 
\begin_inset Formula $pos$
\end_inset

 of 
\begin_inset Formula $kmer$
\end_inset

 is also a position of 
\begin_inset Formula $query$
\end_inset


\end_layout

\begin_layout Verse
because the 
\begin_inset Formula $m$
\end_inset

 characters proceeding 
\begin_inset Formula $pos$
\end_inset

 are 
\end_layout

\begin_layout Verse
\begin_inset Formula $s_{0},\,...,\,s_{m},\,...,\,s_{k}$
\end_inset

 and 
\begin_inset Formula $s_{0},\,...,\,s_{m}=q_{0},\,...,\,q_{m}=query$
\end_inset


\end_layout

\begin_layout Standard
\noindent
To avoid generating all kmers that contain 
\begin_inset Formula $query$
\end_inset

 as a prefix and then hashing them, we generate the hashes directly, skipping
 that step and increasing performance:
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $hash(q_{1},\,q_{1},\,...,\,q_{m})=\sum_{i=0}^{k}\:r(q_{i})\:\sigma^{k-i}=h_{q}$
\end_inset

, constant
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $H\subset\mathbb{Z}^{+}\coloneqq$
\end_inset

 set of all hashes of kmers with a prefix equal to 
\begin_inset Formula $query$
\end_inset


\end_layout

\begin_layout Verse
let 
\begin_inset Formula $h_{min},\:h_{max}:\:\forall h_{i}\in H:\:h_{min}\leq h_{i}<h_{max}$
\end_inset

 be the lower and upper bound of 
\begin_inset Formula $H$
\end_inset


\end_layout

\begin_layout Verse
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Verse
to find 
\begin_inset Formula $h_{min}$
\end_inset

 we observe that as the query 
\begin_inset Formula $q_{min}:\,r(q_{min})=h_{min}$
\end_inset

 has a prefix equal to 
\begin_inset Formula $query$
\end_inset

 it holds true that 
\end_layout

\begin_layout Verse
\begin_inset Formula $hash(h_{min})\geq h_{p}$
\end_inset

 because the first 
\begin_inset Formula $m$
\end_inset

 summands 
\begin_inset Formula $r(q_{min,j})\:\sigma^{k-j-1}:1\leq j\leq m$
\end_inset

 of the hash are given by the prefix
\end_layout

\begin_layout Verse
we choose the other summands 
\begin_inset Formula $r(q_{i})\:\sigma^{k-i-1}:i>m$
\end_inset

 to all be as small as possible by using characters such that 
\begin_inset Formula $\forall q_{i}:\:r(q_{i})=0$
\end_inset

 
\end_layout

\begin_layout Verse
thus 
\begin_inset Formula $h_{min}=h_{p}+\sum_{i=m+1}^{k}\:0*\sigma^{k-i-1}=h_{p}$
\end_inset


\end_layout

\begin_layout Verse
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Verse
to find 
\begin_inset Formula $h_{max}$
\end_inset

 we observe that 
\begin_inset Formula $\#H=\sigma^{k-m}$
\end_inset

 because 
\begin_inset Formula $m$
\end_inset

 characters of each query are given by the prefix
\end_layout

\begin_layout Verse
we furthermore observe that for two hashes 
\begin_inset Formula $h_{a},\,h_{b}\in H:\,h_{a}<h_{b}$
\end_inset

the difference between the hashes 
\begin_inset Formula $h_{a}-h_{b}\geq1$
\end_inset


\end_layout

\begin_layout Verse
This is because given 
\begin_inset Formula $q_{a}=(a_{1},\,...,\,a_{k-1},\,a_{k})\::hash(q_{a})=h_{a}\neq h_{max}-1$
\end_inset

 to find the next smallest hash that is also in 
\begin_inset Formula $H$
\end_inset

, we replace 
\begin_inset Formula $a_{k}$
\end_inset

with 
\begin_inset Formula $\alpha_{k}$
\end_inset

such that 
\begin_inset Formula $r(a_{k})=r(\alpha_{k})+1$
\end_inset


\end_layout

\begin_layout Verse
This means that 
\begin_inset Formula $hash(q_{a})$
\end_inset

 increases by 
\begin_inset Formula $(r(a_{k})\:\sigma^{k-(k-1)})-(r(\alpha_{k})\:\sigma^{k-(k-1)})=1$
\end_inset


\end_layout

\begin_layout Verse
Given this information we can conclude 
\begin_inset Formula $H=\{h_{p},\,h_{p}+1,\,h_{p}+1,\,...,\,h_{p}+\sigma^{k-m}-1\}$
\end_inset

 
\end_layout

\begin_layout Standard
This gives us far less costly way to generate all hashes in a simple for-loop:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={[GNU]C++},basicstyle={\normalsize\ttfamily},tabsize=2"
inline false
status open

\begin_layout Plain Layout

std::vector<size_t> check_last_kmer(...) const
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template<std::ranges::range range_t>
\end_layout

\begin_layout Plain Layout

std::vector<size_t> search_sub_k(range_t& query) const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	size_t size = query.size();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	size_t h_p = hash(query);                     			
\end_layout

\begin_layout Plain Layout

	size_t h_min = 0 + h_p;                 			
\end_layout

\begin_layout Plain Layout

	size_t h_max = h_p + pow(_sigma, k-size);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	// lookup each hash and return
\end_layout

\begin_layout Plain Layout

	std::vector<size_t> output_positions;
\end_layout

\begin_layout Plain Layout

	for (size_t h = h_min; h < h_max; ++h) 
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		for (size_t pos : _data.at(h))
\end_layout

\begin_layout Plain Layout

			output_positions.push_back(pos);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	// cover edge case for last kmer
\end_layout

\begin_layout Plain Layout

	for (size_t pos : check_last_kmer(query))
\end_layout

\begin_layout Plain Layout

		output_positions.push_back(pos);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return output_positions;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Search function for queries of size 0 < m < k 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that after looking up all hashes dependend on the query, we also need
 to call 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{check_last_kmer}
\end_layout

\end_inset

.
 This is to cover an edge case were the query happens to be a substring
 of the last kmer in the text.
 As the query is compared against prefixes of all kmers and there is no
 kmer with a position 
\begin_inset Formula $p>text.size()-k$
\end_inset

 so the query is manually compared against the last 
\begin_inset Formula $k-1$
\end_inset

 letters in the text each search call.
 While this way of searching is more costly than just a simple lookup it
 is feasable to search queries in a sufficiently fast way if the prefix
 is as long as possible as this means the set of hashes 
\begin_inset Formula $H$
\end_inset

 is relatively small.
\end_layout

\begin_layout Lemma
search performance for queries of size 
\begin_inset Formula $m:\,(k\mod m)\neq0\:\land m<k$
\end_inset

 is inversely proportional to 
\begin_inset Formula $k-m$
\end_inset


\end_layout

\begin_layout Standard
The actual implementation throws an exception if 
\begin_inset Formula $\sigma^{k-m}>10^{7}$
\end_inset

because a badly chosen 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $k$
\end_inset

 combination could take many hours to complete given the amount of kmers
 that would have to be looked up.
\begin_inset Foot
status open

\begin_layout Plain Layout
While somewhat arbitrarily chosen, 
\begin_inset Formula $10^{7}$
\end_inset

represents the case of 
\begin_inset Formula $k-m>11$
\end_inset

 for the nucleotide alphabet (
\begin_inset Formula $\sigma=4$
\end_inset

) which should allow most users to be able to not encounter the exception
 during proper usage of the kmer index and notably will mean for 
\begin_inset Formula $k=10$
\end_inset

 queries of all length be accepted.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Query Size m > k
\end_layout

\begin_layout Standard
For longer queries the query is split into parts of length 
\begin_inset Formula $k$
\end_inset

 which will then be searched individually.
 If 
\begin_inset Formula $m\mod k\neq0$
\end_inset

 there will also be a part at the end (
\begin_inset Quotes eld
\end_inset

rest
\begin_inset Quotes erd
\end_inset

) with a length 
\begin_inset Formula $<k$
\end_inset

.
 We observe that the set of positions for a specific query of length 
\begin_inset Formula $m>k$
\end_inset

 is a subset of the positions of the first kmer 
\begin_inset Formula $p_{1}$
\end_inset

which the queries prefix of length k.
 To confirm wether a specific position of 
\begin_inset Formula $p_{1}$
\end_inset

is valid, we crossreference the positions with the next part:
\end_layout

\begin_layout Verse
let query 
\begin_inset Formula $q=(q_{1},\,q_{1},\,...,\,q_{m})$
\end_inset

 be of length 
\begin_inset Formula $m:\:m>k\,\land\,m\mod k\neq0$
\end_inset


\end_layout

\begin_layout Verse
let 
\begin_inset Formula $p_{i}=(q_{i},\,...,q_{i+k})$
\end_inset

 with 
\begin_inset Formula $i\in[1,\,(m-(m\mod k))/k]\subset\mathbb{N}$
\end_inset

 be the 
\begin_inset Formula $i$
\end_inset

-th kmer part in the query
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $r=(q_{m-(m\mod k)/k},\,...,q_{m})$
\end_inset

 be the rest of length 
\begin_inset Formula $m\mod k$
\end_inset


\end_layout

\begin_layout Verse
then the query occurs at positions 
\begin_inset Formula $pos(q_{seed})\in pos(q_{1},...q_{k})=pos(p_{1})$
\end_inset

 iff
\end_layout

\begin_layout Verse
there exists at position 
\begin_inset Formula $\rho_{2}\in pos(p_{2})$
\end_inset

 such that 
\begin_inset Formula $\rho_{2}=q_{seed}+k$
\end_inset

, and there exists a position 
\begin_inset Formula $\rho_{3}\in pos(p_{3})$
\end_inset

 such that 
\begin_inset Formula $\rho_{3}=\rho_{2}+k$
\end_inset

, etc for all 
\begin_inset Formula $i$
\end_inset


\end_layout

\begin_layout Verse
For 
\begin_inset Formula $\rho_{(m-(m\mod k))/k}$
\end_inset

 inside the last non-rest part we also need to check for a position 
\begin_inset Formula $\rho_{rest}\in pos(rest)$
\end_inset

 so that 
\begin_inset Formula $\rho_{rest}=\rho_{i+k}+k$
\end_inset


\end_layout

\begin_layout Standard
For perfomance purposes if at any point the program does not find a fitting
 
\begin_inset Formula $\rho_{i}$
\end_inset

, the current position in 
\begin_inset Formula $pos(q_{seed})$
\end_inset

 is marked as invalid and the loop moves onto the next.
 While the worst-case performance (all position in 
\begin_inset Formula $pos(q_{seed})$
\end_inset

 are valid) is very costly this behavior also results in an important fact
 about the functions performance:
\end_layout

\begin_layout Lemma
Search time for queries of size 
\begin_inset Formula $m:\,m>k$
\end_inset

 scales inversely proportional to the number of results for the corresponding
 
\begin_inset Formula $p_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
Even still queries of length 
\begin_inset Formula $m:m\mod k$
\end_inset

 should be preferred as if that is not the case, having to search the rest
 will introduce a significant overhead to the functions performance.
\end_layout

\begin_layout Subsection
Choosing the right k
\end_layout

\begin_layout Standard
In praxis both the texts size and the queries and thus their lengths are
 given and cannot be controlled by the user.
 
\begin_inset Formula $k$
\end_inset

 however can be freely chosen.
 Given Lemma #1 we should choose 
\begin_inset Formula $k$
\end_inset

 as small as possible as this means the size of the map will be limited.
 For example it is reasonable to assume that in a text of length 
\begin_inset Formula $10^{7}$
\end_inset

 all 
\begin_inset Formula $5$
\end_inset

-mers will occur at least once limiting the map to a size of 
\begin_inset Formula $\sigma^{5}=1024$
\end_inset

 which is most likely far less than the number of pairwise different 
\begin_inset Formula $25$
\end_inset

-mers that will occur in the text.
 Given Lemma #3 however we should choose 
\begin_inset Formula $k$
\end_inset

s that are used to search longer queries as big as possible
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that we are not only limited by the machines memory but also the fact
 that the kmer hashes have to fit in a 64-bit unsigned integer which necessitate
s an alphabet and k combination so that 
\begin_inset Formula $\sigma^{k}<2^{64}$
\end_inset

.
 For the 4-letter dna alphabet, this means k can at most be 31 while for
 bigger alphabets, k has to be chosen far lower.
\end_layout

\end_inset

 as for a bigger k the absolute number of results per kmer and thus the
 number of results for each 
\begin_inset Formula $p_{i}$
\end_inset

 that have to be crossreference will decrease.
 Furthermore 
\begin_inset Formula $k$
\end_inset

 should be chosen so the most amount of queries are of length 
\begin_inset Formula $k$
\end_inset

 directly or divisible by 
\begin_inset Formula $k$
\end_inset

.
 In praxis this is not possible, especially for more heterogenous sets of
 queries.
 As such the kmer index implementation was extended to unify multiple kmer
 indices at once.
 This 
\begin_inset Quotes eld
\end_inset

multi kmer index
\begin_inset Quotes erd
\end_inset

 is then able to automatically choose which 
\begin_inset Formula $k$
\end_inset

 would be optimal for any given query, thus coverd a far wider array of
 query lengths optimally.
\end_layout

\begin_layout Section
Multi kmer Index
\end_layout

\begin_layout Standard
To further investigate the behavior the three Lemmas in section 2 imply,
 a benchmark was conducted.
 For a kmer index with a single 
\begin_inset Formula $k=10$
\end_inset

, queries starting of length 
\begin_inset Formula $\{6,7,...,50\}$
\end_inset

 were searched and the search calls duration to return was measured:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/multi_vs_single/single_only.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Runtime duration of searching queries with the kmer index for 
\begin_inset Formula $k=\{10\}$
\end_inset

.
 The inset graph is showing a 
\begin_inset Quotes eld
\end_inset

zoomed in
\begin_inset Quotes erd
\end_inset

 view of the area for query lengths 16 to 20.
 The dotted lines mark query lengths that are a multiple of 
\begin_inset Formula $k$
\end_inset

.
 
\end_layout

\end_inset


\end_layout

\end_inset

The results show a predicatble pattern substantiating the above mentioned
 lemmas.
 Best performance is only achieved for query sizes 
\begin_inset Formula $m:\:m\mod k=0$
\end_inset

 because searching each of the up to 6 parts of the query is the best case
 scenario.
 While queries of length 
\begin_inset Formula $(n*k)-1,\,(n*k)-2:\:n\in{1,2,...}$
\end_inset

still show acceptable performance however in accordance with Lemma #2 as
 the absolute difference of query size and k increases the performance becomes
 worse.
 For queries of length 
\begin_inset Formula $(n*k)+1$
\end_inset

 performance becomes unusable showing a runtime increase of up to 
\begin_inset Formula $5e7$
\end_inset

 times compared to best-case performance.
 Not that the peaks at 
\begin_inset Formula $(n*k)+1$
\end_inset

 reduce in severity as query length increases.
 This is because with the increase in query length given a text of fixed
 length the number of results decreases and thus due to Lemma #3 the function
 shows better performance.
 Given the option to specify multiple k, the most obvious addition would
 be to cover the previous 
\begin_inset Formula $k$
\end_inset

s worst case performance: for example for 
\begin_inset Formula $k_{1}=10$
\end_inset

 we would additionally choose 
\begin_inset Formula $k_{2}=k_{1}+1$
\end_inset

, 
\begin_inset Formula $k_{3}=k_{2}+1$
\end_inset

 and so on.
 Ideally we would just use every possible k in one index however due to
 memory limitations this is sometimes not feasable.
 As observed above, runtime for 
\begin_inset Formula $m=k-1$
\end_inset

 was still satisfactory and thus 
\begin_inset Formula $k_{i}=\{5,7,9,...,27,29\}$
\end_inset

 was used to test wether the now 
\begin_inset Quotes eld
\end_inset

multi
\begin_inset Quotes erd
\end_inset

 kmer index would perform better:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/multi_vs_single/multi_vs_single.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Search Performance for multi kmer and single kmer index (for a text size
 of 1e6 as these results are from the same benchmark session as Figure 1).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Even though the multi kmer index only utilizes 
\begin_inset Formula $k_{i}$
\end_inset

 so that for all 
\begin_inset Formula $m\in[5,30]:\exists k_{i}:k_{i}=m\lor k=m+1$
\end_inset

performance is still near optimal.
 Note how at query length 10 the single kmer index is faster (c.f.
 the red vertical line in Figure 2).
 This illlustrates the slight difference in performance between 
\begin_inset Formula $k=m$
\end_inset

 (which is true for the single kmer index for 
\begin_inset Formula $m=10$
\end_inset

) and 
\begin_inset Formula $k=m+1$
\end_inset

(which is true for the multi kmer index).
 Note further how after 
\begin_inset Formula $m=33$
\end_inset

 (which results in 3 search calls with 
\begin_inset Formula $k=11$
\end_inset

and no rest and thus still performs adequately) runtime increases significantly.
 Further more at 
\begin_inset Formula $m=47$
\end_inset

 performances spikes almost to the same level as for the single kmer index
 because 47 is a prime meaning there can't be a 
\begin_inset Formula $k\in\{5,7,...,29\}$
\end_inset

 that it could be divisible by.
 This is true for all primes past 31 (or lower than 31 for bigger 
\begin_inset Formula $\sigma$
\end_inset

).
 
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
At this point to put the absolute values of the above figures into perspective,
 a comparative analysis of the fm-index
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that for exact string matching there's is no relevant performance differenc
e for the fm- and bi-fm-index
\end_layout

\end_inset

 and a multi-kmer index using every 
\begin_inset Formula $k\in\{3,30\}$
\end_inset

 was conducted and the relative speedup measured:
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $t_{fm<i>},t_{kmer<i>}$
\end_inset

 the search runtime for searching a query of length 
\begin_inset Formula $i$
\end_inset

 with the corresponding index
\end_layout

\begin_layout Verse
then 
\begin_inset Formula $\text{{speedup}}(i)=\begin{cases}
+(1-(t_{kmer<i>}/t_{fm<i>})) & \text{{if}\;}t_{kmer<i>}>t_{fm<i>}\\
-(1-(t_{fm<i>}/t_{kmer<i>})) & \text{{if}\;}t_{kmer<i>}<t_{fm<i>}\\
\,0 & \text{{else}}
\end{cases}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/just_k/relative_speedup.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Relative speedup (in %) of the kmer index vs the fm index per query length
 for text size 
\begin_inset Formula $10โธ$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notably the kmer index exhibits more speedup for the lower end of 
\begin_inset Formula $k\in\{3,...,30\}$
\end_inset

.
 This behavior can be explained by Lemma #1 as for bigger text sizes the
 indices unordered map is at maximum capacity and thus lookup time seizes
 to stop scaling with the texts size.
 The point at which the kmer-index starts to perform worse than the fm-index
 is dependent on the text size as such:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
text size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mean speedup
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kmer faster while
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10ยณ$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20.99%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 31
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10โด$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19.3%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 31
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10โต$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17.35%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 31
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10โถ$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16.77%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 31
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10โท$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9.43%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 22
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10โธ$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8.17%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 12
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10โน$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
< 7%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 11
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Results indicate that using the kmer index results in an overall performance
 boost for smaller texts, for larger texts (
\begin_inset Formula $>10โท$
\end_inset

) bigger k may result in overall performance decrease however if 
\begin_inset Formula $k$
\end_inset

 is chosen adequately low, the kmer index will still perform well and should
 be preferred to the fm index for 
\begin_inset Formula $k<10$
\end_inset

 regardless of text size.
\end_layout

\begin_layout Section
Outlook
\end_layout

\begin_layout Standard
To further improve performance and make the implementation generally more
 consistent and applicable in areas it is currently not the following additional
 features are proposed:
\end_layout

\begin_layout Subsection
>64-bit Hash
\end_layout

\begin_layout Standard
As mentioned above the datatype of the hashes is currently 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{uint64_t}
\end_layout

\end_inset

 (as provided by
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{<cstdint>}
\end_layout

\end_inset

).
 64 bit integers were chosen because the standard C++ library does not currently
 support >64bit integers natively and seqan3s kmer hash also uses them
\begin_inset CommandInset citation
LatexCommand cite
key "seqan3 docs: kmer hash"
literal "false"

\end_inset

.
 However the size of the integer used for the hashes is arbitrary and expanding
 it to 128 or 256 bit would improve the maximum k that can still be searched
 with the overall faster 
\begin_inset Formula $m=k$
\end_inset

 search function as it is currently limited to 
\begin_inset Formula $<31$
\end_inset

 for the smallest relevant nucleotide alphabet.
 This may be especially important when working with bigger alphabets such
 as the IUPAC codes for nucleotides 
\begin_inset CommandInset citation
LatexCommand cite
key "dna15 codes"
literal "false"

\end_inset

 or clear text for which 
\begin_inset Formula $\sigma=255$
\end_inset

.
 Abstracting the hash type for the kmer index to use for example integers
 of up to 1024 bit from boosts 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{<multiprecision/cpp_int.hpp>}
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "boost multiprecision"
literal "false"

\end_inset

 could proof valuable, even if these types introduce a small overhead compared
 to 64 bit sized integers.
 
\end_layout

\begin_layout Subsection
Multi Kmer Index Compression 
\end_layout

\begin_layout Standard
As discussed in section 3, using multiple k for the same index vastly increases
 the search performance for a broad variety of queries.
 Ideally we would want to just choose every possible k however memory limitation
s make this difficult.
 The kmer index from section 3 
\begin_inset Foot
status open

\begin_layout Plain Layout
for 
\begin_inset Formula $k={5,7,9,11,13,15,17,19,21,23,25,27,29}$
\end_inset


\end_layout

\end_inset

 offered decent coverage but for a text size of 10โธ already occupied about
 60gb of memory.
 While this is not unfeasable for stronger machines, as each map uses about
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{H.size() * 64 + text.size() * sizeof(position_t)}
\end_layout

\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 (where H is the set of all pairwise different hashes that occure in the
 text) many bytes which means for bigger text such as an entire genome using
 all ks is all but impossible.
 To remedy this it could be possible to implement a way to compress the
 single-k indices contained in the multi-k index.
 Each index contains all positions of the text in it's map which means in
 a multi-k index with 5 ks, the individual indices contain 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{(5-1)*text.size() * sizeof(position_t)}
\end_layout

\end_inset

 many redundant entries in the form of the vectors of positions for each
 hash.
 If a version of the kmer index is implemented that only contains all the
 texts positions once while still allowing for adequate runtime performance
 an all-purpose kmer index could be proposed that simply holds information
 for all possible ks.
 To allow for optimal runtime and no overhead introduced by the compression
 the current implementation of the kmer index does not currently allow for
 any compression.
\end_layout

\begin_layout Subsection
General Purpose Exact String Matching
\end_layout

\begin_layout Standard
The kmer index is able to search sequences of arbitrary lengths.
 While it proved to be well-suited for searching commonly used kmers of
 length 
\begin_inset Formula $k\in\{3,4,...,30\}$
\end_inset

, any query will be accepted.
 To investigate the possiblity of the application of this a benchmark was
 conducted that compared search time for longer queries:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/multi_kmer_vs_fm/5_1000/runtime_diff_over_text_size.png
	lyxscale 40
	width 100text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Runtime Difference for exact searcher per query size for different text
 sizes.
 (Depicted as 
\begin_inset Formula $sign(\Delta_{i})*log(sign(\Delta_{i})*\Delta_{i})$
\end_inset

 where 
\begin_inset Formula $\Delta_{i}=t_{kmer}-t_{fm}$
\end_inset

 the difference of runtimes of each index searching a query length 
\begin_inset Formula $i$
\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Results indicate that the kmer index performs comparatively well for smaller
 texts while the bigger the text the wores the relative performance becomes.
 This is because for bigger queries no query can be covered directly and
 thus Lemma #3 makes the search performance highly dependent on the number
 of results.
 Noticeable for all text sizes are performance spikes around primes (for
 example in the above figure, notice how at 211 significant decrease in
 performance happens regardless of text size).
 Overall the kmer index is fairly well performing for exact search of queries
 of arbitrary lengths as long as the text is fairly small (
\begin_inset Formula $<10โธ$
\end_inset

) however it's inconsistency around certain query lengths depending on the
 choice of k and around primes irregardless of k makes it hard to recommend
 for general purpose exact string matching.
\end_layout

\begin_layout Subsection
Hybrid Approach
\end_layout

\begin_layout Standard
The performance peaks of the kmer index are fairly consistently predicatable.
 A two-pronged approach is proposed for queries where we know the kmer index
 will perform poorly the searching is done by a seperate fm index.
 This allows for the now hybrid index to have the speedup of the inherent
 advantages of the kmer index while also covering the inherent inconsistency
 by instead using the fm index.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fm_index _fm_fibre;
\end_layout

\begin_layout Plain Layout

kmer_index<(...)> _kmer_fiber;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

std::array<bool, (...)> _should_kmer_be_used;	
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template<std::ranges::range query_t>
\end_layout

\begin_layout Plain Layout

result_t exact_search(query_t query) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if (_should_kmer_be_used[query.size()])
\end_layout

\begin_layout Plain Layout

		return _kmer_fibre.search(query);
\end_layout

\begin_layout Plain Layout

	else 
\end_layout

\begin_layout Plain Layout

		return _fm_fibre.search(query);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Search function behavior for the hypothetical hybrid index
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here during construction of the hybrid index a table (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{_should_kmer_be_used}
\end_layout

\end_inset

) is filled that determines which queries lengths will be searched by which
 index.
 The length of the table is somewhat arbitrary and should be chosen such
 that all query lengths are covered as pre-calculating them is beneficial
 to reduce runtime performance.
 The decision of which index to use is not fully clear but based on the
 results demonstrated in this paper, the following recommendations are made:
\end_layout

\begin_layout Standard
The fm-index should be used to search a query of length 
\begin_inset Formula $m$
\end_inset

 if and only if
\end_layout

\begin_layout Itemize
the text size is 
\begin_inset Formula $>10โท$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $m$
\end_inset

 is a prime
\end_layout

\begin_layout Itemize
there is no 
\begin_inset Formula $k_{i}:m\mod k_{i}=0$
\end_inset


\end_layout

\begin_layout Standard
In all other cases preferring the kmer index component may result in an
 overall speedup, however further research needs to be done to develop a
 better tested heuristic that substantiates these recommendations and is
 capable of determining a more exact text size (which may also be dependent
 on the alphabet used) which when exceed might proof use of the hybrid index
 to be more trouble than it is worth.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
The kmer index is superior for searching kmers for 
\begin_inset Formula $k\leq30$
\end_inset

.
 For this purpose it is well suited and should be preferred to more generalist
 indices like the fm index if runtime performance is important.
 For queries past 30 the kmer index was shown to have an inconsistent performanc
e that makes it hard to recommend as a general-purpose index for exact string
 macthing however since there are cases in which significant speedup is
 achieved, it should be considered with further research into this topic.
 The current kmer index implementation is stable, reasonably well optimized
 and has been shown to show the practical speedup that was suggested by
 the theoretical properties of the kmer index.
 Given a user-friendly front end that does not require the average user
 to interact with for example the choice of k by picking the right k for
 them should make the implementation worth using in praxis.
 The multi-kmer approach furthermore allows for flexibility at runtime and
 if a way to compress them (or enough aquire enough memory) is possible,
 simply choosing all k for the multi-kmer index could make it a simple to
 use and well-performing option for searching exact kmers.
 
\end_layout

\begin_layout Section
Addendum: Implementation defined Optimization
\end_layout

\begin_layout Standard
While the kmer index brings inherent theoretical advantages such as it's
 data structure being specifically tailored to searching kmers with it,
 this implementation may owe it's comparatively good performance to the
 specific way things are implemented.
 C++20 was used for all performance relevant code.
\end_layout

\begin_layout Subsection
Returning by Reference
\end_layout

\begin_layout Standard
As described in Section 2 depending on the length 
\begin_inset Formula $m$
\end_inset

 of the query the positions may or may not be the contents of a single vector
 in the indices map (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{
\backslash
_data}
\end_layout

\end_inset

).
\end_layout

\begin_layout Itemize
For 
\begin_inset Formula $m:\:m=k$
\end_inset

 all occurences of the query are identical to the entry in the indices map
 at the corresponding hash (c.f.
 Section 2.1)
\end_layout

\begin_layout Itemize
For 
\begin_inset Formula $m:\:m>k$
\end_inset

 all occurences of the query are a subset of the positions of the first
 kmer prefix of the query (c.f.
 Section 2.3)
\end_layout

\begin_layout Itemize
For 
\begin_inset Formula $m:\ m<k$
\end_inset

 the occurences will usually not be contained to a single entry in the map
 at all.
 As multiple kmers (all that have the query as it's prefix) are searched
 per query the results for the query will be made of multiple entries in
 the indices map
\end_layout

\begin_layout Standard
The trivial way to solve the problem of unifying occurences for all search
 modes is to copy the correct positions to a vector and return it directly.
 This is highly inefficient as creating the new vector and potential copying
 tens of thousands of positions into it every search call would introduce
 an unacceptable performance overhead.
 Instead, a custom result type was implemented that is able to unify entries
 in the map by reference:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

struct kmer_index_result {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	private: 
\end_layout

\begin_layout Plain Layout

		class kmer_index_result_iterator {...}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// bool vector equivalent that 
\end_layout

\begin_layout Plain Layout

		// specifies for each position in _positions
\end_layout

\begin_layout Plain Layout

		// wether or not it should be used 
\end_layout

\begin_layout Plain Layout

		compressed_bitvector _bitmask;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// pointer to positions held by 
\end_layout

\begin_layout Plain Layout

		// map of kmer_index
\end_layout

\begin_layout Plain Layout

		std::vector<const std::vector<size_t>*> _positions;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		(...)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public:
\end_layout

\begin_layout Plain Layout

		// CTOR
\end_layout

\begin_layout Plain Layout

		kmer_index_result(...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		kmer_index_result_iterator begin();
\end_layout

\begin_layout Plain Layout

		kmer_index_result_iterator end();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// usage in main.cpp: result simply usable as range
\end_layout

\begin_layout Plain Layout

auto index = kmer_index<...>(text);
\end_layout

\begin_layout Plain Layout

auto result = index.search(query);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for (auto position : result)
\end_layout

\begin_layout Plain Layout

	seqan3::debug_stream << position << 
\begin_inset Quotes eld
\end_inset


\backslash
n
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
The kmer index returns the above defined kmer_index_result.
 It can be used like any other range.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The result can hold references to multiple vectors to cover both 
\begin_inset Formula $m=k$
\end_inset

 and 
\begin_inset Formula $m<k$
\end_inset

 queries.
 For 
\begin_inset Formula $m>k$
\end_inset

 it furthermore has a vector of booleans specifying wether or not the results
 at position 
\begin_inset Formula $i$
\end_inset

 of the vector inside the kmer indices map is valid for that query.
 While for 
\begin_inset Formula $m>k$
\end_inset

 the index marks each positions, for the other cases this vector is simply
 initialized as all 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{true}
\end_layout

\end_inset

 and not altered at any point.
 When the result is used as a range the iterator will skip positions marked
 as invalid and continue to the next automatically.
 This allows very little overhead for construction and holding only references
 eliminates most of the runtime overhead that would be introduced if the
 index returned by value and had to initilalize vectors to copy the positions
 into.
\end_layout

\begin_layout Subsection
Choosing the fastes Pow Implementation
\end_layout

\begin_layout Standard
By the nature of the hash used, exponentiation (henceforth referred to as
 
\begin_inset Quotes eld
\end_inset

pow
\begin_inset Quotes erd
\end_inset

 in reference to the commonly used 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::pow}
\end_layout

\end_inset

) is used every search call, sometimes multiple times.
 It furthermore needs to be able to be evaluated at compile time (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{constexpr}
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{consteval}
\end_layout

\end_inset

 available since C++20 if applicable
\end_layout

\end_inset

) and only needs to work with unsigned integers .
 Four different versions of pows were implemented and their performance
 evaluated:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{trivial_pow(base,n)}
\end_layout

\end_inset

: A trivial implementation calling base*base n-many times
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{recursive_pow(base,n)}
\end_layout

\end_inset

: Utilizing a recursive approach, this function calls itself recursively
 n-many times and then evaluates each call from the inside out to return
 the correct result based on wether the exponent was odd or even
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{bit_pow(base,n)}
\end_layout

\end_inset

: Utilizes bit-operations which are generally more well-optimized on most
 modern machines
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{switch_pow(base,n)}
\end_layout

\end_inset

: Instead of using a loop, this implementation has multiple switch cases
 with identical code, when the function is called a lookup in a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{constexpr}
\end_layout

\end_inset

 table produces the correct first switch case to start with.
 The result 
\begin_inset Quotes eld
\end_inset

falls through
\begin_inset Quotes erd
\end_inset

 the rest of the switch cases the correct number of times.
 Any exponentiation that would overflow the unsigned 64-bit integer result
 is immediately caught and 0 is returned instead.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/pow_vs_pow/pow_vs_pow.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Boxplot showing runtime distribution for different pow implementations.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Results indicate that the implementation utilizing the fall-through switch
 is overall faster than the other implmentations and was thus used for the
 index whenever possible.
\end_layout

\begin_layout Subsection
Choosing the fastest Hash Implementation
\end_layout

\begin_layout Standard
Armed with the fastest possible pow the speed of the entire hash function
 was addressed:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

static size_t hash_for(iterator_t query_begin)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	size_t hash = 0;
\end_layout

\begin_layout Plain Layout

	for (size_t i = 0; i < k; ++i)
\end_layout

\begin_layout Plain Layout

		hash += to_rank(*it++) * pow(_sigma, k-i-1);
\end_layout

\begin_layout Plain Layout

	return hash;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Trivial implementation for kmer hash utilizing a for loop.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

template<size_t...
 is>
\end_layout

\begin_layout Plain Layout

static size_t hash_fold_aux(iterator_t it, 
\end_layout

\begin_layout Plain Layout

	std::index_sequence<is...> sequence)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return (...
 + to_rank(*it) * pow(_sigma, k-is-1));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

static size_t hash_fold(iterator_t query_begin)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return hash_fold_aux(query_begin, std::make_index_sequence<k>()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation of hash function utilizing a fold expression.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_fold}
\end_layout

\end_inset

 uses the fact that both 
\begin_inset Formula $k$
\end_inset

, 
\begin_inset Formula $\sigma$
\end_inset

 and pow can all be evaluated at compile time.
 This allows the compiler to unwrap the fold expression and calculate all
 factors 
\begin_inset Formula $pow(\sigma,\,k-i-1)\,:i\in\{0,1,2,...,k\}$
\end_inset

 at compile time thus increasing runtime performance.
 To illustrate this a benchmark was conducted comparing both hash-implementation
 for randomized kmers of length 
\begin_inset Formula $k\in\{5,\,10,\,15,\,20,\,25\}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/hash_vs_hash/hash_vs_hash.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Multiple boxplots showing distribution of runtime results for hash implementatio
ns for different 
\begin_inset Formula $k$
\end_inset

 (y-axes have been normalized to the same scale to enable valid comparison
 between graphs).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Results
\begin_inset Foot
status open

\begin_layout Plain Layout
Datapoints outside of the 99.9% confidence interval (correspondingly for
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_fold}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_for}
\end_layout

\end_inset

 separateley) have been discarded from the benchmark result times as they
 represent random interference caused by other processes of the OS the benchmark
 was run on.
\end_layout

\end_inset

indicate that using the fold expression does increase performance.
 For 
\begin_inset Formula $k=5$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_fold}
\end_layout

\end_inset

 is dramatically faster than 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_for}
\end_layout

\end_inset

 which may be attributed to cache-artifacts that allow the CPU to hold all
 factors of the precalculated hash sum in the L1 cache improving access
 times and thus runtime.
 As results suggest 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_fold}
\end_layout

\end_inset

 was used whenever possible.
 
\end_layout

\begin_layout Subsection
Choosing the fastest Map
\end_layout

\begin_layout Standard
As an unordered map is the data structure used to access the data inside
 the kmer index, choosing the most performant map implementation is of vital
 importance.
 As 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::unordered_map}
\end_layout

\end_inset

 did not proof sufficiently fast enough, other maps were tested and evaluated
 specifically for the context of use in a kmer index (that is with key type
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{size_t}
\end_layout

\end_inset

 and value type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::vector<uint32_t>}
\end_layout

\end_inset

).
 Tested were
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::unordered_map}
\end_layout

\end_inset

 from the C++17 standard library
\begin_inset CommandInset citation
LatexCommand cite
key "std::unordered_map"
literal "false"

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{boost::unordered_map}
\end_layout

\end_inset

 from the 1.65.1 Boost Library
\begin_inset CommandInset citation
LatexCommand cite
key "boost::unordered_map"
literal "false"

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{absl::node_hash_map}
\end_layout

\end_inset

 from Googles Abseil
\begin_inset CommandInset citation
LatexCommand cite
key "absl::unordered_map"
literal "false"

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{robin_hood::unordered_map}
\end_layout

\end_inset

 as provided by Martin Ankerl et.
 al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "robin_hood::unordered_map"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
For the benchmark each map was filled with a fixed number of randomized
 elements and was then queried.
 Only retrieval was tested here since after construction in the context
 of the kmer index no insertion takes places.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/map_vs_map/map_vs_map.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Search performance for different map implementations.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Results indicate that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{robin_hood::unordered_map}
\end_layout

\end_inset

 outperformed every other map tested irregardless of the number of elements
 contained and was as such used as the central data structure for the kmer
 index.
 A direct-addressing approach was also tested <TODO: cite addendum>.
 While it improved runtime slightly it scaled exceptionally badly with higher
 k and demanded too much memory and performed to inconsistently to be deemed
 usable in praxis.
\end_layout

\begin_layout Subsection
Paralellization
\end_layout

\begin_layout Standard
Other than the amount of memory needed, the only true disadvantage of using
 the multi kmer index with multiple k is that the time it takes to construct
 will multiply with the number of k.
 To address this, a general purpose thread pool was implemented that allows
 all of the single kmer indices to be constructed at the same time:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

template<std::ranges::range text_t>             
\end_layout

\begin_layout Plain Layout

multi_kmer_index(text_t& text)
\end_layout

\begin_layout Plain Layout

	: single_kmer_index<ks>()...
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	auto pool = thread_pool{(...)};
\end_layout

\begin_layout Plain Layout

	std::vector<std::future<(...)>> futures;
\end_layout

\begin_layout Plain Layout

	(futures.emplace_back(
\end_layout

\begin_layout Plain Layout

		pool.execute(&single_kmer_index<ks>::create, text)), ...);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	// wait to finish
\end_layout

\begin_layout Plain Layout

	for (auto& f : futures)
\end_layout

\begin_layout Plain Layout

		f.get();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
During construction of the multi kmer index, the creation functions for
 all it's single kmer parts is called in paralell.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As the number of possible ks is currently restricted to at most 31, modern
 systems with 32 or more CPUs are capable of constructing one multi kmer
 index for all ks in the same time as one single kmer index for k=31 given
 sufficient memory.
 In the future, paralellization could furthermore be utilized to search
 multiple queries or even multiple parts of a single query at once.
 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: megahit assembly"
literal "false"

\end_inset

 https://academic.oup.com/bioinformatics/article/31/10/1674/177884
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: soapdenovo assembly"
literal "false"

\end_inset

 https://academic.oup.com/bioinformatics/article/30/12/1660/380938
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: taxonomical profiling"
literal "false"

\end_inset

https://msystems.asm.org/content/1/3/e00020-16
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: kraken LCA"
literal "false"

\end_inset

https://genomebiology.biomedcentral.com/articles/10.1186/gb-2014-15-3-r46
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: spectrum dissimilarity"
literal "false"

\end_inset

https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-015-0875-7
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: spectrum error correction"
literal "false"

\end_inset

https://academic.oup.com/bioinformatics/article/29/3/308/257257
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "seqan3 fm-index master"
literal "false"

\end_inset

Pockrandt, C.
 M.
 Generic implementation of a bidirectional FM-index in SeqAn and applications.
 Diss.
 Masterโs thesis, Freie Universitรคt Berlin, 2015.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "seqan3 docs"
literal "false"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "seqan3 docs: kmer hash"
literal "false"

\end_inset

 http://docs.seqan.de/seqan/3-master-user/group__views.html#ga6e598d6a021868f704d39
df73252974f
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "seqan3 docs: fm index"
literal "false"

\end_inset

 http://docs.seqan.de/seqan/3-master-user/group__submodule__fm__index.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "seqan2 doctor arbeit"
literal "false"

\end_inset

 https://refubium.fu-berlin.de/bitstream/handle/fub188/12704/Thesis.Gogol-Doring.Seq
An.2009.pdf?sequence=1&isAllowed=y page 143 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "dna15 codes"
literal "false"

\end_inset

https://www.bioinformatics.org/sms/iupac.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "my github"
literal "false"

\end_inset

https://github.com/Clemapfel/kmer_index/blob/master/kmer_index.hpp 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "cpp RVO"
literal "false"

\end_inset

https://en.cppreference.com/w/cpp/language/copy_elision
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "std::unordered_map"
literal "false"

\end_inset

https://en.cppreference.com/w/cpp/container/unordered_map
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "boost::unordered_map"
literal "false"

\end_inset

 https://www.boost.org/doc/libs/1_65_0/doc/html/boost/unordered_map.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "absl::unordered_map"
literal "false"

\end_inset

 https://abseil.io/docs/cpp/guides/container#abslnode_hash_map-and-abslnode_hash_
set
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "robin_hood::unordered_map"
literal "false"

\end_inset

 https://github.com/martinus/robin-hood-hashing
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "boost multiprecision"
literal "false"

\end_inset

https://www.boost.org/doc/libs/1_62_0/libs/multiprecision/doc/html/boost_multiprec
ision/tut/ints/cpp_int.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-5"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-6"

\end_inset


\end_layout

\end_body
\end_document
