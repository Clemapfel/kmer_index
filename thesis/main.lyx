#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\definecolor{gray}{rgb}{0.5, 0.5, 0.5}
\definecolor{keyword}{RGB}{243, 60, 114}
\definecolor{comment}{RGB}{0, 215, 106}
\definecolor{background}{rgb}{0.9, 0.9, 0.9}

\usepackage{listings}
\usepackage{xparse}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams-chap-bytype
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "beramono" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "keywordstyle={\bfseries \color{keyword}},commentstyle={\color{comment}},caption={Search function for exact matches for a query of size 0 < m < k $^{[1]}$},captionpos=b,backgroundcolor={\color{background}},basicstyle={\ttfamily\small},language={C++},numbers=left,captionpos=b,tabsize=2"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Implementation and performance evaluation of a k-mer index for exact string
 matching
\end_layout

\begin_layout Author
Author: Clemens Cords, FU Berlin
\end_layout

\begin_layout Abstract
As demand for large-scale genomic sequence matching rises, so does TODO.
 A Kmer Index optimized for only exact string matching was implemented and
 it's performance measure with large-scale benchmarks.
 It is shown that the runtime is heavily dependent on the size of the query
 relative to k and the number of results of the query in the text.
 Appropriate choice of k can vastly increase performance and should be chosen
 as high as possible (k > 20 if the machines memory permits so) and so that
 query.size() % k is a low as possible.
 Finally a systematic comparison between exact search performance against
 the FM and BI-FM index is carried out.
 With an approriately chosen k while avoiding the queries that woudl trigger
 the worst case, the kmer index performs up to TODO: PERCENT faster.
 While implementation defined optimization may push the kmer index even
 further, the author recommends usage in situations that require exact string
 matching and have consistently predictable query sizes.
 Furthermore a two-pronged approach of using the (bi-)fm index for approximate
 queries and the kmer index for exact queries may proof superior to just
 using either on their own.
\end_layout

\begin_layout Section*
Motivation
\end_layout

\begin_layout Standard
TODO:
\end_layout

\begin_layout Section
Glossary & Data
\end_layout

\begin_layout Standard
A k-mer (also known as 
\begin_inset Quotes eld
\end_inset

q-gram
\begin_inset Quotes erd
\end_inset

, henceforth written as 
\begin_inset Quotes eld
\end_inset

kmer
\begin_inset Quotes erd
\end_inset

) is any (usually) genomic sequence of length k.
 A kmer index is constructed by iterating through the text, saving all positions
 for the occuring kmers.
 With a simple lookup the kmer index can return all positions of the given
 kmer or the number of occurences.
 To save on memory, kmers are hashed and lookup and storage use this hashed
 form.
 The hash used has the following formula:
\end_layout

\begin_layout LyX-Code
let 
\begin_inset Formula $kmer$
\end_inset

 = 
\begin_inset Formula $(q_{1},\,q_{2},\,...,q_{k})$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout LyX-Code
where 
\begin_inset Formula $q_{i}\in A$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code
\begin_inset Formula $hash(kmer)$
\end_inset

 = 
\begin_inset Formula $\sum_{i=0}^{k}\:rank(q_{i})\:\sigma^{k-i-1}$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout LyX-Code
where 
\begin_inset Formula $\sigma=\#A$
\end_inset

 , 
\begin_inset Formula $rank(q_{i})\in\{0,1,...,\sigma-1\}$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
While not having the best performance, this hash provides adequate TODO:
 entropy? and avoid hash collisions.
 Furthermore the kmer index was compared against the (bi-) fm implementations
 of seqan3 [SEQAN CITATION] which also uses the above hash for their library.
\end_layout

\begin_layout Standard
To better understand the construction and structure of the index, consider
 this example:
\end_layout

\begin_layout LyX-Code
let k = 3
\end_layout

\begin_layout LyX-Code
let text = 
\bar under
A C G T C G T
\end_layout

\begin_layout LyX-Code
           A C G 
\end_layout

\begin_layout LyX-Code
             C G T 
\end_layout

\begin_layout LyX-Code
               G T C 
\end_layout

\begin_layout LyX-Code
                 T C G 
\end_layout

\begin_layout LyX-Code
           
\bar under
        C G T
\end_layout

\begin_layout LyX-Code
           0 1 2 3 4 5 6 
\end_layout

\begin_layout Standard
As the index iterates through the text, it logs the positions of the kmer,
 if a kmer happens multiple times the position is added to the already existing
 map.
\end_layout

\begin_layout LyX-Code
let data = 
\end_layout

\begin_deeper
\begin_layout LyX-Code
hash(ACG) =  6 | 0
\end_layout

\begin_layout LyX-Code
hash(CGT) = 27 | 1, 4
\end_layout

\begin_layout LyX-Code
hash(GTC) = 45 | 2
\end_layout

\begin_layout LyX-Code
hash(TCG) = 54 | 3
\end_layout

\end_deeper
\begin_layout Standard
Because the construction method has to iterate through each position of
 the text, the complexity of this construction is 
\begin_inset Formula $\Theta(n)$
\end_inset

 (where 
\begin_inset Formula $n$
\end_inset

 is the number of characters in the text.
 For performance reasons, an unordered map is chosen to represent the data
 (c.f.
 section <TODO> 
\begin_inset Quotes eld
\end_inset

optimization
\begin_inset Quotes erd
\end_inset

).
 
\end_layout

\begin_layout Section
Searching
\end_layout

\begin_layout Standard
As will be demonstrated later on, time it takes to search a query is highly
 variable and mostly dependent on query size.
 Because of the nature of only being able to directly search kmers rather
 than sequences of any length, any query needs to be broken up into parts
 of k which can then be search independently 
\end_layout

\begin_layout Subsection
query.size() == k
\end_layout

\begin_layout Standard
The easiest and thus best performing <todo: citation to benchmarks> case
 are queries of lengths exactly k.
 For these a simple lookup can return all results at once.
 
\end_layout

\begin_layout LyX-Code
\begin_inset listings
lstparams "language={[GNU]C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

// members of kmer index
\end_layout

\begin_layout Plain Layout

unordered_map<size_t, std::vector<size_t>> _data;
\end_layout

\begin_layout Plain Layout

size_t hash(std::vector<query> q) {...};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template<std::ranges::range range_t>
\end_layout

\begin_layout Plain Layout

std::vector<size_t> search_k(range_t& query)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	assert(query.size() == k);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	const auto* it = _data.at(hash(query));
\end_layout

\begin_layout Plain Layout

	if (it == _data.end())
\end_layout

\begin_layout Plain Layout

		return std::vector<size_t>();
\end_layout

\begin_layout Plain Layout

	else 
\end_layout

\begin_layout Plain Layout

		return *it;
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Search function for exact matches for a query of size k 
\begin_inset ERT
status open

\begin_layout Plain Layout

{$^{[1]}$}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
By the nature of using an unordered map, it has 
\begin_inset Quotes eld
\end_inset

average constant-time complexity
\begin_inset Quotes erd
\end_inset

 dependent on the number of entries of map 
\begin_inset Formula $\#H_{text}$
\end_inset

 (where 
\begin_inset Formula $H_{text}\coloneqq$
\end_inset

 set of different hashes occurring in text.) <TODO: citation for complexity>
\end_layout

\begin_layout Standard
\begin_inset Foot
status open

\begin_layout Plain Layout
Code examples used here are only for the purpose of demonstration and may
 not be identical to the code used in the actual implementation
\end_layout

\end_inset


\end_layout

\begin_layout Lemma
search performance for queries of size 
\begin_inset Formula $m:\,m\mod k=0$
\end_inset

 is optimal
\end_layout

\begin_layout Subsection
query.size() < k
\end_layout

\begin_layout Standard
To be able to search a query of arbitrary length the index has to be able
 to search queries that have a length smaller than k.
 Without modifying the structure of the index significantly one method to
 do this is to search for all kmers that contain the query as a prefix:
 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
let 
\begin_inset Formula $query=(q_{1},\,q_{2},\,...,\,q_{m})$
\end_inset

 where 
\begin_inset Formula $m<k$
\end_inset

 
\end_layout

\begin_layout Standard
for an arbitrary 
\begin_inset Formula $kmer=(s_{1},\,...,\,s_{k})$
\end_inset

 it holds true that 
\end_layout

\begin_layout Standard
if 
\begin_inset Formula $\forall i<m:\:q_{i}=s_{i}$
\end_inset

 then any position 
\begin_inset Formula $pos$
\end_inset

 of 
\begin_inset Formula $kmer$
\end_inset

 is also a position of 
\begin_inset Formula $query$
\end_inset


\end_layout

\begin_layout Standard
because the 
\begin_inset Formula $m$
\end_inset

 characters proceeding pos are 
\end_layout

\begin_layout Standard
\begin_inset Formula $s_{0},\,...,\,s_{m},\,...,\,s_{k}$
\end_inset

 and 
\begin_inset Formula $s_{0},\,...,\,s_{m}=q_{0},\,...,\,q_{m}=query$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\noindent
To avoid generating all kmers that contain 
\begin_inset Formula $query$
\end_inset

 as a prefix and then hashing them, we generate the hashes directly, skipping
 that step and increasing performance:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
let 
\begin_inset Formula $hash(q_{1},\,q_{1},\,...,\,q_{m})=\sum_{i=0}^{k}\:rank(q_{i})\:\sigma^{k-i}=h_{q}$
\end_inset

, constant
\end_layout

\begin_layout Standard
let 
\begin_inset Formula $H\subset\mathbb{Z}^{+}\coloneqq$
\end_inset

set of all hashes with prefix equal to query
\end_layout

\begin_layout Standard
let 
\begin_inset Formula $h_{min},\:h_{max}:\:\forall h_{i}\in H:\:h_{min}\leq h_{i}\leq h_{max}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
to find 
\begin_inset Formula $h_{min}$
\end_inset

 we choose a query in h that has the lowest possible hash
\end_layout

\begin_layout Standard
as 
\begin_inset Formula $h_{min}$
\end_inset

has a prefix equal to 
\begin_inset Formula $query$
\end_inset

 it holds true that 
\end_layout

\begin_layout Standard
\begin_inset Formula $hash(h_{min})\geq h_{p}$
\end_inset

 because the first m summands of the hash are given
\end_layout

\begin_layout Standard
we choose the other summands 
\begin_inset Formula $rank(q_{i>m})\:\sigma^{k-i-1}$
\end_inset

to all be as small as possible: 
\begin_inset Formula $\forall q_{i}:\:rank(q_{i})=0$
\end_inset

 
\end_layout

\begin_layout Standard
thus 
\begin_inset Formula $h_{min}=h_{p}+\sum_{i=m}^{k}\:0*\sigma^{k-i-1}=h_{p}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
to find 
\begin_inset Formula $h_{max}$
\end_inset

 we observe that 
\begin_inset Formula $\#H=\sigma^{k-m}$
\end_inset


\end_layout

\begin_layout Standard
we furthermore observer that for two hashes 
\begin_inset Formula $h_{a},\,h_{b}\in H:\,h_{a}<h_{b}$
\end_inset


\end_layout

\begin_layout Standard
the difference between the hashes 
\begin_inset Formula $h_{a}-h_{b}\geq1$
\end_inset


\end_layout

\begin_layout Standard
This is because given 
\begin_inset Formula $q_{a}=(a_{1},\,...,\,a_{k-1},\,a_{k})\::hash(q_{a})=h_{a}$
\end_inset

to find the next smallest hash that is also in 
\begin_inset Formula $H$
\end_inset

, we replace 
\begin_inset Formula $a_{k}$
\end_inset

with 
\begin_inset Formula $\alpha_{k}$
\end_inset

such that 
\begin_inset Formula $rank(a_{k})=rank(\alpha_{k})+1$
\end_inset


\end_layout

\begin_layout Standard
This means that 
\begin_inset Formula $hash(q_{a})$
\end_inset

 increases by 
\begin_inset Formula $(rank(a_{k})\:\sigma^{k-(k-1)})-(rank(\alpha_{k})\:\sigma^{k-(k-1)})=1$
\end_inset


\end_layout

\begin_layout Standard
Give this information we can conclude 
\begin_inset Formula $H=\{h_{p},\,h_{p}+1,\,h_{p}+1,\,...,\,h_{p}+\sigma^{k-m}\}$
\end_inset

 
\end_layout

\begin_layout Standard
This gives us far less costly way to generate all hashes in a simple for-loop:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={[GNU]C++},numbers=left,basicstyle={\normalsize\ttfamily},tabsize=2"
inline false
status open

\begin_layout Plain Layout

// member of kmer index
\end_layout

\begin_layout Plain Layout

constexpr size_t _sigma = ...
 // alphabet size
\end_layout

\begin_layout Plain Layout

std::vector<size_t> check_last_kmer(...
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template<std::ranges::range range_t>
\end_layout

\begin_layout Plain Layout

std::vector<size_t> search_sub_k(range_t& query)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	size_t size = query.size();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// generate bounds of set of all hashes 
\end_layout

\begin_layout Plain Layout

	// for kmers that have query as prefix
\end_layout

\begin_layout Plain Layout

	size_t prefix_hash = hash(query);                      //h_p				
\end_layout

\begin_layout Plain Layout

	size_t lower_bound = 0 + prefix_hash;                  //h_min			
\end_layout

\begin_layout Plain Layout

	size_t upper_bound = prefix_hash + pow(_sigma, k-size);//h_max
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	// lookup each hash and return
\end_layout

\begin_layout Plain Layout

	std::vector<size_t> output_positions;
\end_layout

\begin_layout Plain Layout

	for (size_t h = lower_bound; h < upper_bound; ++h) 
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		for (size_t pos : _data.at(h))
\end_layout

\begin_layout Plain Layout

			output_positions.push_back(pos)
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	// cover edge case for last kmer
\end_layout

\begin_layout Plain Layout

	for (size_t pos : check_last_kmer(query))
\end_layout

\begin_layout Plain Layout

		output_positions.push_back(pos);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return output_positions;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Search function for exact matches for a query of size 0 < m < k 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that after looking up all hashes dependend on the query, we also need
 to call 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{check_last_kmer}
\end_layout

\end_inset

.
 This is to cover an edge case were the query happens to be a substring
 of the last kmer in the text.
 As the query is compared against prefixes of all kmers there is no kmer
 with a position 
\begin_inset Formula $p>text.size()-k$
\end_inset

 so the query is manually compared against the last 
\begin_inset Formula $k-1$
\end_inset

 letters in the text each search call.
\end_layout

\begin_layout Standard
While this way of searching is more costly than just a simple lookup as
 done for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{query.size == k}
\end_layout

\end_inset

 it is feasable to search queries in a sufficiently fast way if the prefix
 is as long as possible <TODO: cite graph above>.
\end_layout

\begin_layout Lemma
search performance for queries of size 
\begin_inset Formula $m:\,k\mod m\neq0$
\end_inset

 is inversely proportional to 
\begin_inset Formula $k-(k\mod%m)
$
\end_inset


\end_layout

\begin_layout Standard
Initial observations recommend 
\begin_inset Formula $k-(k\%m)$
\end_inset

 be no more than 
\begin_inset Formula $3$
\end_inset

 if possible.
\end_layout

\begin_layout Subsection
query.size > k
\end_layout

\begin_layout Standard
Since the kmer index can only lookup queries of length k for longer queries
 the query is split into parts of length k.
 If 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{query.size() % k != 0}
\end_layout

\end_inset

 there will also be a part (
\begin_inset Quotes eld
\end_inset

rest
\begin_inset Quotes erd
\end_inset

) with a length < k.
 To find the position of the query, the positions of each pat including
 the rest are looked up.
 The query can only occure at every positions of the first kmer, thus for
 each position the positions of the other parts are crossreferenced to confirm
 that the query actually occurs there:
\end_layout

\begin_layout Standard
let query 
\begin_inset Formula $q=(q_{1},\,q_{1},\,...,\,q_{m})$
\end_inset

 be of length 
\begin_inset Formula $m:\:m>k\,\land\,m\%k\neq0$
\end_inset


\end_layout

\begin_layout Standard
let 
\begin_inset Formula $p_{i}=(q_{i},\,...,q_{i+k})$
\end_inset

 with 
\begin_inset Formula $i\in[0,\,(m-(m\%k))/k]$
\end_inset

 be the i-th kmer in the query
\end_layout

\begin_layout Standard
let 
\begin_inset Formula $r=(q_{m-(m\%k)},\,...,q_{m})$
\end_inset

 be the rest of length 
\begin_inset Formula $m\%k$
\end_inset


\end_layout

\begin_layout Standard
then the query occurs at positions 
\begin_inset Formula $pos(q_{seed})\in pos(q_{1},...q_{k})=pos(p_{1})$
\end_inset

 iff
\end_layout

\begin_layout Standard
there exists at position 
\begin_inset Formula $\rho_{2}\in pos(p_{2})$
\end_inset

 such that 
\begin_inset Formula $\rho_{2}=q_{seed}+k$
\end_inset

, and there exists a position 
\begin_inset Formula $\rho_{3}\in pos(p_{3})$
\end_inset

 such that 
\begin_inset Formula $\rho_{3}=\rho_{2}+k$
\end_inset

, etc.
\end_layout

\begin_layout Standard
For 
\begin_inset Formula $\rho_{(m-(m\%k))/k}$
\end_inset

 we also need to check for position 
\begin_inset Formula $\rho_{rest}\in pos(rest)$
\end_inset

 if applicable
\end_layout

\begin_layout Standard
For perfomance purposes if at any point the program does not find a fitting
 
\begin_inset Formula $\rho_{i}$
\end_inset

, the current position in 
\begin_inset Formula $pos(q_{seed})$
\end_inset

 is marked as invalid the loop moves onto the next.
 While the worst-case performance (all position in 
\begin_inset Formula $pos(q_{seed})$
\end_inset

 are valid) is very costly it also provides a very important fact about
 searching:
\end_layout

\begin_layout Lemma
search time for queries of size 
\begin_inset Formula $m:\,m>k$
\end_inset

 scales inversely proportional to the number of results for the corresponding
 
\begin_inset Formula $p_{i}$
\end_inset


\end_layout

\begin_layout Subsection
choosing the right k
\end_layout

\begin_layout Standard
In praxis usually both the text size and the queries and thus their lengths
 are given and cannot be controlled, k however can be freely chosen by the
 user.
 Given these 3 lemmas, k should be chosen such that.
 For the set of unique queries 
\begin_inset Formula $\{q_{1},\,...,\,q_{n}\}:\,\sum_{i=1}^{n}k-(k\mod size(q_{i}))$
\end_inset

 is as low as possible.
 In section <TODO: addendum choosing k> an algorithm is provided to choose
 the best k.
 Furthermore k should be chosen as high as possible
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that we are not only limited by the machines memory but also the fact
 that the kmer hashes have to fit in a 64-bit integer which necessitates
 an alphabet and k combination so that 
\begin_inset Formula $\sigma^{k}<2^{64}$
\end_inset

.
 For the 4-letter dna alphabet, this means k can at most be 31 while for
 bigger alphabets, k has to be chosen far lower.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
because given a fixed text size, the higher the k the less results each
 kmer will have and as stated <TODO: lemma 3> this will increase search
 time.
 Considering these stipulations for the k naturally the decision won't always
 be clear and in some instances multiple k would seem to give better results
 than only a single k.
 As such, the kmer index implementation gives the option to unify indices
 for multiple k into a single big index that picks the optimal k to search
 a certain query with by itself.
\end_layout

\begin_layout Section
Multi-kmer Index
\end_layout

\begin_layout Standard
As evident from section 2, the search performance is very highly variable
 depending on mostly the length of the query in relationship to k.
 To investigate this further a benchmark was conducted: 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Documents/Workspace/kmer_index/source/benchmarks/kmer_vs_fm_over_query_size/k10_search_over_query.png
	lyxscale 10
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Graph demonstrating the highly variable search performance of the kmer index
 based on query length.
 The inset graph is showing a 
\begin_inset Quotes eld
\end_inset

zoomed in
\begin_inset Quotes erd
\end_inset

 view of the are for query length 16 to 20.
 The grey dotted lines mark query length that are a multiple of k
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Benchmark results show a predicatble pattern, the search performance is
 at it's worst for k+1.
 This is explained through the way the search function works, for a query
 of length k+1 it first searches the first kmer, however to find positions
 for the rest it has to generate the hashes for all kmers with fixed prefix
 of one, for the given example of k = 10 this means the function has to
 generate and lookup 
\begin_inset Formula $\sigma^{k-query.size()}=4^{9}=262144$
\end_inset

 hashes which is very costly.
 Note that the worst case peaks lower as the query size increases.
 This is because during the search in section 2.3 the results for all the
 k-long parts of the query has to be crossreferenced:
\end_layout

\begin_layout Standard
For query 
\begin_inset Formula $q=(q_{1},\:...,\,q_{m})$
\end_inset

 size 
\begin_inset Formula $m:\,m=n*k+rest$
\end_inset

 with 
\begin_inset Formula $n\in\{2,\,3,\,...\}\:\land0<r<k$
\end_inset

 
\end_layout

\begin_layout Standard
let 
\begin_inset Formula $p_{n}\coloneqq(q_{n},\,...,q_{2n-1})$
\end_inset

 be the 
\begin_inset Formula $n$
\end_inset

ths k-long section of query and 
\begin_inset Formula $\#R_{n}=r(p_{n})$
\end_inset

 the number of results for that kmer 
\end_layout

\begin_layout Standard
then the crossreferencing (c.f.
 line <TODO: code) takes at most 
\begin_inset Formula $\Theta(r_{0}*r_{1}*...*r_{n}*r((q_{m-rest},\,...,\,q_{m})))$
\end_inset

 comparisons 
\end_layout

\begin_layout Standard
where 
\begin_inset Formula $r((q_{n*k},\,...,\,q_{m})))$
\end_inset

 is the number of result for the last part of length 
\begin_inset Formula $rest<k$
\end_inset

 
\end_layout

\begin_layout Standard
This is because for each resut 
\begin_inset Formula $result_{n}\in R_{n}:n<m-rest$
\end_inset

 the code has to check if there is a result in 
\begin_inset Formula $result_{n+1}\in R_{n+1}$
\end_inset

 so that 
\begin_inset Formula $result_{n+1}=result_{n}+k$
\end_inset

 to confirm that that query actually occurs there.
 
\end_layout

\begin_layout Standard
Because of this the performance for nk-searches scales significantly with
 the number of results.
 However the amortized complexity detailed above assume that the code will
 finish every comparison while in actual implementation it will stop once
 a position is deconfirmed.
 By increasing the query size in a fixed size text the number of results
 for that query will also decrease.
 This is why the peak worst case performances for the searches becomes lower
 as the query grows, a longer query means less results and less results
 means the search function can abort earlier which saves runtime.
\end_layout

\begin_layout Section
Implementation defined Optimization
\end_layout

\begin_layout Standard
While few of the ideas here improve the theoretical performance of the kmer
 index, certain implementation choices contributed significantly to it having
 a chance to outpace the fm index.
 Picking C++ as the language of choice was an intentional decision made
 to allow the author to have flexibility <TODO>
\end_layout

\begin_layout Subsection
Returning by Reference
\end_layout

\begin_layout Standard
As we've seen in section <TODO>, for queries of length 
\begin_inset Formula $m:\:m=k$
\end_inset

 the returned positions of the query are simply the entry in the map for
 the corresponding hash.
 However for 
\begin_inset Formula $m:\:m>k\,\land\,m\%k=0$
\end_inset

 there may not be any entry in the map that exactly corresponds to the positions
 of the query, while all positions for it are from the corresponding vector
 in the map for hash of the first k characters, not all positions in the
 vector are correct, some have to be thrown out.
 For 
\begin_inset Formula $m:\:m<k$
\end_inset

 there may not be a single vector in the map that represents all positions,
 as all kmer with the prefix equal to query are valid positions, the resulting
 positions correspond to multiple vector in the actual map.
 Performance wise this proves problematic, copying many positions into a
 result vector as well as allocating that result vector introduce a huge
 overhead that is unexceptable.
 To fix this a result class was created that simply holds the references
 to the correct vectors as well as information about which results within
 those are valid (as needed for the 
\begin_inset Formula $m:\:m>k\,\land\,m\%k=0$
\end_inset

 case):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

struct kmer_index_result 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private: 
\end_layout

\begin_layout Plain Layout

		class kmer_index_result_iterator {...}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// bool vector equivalent that 
\end_layout

\begin_layout Plain Layout

		// specifies for each position in _positions
\end_layout

\begin_layout Plain Layout

		// wether or not it should be used 
\end_layout

\begin_layout Plain Layout

		compressed_bitvector _bitmask;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// pointer to positions held by 
\end_layout

\begin_layout Plain Layout

		// map of kmer_index
\end_layout

\begin_layout Plain Layout

		std::vector<const std::vector<size_t>*> _positions;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		(...)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public:
\end_layout

\begin_layout Plain Layout

		// CTOR
\end_layout

\begin_layout Plain Layout

		kmer_index_result(...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// usable as range
\end_layout

\begin_layout Plain Layout

		kmer_index_result_iterator begin();
\end_layout

\begin_layout Plain Layout

		kmer_index_result_iterator end();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// member of kmer_index: search query of any length
\end_layout

\begin_layout Plain Layout

template<std::ranges::range query_t>
\end_layout

\begin_layout Plain Layout

kmer_index_result search(query_t&& query);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// in main: result simply usable as range
\end_layout

\begin_layout Plain Layout

auto index = kmer_index<...>(text);
\end_layout

\begin_layout Plain Layout

auto result = index.search(query);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for (auto position : result)
\end_layout

\begin_layout Plain Layout

	std::cout << result << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
The kmer index returns the above defined kmer_index_result.
 It can be used like any other range, here illustrated in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{//main}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

The result only holds the pointers to the corresponding vectors of positions
 inside the kmer index.
 This allows for construction of the result to be minimal, it only needs
 to move the pointers into 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{_positions}
\end_layout

\end_inset

 and initialize 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{_bitmask}
\end_layout

\end_inset

.
 During the search call, the kmer index signals to the result which positions
 should be used and which should be discarded, however none of them are
 actually removed from the vectors, instead when the results is evaluated
 later on, it only returns valid positions and skips past the ones marked
 as invalid <TODO: cite code>.
 This removes the need to allocate a vector of positions and improves search
 performance dramatically while not sacrificing usability.
 
\end_layout

\begin_layout Subsection
Choosing the fastes Pow Implementation
\end_layout

\begin_layout Standard
By the nature of the hash used to hash kmers in the kmer index, exponentiation
 (pow() in programming terms) is used everywhere, however exclusively with
 positive integers.
 Furthermore all pow functions need to be able to be evaluated at compile
 time (c.f.
 section <TODO>) It was thus imperative to choose the most optimal pow implement
ation.
 A benchmark was conducted for 4 different implementations and the results
 were compared:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{trivial_pow(base,n)}
\end_layout

\end_inset

: A trivial implementation calling base*base n -many times
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{recursive_pow(base,n)}
\end_layout

\end_inset

: Utilizing a recursive approach, the function calls itself recursively
 n-many times and then evaluates each call bottom-up to then return the
 correct result base on wether the exponent was odd or even
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{bit_pow(base,n)}
\end_layout

\end_inset

: Rather than using 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{operator*}
\end_layout

\end_inset

 for multiplication, this implementation utilizes equivalent bit operations
 which are generally more well-optimized on modern machines
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{switch_pow(base,n)}
\end_layout

\end_inset

: Instead of using a loop, this implementation has multiple switch cases
 with identical code, when the function is called a lookup in a constexpr
 table produces the correct first switch case to start with and then the
 results falls through the rest of them the correct number of times.
 Any exponentiation that would overflow the unsigned 64-bit integer result
 is immediately caught and 0 is returned instead.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Documents/Workspace/kmer_index/source/benchmarks/pow_vs_pow/pow_vs_pow.png
	lyxscale 15
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Boxplot showing runtime (y-axis log scaled) for different pow implementations.
 The notches represent the confidence interval around the median.
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As clearly evident from the benchmarks, the approach switch_pow took vastly
 outpaces the others and as such was used for the kmer_index implmentation
 wherever possible.
\end_layout

\begin_layout Subsection
Choosing the fastest Hash Implementation
\end_layout

\begin_layout Standard
Simiarly to pow, the result of the hash function transforming a kmer into
 a 64-bit integer is integral to the index function and optimizing it's
 runtime as much as possible is very advantageous.
 Two hash implementations were compared:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

constexpr uint8_t _sigma = alphabet_size<alphabet_t>;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static size_t hash_for(iterator_t query_begin)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	size_t hash = 0;
\end_layout

\begin_layout Plain Layout

	for (size_t i = 0; i < k; ++i)
\end_layout

\begin_layout Plain Layout

		hash += to_rank(*it++) * pow(_sigma, k-i-1)
\end_layout

\begin_layout Plain Layout

	return hash;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Trivial implementation for kmer hash utilizing a simple for loop
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

template<size_t...
 is>
\end_layout

\begin_layout Plain Layout

static size_t hash_fold_aux(iterator_t it, 
\end_layout

\begin_layout Plain Layout

	std::index_sequence<is...> sequence)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return (...
 + to_rank(*it) * pow(_sigma, k-is-1))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

static size_t hash_fold(iterator_t query_begin)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return hash_fold_aux(query_begin, std::make_index_sequence<k>()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation of hash function utilizing fold expression
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_fold}
\end_layout

\end_inset

 uses the fact that both k, 
\begin_inset Formula $\sigma$
\end_inset

 and pow are all available at compile time.
 This allows the compiler to unwrap the fold expression and calculate all
 factors 
\begin_inset Formula $pow(\sigma,\,k-i-1)\,:i\in\{0,1,2,...,k\}$
\end_inset

at compile time thus increasing runtime performance.
 To illustrate this a benchmark was conducted comparing both hash-implementation
 for randomized kmers of length 
\begin_inset Formula $k\in\{5,\,10,\,15,\,20,\,25\}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Documents/Workspace/kmer_index/source/benchmarks/hash_vs_hash/hash_vs_hash.png
	lyxscale 10
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Multiple boxplots for different k showing distribution of runtime results
 for hash implementations (y-axes have been normalized to the same scale
 to enable valid comparison between graphs) 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Benchmarks results show that for all tested k the fold-expression implemetation
 for the hash has superior median runtime
\begin_inset Foot
status open

\begin_layout Plain Layout
Datapoints outside of the 99.9% confidence interval (correspondingly for
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_fold}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_for}
\end_layout

\end_inset

 seperateley) have been discarded from the benchmark result times as they
 represent random interference caused by other processes of the OS the benchmark
 was run on.
 
\end_layout

\end_inset

.
 The relatively large variance in for all but 
\begin_inset Formula $k=5$
\end_inset

 is believed to be cause interference in the benchmark environment.
 For 
\begin_inset Formula $k=5$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_fold}
\end_layout

\end_inset

 is dramatically faster than 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_for}
\end_layout

\end_inset

 which may be attributed to cache-artifacts that allow the CPU to hold all
 factors of the precalculated hash sum in the L1 cache improving access
 times.
 These results are indicitave that the fold implementation is more performant
 and was thus choosen to be used by the kmer index whenever possible.
\end_layout

\begin_layout Subsection
Choosing the fastest Map
\end_layout

\begin_layout Standard
As an 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{unordered_map}
\end_layout

\end_inset

 with the keys as 64-bit hashes and the value a vector of text positions,
 ( 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::vector<uint32_t}
\end_layout

\end_inset

 by default) is the data structure used to assess the data inside the kmer
 index, choosing the most performant map implementation is of vital importance.
 As 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::unordered_map}
\end_layout

\end_inset

 did not proof sufficient enough, other maps were tested and evaluated specifica
lly for the context of use in a kmer index (that is with the key type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{size_t}
\end_layout

\end_inset

 and the value type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::vector<uint32_t>}
\end_layout

\end_inset

.
 Tested were
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::unordered_map}
\end_layout

\end_inset

 from the C++17 standard library <TODO https://en.cppreference.com/w/cpp/container
/unordered_map
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{boost::unordered_map}
\end_layout

\end_inset

 from the 1.65.1 Boost Library <TODO https://www.boost.org/doc/libs/1_65_0/doc/html/
boost/unordered_map.html
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{absl::node_hash_map}
\end_layout

\end_inset

 from Googles' Abseil <TODO: https://abseil.io/docs/cpp/guides/container#abslnode
_hash_map-and-abslnode_hash_set
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{robin_hood::unordered_map}
\end_layout

\end_inset

 as provided by Martin Ankerl <TODO: https://github.com/martinus/robin-hood-hashi
ng>
\end_layout

\begin_layout Standard
The choice of maps was largely based on availability and the opinions of
 other <todo: cite blog>.
 For the benchmark each map was filled with a fixed number of randomized
 elements and was then queried with it's given 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{at(size_t hash)}
\end_layout

\end_inset

 function.
 Only retrieval was tested here since after construction no insertion takes
 places during searching with the kmer index.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Documents/Workspace/kmer_index/source/benchmarks/map_vs_map/map_vs_map.png
	lyxscale 10
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
search performance for different map implementations
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As clearly evident, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{robin_hood::unordered_map}
\end_layout

\end_inset

 outperformed every other map tested and was as such used in the kmer index
 whenever possible.
\end_layout

\begin_layout Subsection
Choosing the right k(s)
\end_layout

\begin_layout Standard
Given the kmers inconsistent nature, picking the best possible k has a large
 impact on the search performance.
 While with a single k this is hard to do, given the option to have any
 number of k raises the question of how many and which to pick.
 
\end_layout

\end_body
\end_document
