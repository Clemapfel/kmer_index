#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\definecolor{gray}{rgb}{0.5, 0.5, 0.5}
\definecolor{keyword}{RGB}{243, 60, 114}
\definecolor{comment}{RGB}{0, 215, 106}
\definecolor{background}{rgb}{0.9, 0.9, 0.9}

\usepackage{listings}
\usepackage{xparse}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams-chap-bytype
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "beramono" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "keywordstyle={\bfseries \color{keyword}},commentstyle={\color{comment}},caption={Search function for exact matches for a query of size 0 < m < k $^{[1]}$},captionpos=b,backgroundcolor={\color{background}},basicstyle={\ttfamily\small},language={C++},numbers=left,captionpos=b,tabsize=2"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Implementation and Performance Evaluation of a k-mer Index for exact String
 Matching
\end_layout

\begin_layout Author
Author: Clemens Cords, FU Berlin
\end_layout

\begin_layout Abstract
As demand for large-scale genomic sequence matching rises so does the ability
 to efficiently get the positions or number of occurences for an exact query
 of length k called kmer.
 A kmer index optimized for this purposes was implemented and it's performance
 evaluated.
 The implementation is capable of searching kmers with an abitrary k specified
 at run-time, utilizes parallization for faster construction and searching
 of multiple queries at once and it's internal structure can be further
 customized at compile time to achieve greater performance for certain query
 sizes.
 The exact nature of the implementation-defined optimizations is explained
 and it's performance benchmarked.
 Results indicate that for the purpose of searching for positions or number
 of occurences of kmers of the commonly used length 
\begin_inset Formula $k\in\{3,...,30\}$
\end_inset

 the kmer index performs up to 2 times faster than the fm-index regardless
 of text size.
 Further comparison for queries of greater length is made, it is observed
 that although the kmer index may perform better in some cases, it's performance
 is highly dependend on the text size and query length.
 Soft guidelines are formulated in what cases the kmer index may outperform
 the fm-index.
 It is concluded that the kmer index is to be always preferred for any exact
 string matching for queries of length 
\begin_inset Formula $k<30$
\end_inset

, for greater 
\begin_inset Formula $k$
\end_inset

 it's inconsistency doesn't lend it to general-purpose use however may proof
 useful in circumstances where the lengths of query are highly homogenous.
 
\end_layout

\begin_layout Section*
Motivation
\end_layout

\begin_layout Section
Construction
\end_layout

\begin_layout Standard
A k-mer (also known as 
\begin_inset Quotes eld
\end_inset

q-gram
\begin_inset Quotes erd
\end_inset

, henceforth written as 
\begin_inset Quotes eld
\end_inset

kmer
\begin_inset Quotes erd
\end_inset

) is any (usually) genomic sequence of length k.
 The kmer index then utilizes an unordered map data structure that saves
 the positions for each occurence of the kmer so a simple lookup can retrieve
 all of them.
 To save on memory the kmer are not saved in clear text but are converted
 to an unsigned integer with the following hash function:
\end_layout

\begin_layout LyX-Code
let 
\begin_inset Formula $kmer$
\end_inset

 = 
\begin_inset Formula $(q_{1},\,q_{2},\,...,q_{k})$
\end_inset

 where 
\begin_inset Formula $q\in A$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $hash(kmer)$
\end_inset

 = 
\begin_inset Formula $\sum_{i=0}^{k}\:rank(q_{i})\:\sigma^{k-i-1}$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout LyX-Code
where 
\begin_inset Formula $\sigma=\#A$
\end_inset

 , 
\begin_inset Formula $rank(q_{i})\in\{0,1,...,\sigma-1\}$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
This hash guarantees no hash collisions <TODO: citation> and was furthermore
 chosen because the kmer index is to be integrated and compared to the seqan3
 library <seqan citation> which uses the same hash function <todo: kmer
 hash header>.
 Constructing the kmer is fairly straight-forward: simply iterate through
 the text, creating a new entry for a kmer that wasn't seen before or if
 it was, adding the current position to that kmers entry:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

template<size_t k, typename position_t>
\end_layout

\begin_layout Plain Layout

class kmer_index { 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

private: unordered_map<uint64_t, std::vector<position_t> _data;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template<std::ranges::range text_t>
\end_layout

\begin_layout Plain Layout

public: void create(text_t text)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	auto hashes = text | views::kmer_hash<k>;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	size_t position = 0;
\end_layout

\begin_layout Plain Layout

	for (auto hash : hashes) {
\end_layout

\begin_layout Plain Layout

		if (_data.find(hash) == _data.end())
\end_layout

\begin_layout Plain Layout

			_data.insert(hash, std::vector<position_t>());
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		_data[hash].push_back(position);
\end_layout

\begin_layout Plain Layout

		++position;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Called during construction the create function iterates through the text,
 filling the index |
\begin_inset Formula $ยน$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Give a text of length 
\begin_inset Formula $n$
\end_inset

, 
\begin_inset Formula $n-k$
\end_inset

hashes will be generated and inserted into the index.
 Thus the creation function
\begin_inset Foot
status open

\begin_layout Plain Layout
All code examples henceforth used are edited for brevity only meant for
 the purpose of demonstrating the programs behavior and are not necessarily
 identical or representative to the code used in the actual implementation.
\end_layout

\end_inset

 has an amortized complexity of 
\begin_inset Formula $\Theta(n)$
\end_inset

 which is acceptable as for the purpose of indexing genomic data the texts
 are rarely dynamic, this construction will need to be done only once as
 the index can then be serialized and loaded from memory for later use.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Searching
\end_layout

\begin_layout Standard
To achieve greater flexibility, the kmer index implementation is capable
 of searching for queries of arbitrary length.
 While a k still needs to be specified at compile time, at runtime any query
 can be searched, the behavior and thus performance of the kmer index is
 dependend on the length of the query in relation to the k.
\end_layout

\begin_layout Subsection
query size m = k
\end_layout

\begin_layout Standard
The easiest and thus best performing <todo: citation to benchmarks> case
 are queries of lengths exactly k.
 For these a simple lookup can return all results at once: 
\end_layout

\begin_layout LyX-Code
\begin_inset listings
lstparams "language={[GNU]C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

unordered_map<uint64_t, std::vector<position_t> _data;
\end_layout

\begin_layout Plain Layout

uint64_t hash(...);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template<std::ranges::range range_t>
\end_layout

\begin_layout Plain Layout

std::vector<size_t> search_k(range_t& query)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	const auto* it = _data.at(hash(query));
\end_layout

\begin_layout Plain Layout

	if (it == _data.end())
\end_layout

\begin_layout Plain Layout

		return std::vector<size_t>();
\end_layout

\begin_layout Plain Layout

	else 
\end_layout

\begin_layout Plain Layout

		return *it;
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Search function for query of size k |
\begin_inset Formula $ยน$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
By the nature of using an unordered map, it has average constant-time complexity
 dependent on the number of entries of map 
\begin_inset Formula $\#H_{text}$
\end_inset

 (where 
\begin_inset Formula $H_{text}\coloneqq$
\end_inset

 set of different hashes occurring in text).
 Note that the runtime of this functions is nearly completely made up of
 the time it takes to translate the query into an int with 
\begin_inset ERT
status open

\begin_layout Plain Layout

lstinline{hash}
\end_layout

\end_inset

 and the time it takes for the unordered map 
\begin_inset ERT
status open

\begin_layout Plain Layout

lstinline{
\backslash
_data}
\end_layout

\end_inset

 to locate the appropriate vector of positions.
 This mode of searching is the kmer indices strength and queries of length
 k should be considered the best-case scenario.
\end_layout

\begin_layout Lemma
search performance for queries of size 
\begin_inset Formula $m:\,m\mod k=0$
\end_inset

 is optimal compared to other 
\begin_inset Formula $m$
\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
query size m < k
\end_layout

\begin_layout Standard
To be able to search a query of arbitrary length the index has to be able
 to search queries that have a length smaller than k but without modifying
 the structure of the index significantly one method to achieve this is
 by insted searching for occurences of all kmers that have a prefix equal
 to the query:
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $query=(q_{1},\,q_{2},\,...,\,q_{m})$
\end_inset

 where 
\begin_inset Formula $m<k$
\end_inset

 
\end_layout

\begin_layout Verse
for an arbitrary 
\begin_inset Formula $kmer=(s_{1},\,...,\,s_{k})$
\end_inset

 it holds true that 
\end_layout

\begin_layout Verse
iff 
\begin_inset Formula $\forall i\leq m:\:q_{i}=s_{i}$
\end_inset

 then any position 
\begin_inset Formula $pos$
\end_inset

 of 
\begin_inset Formula $kmer$
\end_inset

 is also a position of 
\begin_inset Formula $query$
\end_inset


\end_layout

\begin_layout Verse
because the 
\begin_inset Formula $m$
\end_inset

 characters proceeding 
\begin_inset Formula $pos$
\end_inset

 are 
\end_layout

\begin_layout Verse
\begin_inset Formula $s_{0},\,...,\,s_{m},\,...,\,s_{k}$
\end_inset

 and 
\begin_inset Formula $s_{0},\,...,\,s_{m}=q_{0},\,...,\,q_{m}=query$
\end_inset


\end_layout

\begin_layout Standard
\noindent
To avoid generating all kmers that contain 
\begin_inset Formula $query$
\end_inset

 as a prefix and then hashing them, we generate the hashes directly, skipping
 that step and increasing performance:
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $hash(q_{1},\,q_{1},\,...,\,q_{m})=\sum_{i=0}^{k}\:r(q_{i})\:\sigma^{k-i}=h_{q}$
\end_inset

, constant
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $H\subset\mathbb{Z}^{+}\coloneqq$
\end_inset

 set of all hashes of kmers with a prefix equal to 
\begin_inset Formula $query$
\end_inset


\end_layout

\begin_layout Verse
let 
\begin_inset Formula $h_{min},\:h_{max}:\:\forall h_{i}\in H:\:h_{min}\leq h_{i}\leq h_{max}$
\end_inset

 be the upper and lower bound for 
\begin_inset Formula $H$
\end_inset


\end_layout

\begin_layout Verse
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Verse
to find 
\begin_inset Formula $h_{min}$
\end_inset

 we observe that as 
\begin_inset Formula $h_{min}$
\end_inset

has a prefix equal to 
\begin_inset Formula $query$
\end_inset

 it holds true that 
\end_layout

\begin_layout Verse
\begin_inset Formula $hash(h_{min})\geq h_{p}$
\end_inset

 because the first 
\begin_inset Formula $m$
\end_inset

 summands of the hash are given by the prefix a
\end_layout

\begin_layout Verse
we choose the other summands 
\begin_inset Formula $r(q_{i>m})\:\sigma^{k-i-1}$
\end_inset

to all be as small as possible by using characters such that 
\begin_inset Formula $\forall q_{i}:\:r(q_{i})=0$
\end_inset

 
\end_layout

\begin_layout Verse
thus 
\begin_inset Formula $h_{min}=h_{p}+\sum_{i=m}^{k}\:0*\sigma^{k-i-1}=h_{p}$
\end_inset


\end_layout

\begin_layout Verse
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Verse
to find 
\begin_inset Formula $h_{max}$
\end_inset

 we observe that 
\begin_inset Formula $\#H=\sigma^{k-m}$
\end_inset

 
\end_layout

\begin_layout Verse
we furthermore observe that for two hashes 
\begin_inset Formula $h_{a},\,h_{b}\in H:\,h_{a}<h_{b}$
\end_inset


\end_layout

\begin_layout Verse
the difference between the hashes 
\begin_inset Formula $h_{a}-h_{b}\geq1$
\end_inset


\end_layout

\begin_layout Verse
This is because given 
\begin_inset Formula $q_{a}=(a_{1},\,...,\,a_{k-1},\,a_{k})\::hash(q_{a})=h_{a}$
\end_inset

to find the next smallest hash that is also in 
\begin_inset Formula $H$
\end_inset

, we replace 
\begin_inset Formula $a_{k}$
\end_inset

with 
\begin_inset Formula $\alpha_{k}$
\end_inset

such that 
\begin_inset Formula $r(a_{k})=r(\alpha_{k})+1$
\end_inset


\end_layout

\begin_layout Verse
This means that 
\begin_inset Formula $hash(q_{a})$
\end_inset

 increases by 
\begin_inset Formula $(r(a_{k})\:\sigma^{k-(k-1)})-(r(\alpha_{k})\:\sigma^{k-(k-1)})=1$
\end_inset


\end_layout

\begin_layout Verse
Given this information we can conclude 
\begin_inset Formula $H=\{h_{p},\,h_{p}+1,\,h_{p}+1,\,...,\,h_{p}+\sigma^{k-m}\}$
\end_inset

 
\end_layout

\begin_layout Standard
This gives us far less costly way to generate all hashes in a simple for-loop:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={[GNU]C++},numbers=left,basicstyle={\normalsize\ttfamily},tabsize=2"
inline false
status open

\begin_layout Plain Layout

// member of kmer index
\end_layout

\begin_layout Plain Layout

constexpr size_t _sigma = ...
 // alphabet size
\end_layout

\begin_layout Plain Layout

std::vector<size_t> check_last_kmer(...
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template<std::ranges::range range_t>
\end_layout

\begin_layout Plain Layout

std::vector<size_t> search_sub_k(range_t& query)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	size_t size = query.size();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// generate bounds of set of all hashes 
\end_layout

\begin_layout Plain Layout

	// for kmers that have query as prefix
\end_layout

\begin_layout Plain Layout

	size_t prefix_hash = hash(query);                      //h_p				
\end_layout

\begin_layout Plain Layout

	size_t lower_bound = 0 + prefix_hash;                  //h_min			
\end_layout

\begin_layout Plain Layout

	size_t upper_bound = prefix_hash + pow(_sigma, k-size);//h_max
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	// lookup each hash and return
\end_layout

\begin_layout Plain Layout

	std::vector<size_t> output_positions;
\end_layout

\begin_layout Plain Layout

	for (size_t h = lower_bound; h < upper_bound; ++h) 
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		for (size_t pos : _data.at(h))
\end_layout

\begin_layout Plain Layout

			output_positions.push_back(pos)
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	// cover edge case for last kmer
\end_layout

\begin_layout Plain Layout

	for (size_t pos : check_last_kmer(query))
\end_layout

\begin_layout Plain Layout

		output_positions.push_back(pos);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return output_positions;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Search function for exact matches for a query of size 0 < m < k |
\begin_inset Formula $ยน$
\end_inset

 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that after looking up all hashes dependend on the query, we also need
 to call 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{check_last_kmer}
\end_layout

\end_inset

.
 This is to cover an edge case were the query happens to be a substring
 of the last kmer in the text.
 As the query is compared against prefixes of all kmers there is no kmer
 with a position 
\begin_inset Formula $p>text.size()-k$
\end_inset

 so the query is manually compared against the last 
\begin_inset Formula $k-1$
\end_inset

 letters in the text each search call.
\end_layout

\begin_layout Standard
While this way of searching is more costly than just a simple lookup as
 done for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{query.size == k}
\end_layout

\end_inset

 it is feasable to search queries in a sufficiently fast way if the prefix
 is as long as possible.
\end_layout

\begin_layout Lemma
search performance for queries of size 
\begin_inset Formula $m:\,(k\mod m)\neq0\:\land m<k$
\end_inset

 is inversely proportional to 
\begin_inset Formula $k-m$
\end_inset


\end_layout

\begin_layout Standard
Initial observations recommend 
\begin_inset Formula $k-m$
\end_inset

 be no more than 
\begin_inset Formula $3$
\end_inset

 if possible.
 The actual implementation throws an exception if 
\begin_inset Formula $\sigma^{k-m}>10^{7}$
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
While somewhat arbitrarily chosen, 
\begin_inset Formula $10^{7}$
\end_inset

represents the case of 
\begin_inset Formula $k-m>11$
\end_inset

 for the dna alphabet (
\begin_inset Formula $\sigma=4$
\end_inset

) which should allow most users to be able to not encounter the exception
 during proper usage of the kmer index and notably will mean for 
\begin_inset Formula $k=10$
\end_inset

 queries of all length be accepted.
\end_layout

\end_inset

as if it was unchecked a badly chosen m and k combination could take many
 hours to complete because of the amount of kmers that have to be looked
 up.
\end_layout

\begin_layout Subsection
query size m > k
\end_layout

\begin_layout Standard
For longer queries the query is split into parts of length k.
 If 
\begin_inset Formula $m\mod k\neq0$
\end_inset

 there will also be a part (
\begin_inset Quotes eld
\end_inset

rest
\begin_inset Quotes erd
\end_inset

) with a length 
\begin_inset Formula $<k$
\end_inset

.
 We observer that the positions of the query are a subset of the positions
 of the first kmer 
\begin_inset Formula $p_{1}$
\end_inset

in the query.
 To confirm wether a positions of 
\begin_inset Formula $p_{1}$
\end_inset

is valid, we crossreference the positions with the next part:
\end_layout

\begin_layout Verse
let query 
\begin_inset Formula $q=(q_{1},\,q_{1},\,...,\,q_{m})$
\end_inset

 be of length 
\begin_inset Formula $m:\:m>k\,\land\,m\mod k\neq0$
\end_inset


\end_layout

\begin_layout Verse
let 
\begin_inset Formula $p_{i}=(q_{i},\,...,q_{i+k})$
\end_inset

 with 
\begin_inset Formula $i\in[0,\,(m-(m\mod k))/k]$
\end_inset

 be the i-th kmer in the query
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $r=(q_{m-(m\%k)},\,...,q_{m})$
\end_inset

 be the 
\begin_inset Quotes eld
\end_inset

rest
\begin_inset Quotes erd
\end_inset

 of length 
\begin_inset Formula $m\mod k$
\end_inset


\end_layout

\begin_layout Verse
then the query occurs at positions 
\begin_inset Formula $pos(q_{seed})\in pos(q_{1},...q_{k})=pos(p_{1})$
\end_inset

 iff
\end_layout

\begin_layout Verse
there exists at position 
\begin_inset Formula $\rho_{2}\in pos(p_{2})$
\end_inset

 such that 
\begin_inset Formula $\rho_{2}=q_{seed}+k$
\end_inset

, and there exists a position 
\begin_inset Formula $\rho_{3}\in pos(p_{3})$
\end_inset

 such that 
\begin_inset Formula $\rho_{3}=\rho_{2}+k$
\end_inset

, etc.
\end_layout

\begin_layout Verse
For 
\begin_inset Formula $\rho_{(m-(m\mod k))/k}$
\end_inset

 we also need to check for position 
\begin_inset Formula $\rho_{rest}\in pos(rest)$
\end_inset

 so that 
\begin_inset Formula $\rho_{rest}=\rho_{i+k}+k$
\end_inset


\end_layout

\begin_layout Standard
For perfomance purposes if at any point the program does not find a fitting
 
\begin_inset Formula $\rho_{i}$
\end_inset

, the current position in 
\begin_inset Formula $pos(q_{seed})$
\end_inset

 is marked as invalid the loop moves onto the next.
 While the worst-case performance (all position in 
\begin_inset Formula $pos(q_{seed})$
\end_inset

 are valid) is costly this behavior also provides a very important fact
 about searching query of length 
\begin_inset Formula $m>k$
\end_inset

:
\end_layout

\begin_layout Lemma
search time for queries of size 
\begin_inset Formula $m:\,m>k$
\end_inset

 scales inversely proportional to the number of results for the corresponding
 
\begin_inset Formula $p_{i}$
\end_inset


\end_layout

\begin_layout Subsection
Choosing the right k
\end_layout

\begin_layout Standard
In praxis usually both the texts size and the queries and thus their lengths
 are given and cannot be controlled.
 
\begin_inset Formula $k$
\end_inset

 however can be freely chosen.
 Give a fixed text size, longer sequences will have a lower number occurences
 than short sequences.
 Accordant to Lemma #3, this means k should be chosen as high as possible.
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that we are not only limited by the machines memory but also the fact
 that the kmer hashes have to fit in a 64-bit unsigned integer which necessitate
s an alphabet and k combination so that 
\begin_inset Formula $\sigma^{k}<2^{64}$
\end_inset

.
 For the 4-letter dna alphabet, this means k can at most be 31 while for
 bigger alphabets, k has to be chosen far lower.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Furthermore sets of queries with a relatively narrow distribution of query
 lengths should be preferred as in this case a 
\begin_inset Formula $k$
\end_inset

 should be chosen so that as many queries as possible are either divisible
 by 
\begin_inset Formula $k$
\end_inset

 (which is optimal c.f.
 Lemma #1) or if not, the rest of integer division 
\begin_inset Formula $m\mod k$
\end_inset

 should be as high as possible as this means accordant to Lemma #2 that
 the prefix is as long as possible and thus 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{search_k}
\end_layout

\end_inset

 has as few kmers to search as possible.
 However given practical examples the set of queries is rarely homogenous
 enough to be able to choose a single k that fullfills all of these criteria.
 Due to this the kmer index was implemented in a way where multiple k can
 be chosen at once, unifying multiple kmer indices for different k into
 one and letting the index choose the optimal k to search with.
\end_layout

\begin_layout Section
Multi-kmer Index
\end_layout

\begin_layout Standard
To further investigate the behavior the three Lemmas in section 2 imply,
 a benchmark was conducted.
 For a kmer index with 
\begin_inset Formula $k=10$
\end_inset

, queries starting at 6 all the way up to 60 were searched and the search
 calls duration to return was measured:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/multi_vs_single/single_only.png
	lyxscale 30
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Benchmark results searching queries of length 6 to 50 with a kmer index
 for k = 10.
 The inset graph is showing a 
\begin_inset Quotes eld
\end_inset

zoomed in
\begin_inset Quotes erd
\end_inset

 view of the are for query length 16 to 20.
 The grey dotted lines mark query length that are a multiple of k.
 
\end_layout

\end_inset


\end_layout

\end_inset

The results show a predicatble pattern substantiating the above mentioned
 lemmas.
 Optimal performance happens for query sizes 
\begin_inset Formula $m:\:m\mod k=0$
\end_inset

 (Lemma #1).
 While queries of length 
\begin_inset Formula $(n*k)-1,\,(n*k)-2:\:n\in{1,2,...}$
\end_inset

still show acceptable performance the higher 
\begin_inset Formula $k-m$
\end_inset

 the worse the search function performs (Lemma #2).
 For queries of length 
\begin_inset Formula $(n*k)+1$
\end_inset

 performance becomes unusable showing a runtime increase of up to 5e7 times
 compared to best-case performance.
 Not that the peaks at 
\begin_inset Formula $(n*k)+1$
\end_inset

 reduce in severity as query length increases.
 This is because with the query length increasing so does the number of
 results for the query.
 As stated in Lemma #3, this allows the kmer index to abort the search call
 early reducing runtime.
 To achieve a more general-purpose performance, let's look at the similarly
 conducted benchmark for a kmer index with multiple k.
 As 
\begin_inset Formula $(n*k)+1$
\end_inset

is the worst case, adding a 
\begin_inset Formula $k_{2}=k_{1}+1$
\end_inset

 seems reasonable however since as we've seen performance for 
\begin_inset Formula $(n*k)-2$
\end_inset

 is still decent enough so to preserve memory we choose 
\begin_inset Formula $k_{2}=k_{1}+2$
\end_inset

.
 This then means that the new worst case is 
\begin_inset Formula $(n*k_{2})+1$
\end_inset

, and so on.
 To cover the widest possible region, the 
\begin_inset Formula $k_{i}$
\end_inset

 are thus chosen as 
\begin_inset Formula $k_{0}=5,\,k_{1}=k_{0}+2,\,...,\,k_{last}=29$
\end_inset

.
 29 is the highest reasonable k as we are limited by the number of bits
 for the integer used for the hashes
\begin_inset Formula $ยณ$
\end_inset

.
 Comparing the results, it is obvious how having multiple k can have a huge
 impact:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
i
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/multi_vs_single/multi_vs_single.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Search Performance for multi-kmer and single kmer index
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Even thought the multi-kmer index does not cover every single k, covering
 it so that for every query length 
\begin_inset Formula $m$
\end_inset

 there's a k so that 
\begin_inset Formula $k=m\lor k=m+1$
\end_inset

 still decent performance.
 Not how at query length 10 the single kmer index is faster (c.f.
 the red vertical line in the above figure).
 This illlustrates the slight difference in performance between 
\begin_inset Formula $k=m$
\end_inset

 (which is true for the single kmer index for 
\begin_inset Formula $m=10$
\end_inset

) and 
\begin_inset Formula $k=m+1$
\end_inset

(which is true for the multi kmer index).
 Due to the same reason the multi kmer performance sort of zig-zags with
 it's peaks at uncovered k and it lows at directly covered k.
 Note further how past 33 the multi kmer indices performance starts spiking.
 This is because the k is limited to at most 31 numbers past 31 can't be
 covered optimally.
 The spike at 40 owes to the fact that the multi kmer does not have 
\begin_inset Formula $k=10$
\end_inset

 and thus have to cover 40 with 
\begin_inset Formula $k=11$
\end_inset

(44) which is outside the 
\begin_inset Formula $m-k<=3$
\end_inset

 range mentioned above.
 The spike at 47 is because 47 is a prime and thus not divisible by any
 possible 
\begin_inset Formula $k$
\end_inset

.
 This is true for all primes past 31 and illustrates well the kmer indices
 inherent weakness of some query lengths having poor performance while others
 perform very well.
 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
At this point to put the absolute values of these results into perspective,
 a comparison between seqan3's fm-index
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that for exact string matching there's is no relevant performance differenc
e for the fm- and bi-fm-index <TODO: citation>
\end_layout

\end_inset

 and the above used multi-kmer index was conducted.
 These results are from the same benchmark session as the above graphs to
 assure comparability:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/multi_vs_single/multi_vs_fm.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Search performance of the multi kmer index and the fm index.
 The results where linearly fitted using values inside 
\begin_inset Formula $x=[5,33]$
\end_inset

 (designated here by the rectangular are of darker grey background)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Results indicate that the kmer index is faster for all k.
 Even for query lengths 
\begin_inset Formula $m=k+1$
\end_inset

the kmer index outperforms the fm-index by large margin and it is reasonable
 to assume that depending on the text an even lower number of k could still
 provide a significant performance boost.
 To investigate this further, similar benchmarks were conducted for different
 text sizes and the average decrease in runtime
\begin_inset Foot
status open

\begin_layout Plain Layout
speedup = 
\begin_inset Formula $1-mean_{k=3}^{31}(t_{fm}/(t_{fm<k>}-t_{kmer<k>}))$
\end_inset

 where 
\begin_inset Formula $t_{fm<i>}<\,t_{kmer<i>}$
\end_inset

 are the search time performance of the corresponding index for searching
 a query of size i
\end_layout

\end_inset

 was measured:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
text size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
average speedup
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10ยณ$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
88.99%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10โด$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
88.95%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10โต$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
90.05%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10โถ$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
91.13%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10โท$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10โธ$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Implementation defined Optimization
\end_layout

\begin_layout Standard
While few of the ideas here improve the theoretical performance of the kmer
 index, certain implementation choices contributed significantly to it having
 a chance to outpace the fm index.
 Picking C++ as the language of choice was an intentional decision made
 to allow the author to have flexibility <TODO>
\end_layout

\begin_layout Subsection
Returning by Reference
\end_layout

\begin_layout Standard
As we've seen in section <TODO>, for queries of length 
\begin_inset Formula $m:\:m=k$
\end_inset

 the returned positions of the query are simply the entry in the map for
 the corresponding hash.
 However for 
\begin_inset Formula $m:\:m>k\,\land\,m\%k=0$
\end_inset

 there may not be any entry in the map that exactly corresponds to the positions
 of the query, while all positions for it are from the corresponding vector
 in the map for hash of the first k characters, not all positions in the
 vector are correct, some have to be thrown out.
 For 
\begin_inset Formula $m:\:m<k$
\end_inset

 there may not be a single vector in the map that represents all positions,
 as all kmer with the prefix equal to query are valid positions, the resulting
 positions correspond to multiple vector in the actual map.
 Performance wise this proves problematic, copying many positions into a
 result vector as well as allocating that result vector introduce a huge
 overhead that is unexceptable.
 To fix this a result class was created that simply holds the references
 to the correct vectors as well as information about which results within
 those are valid (as needed for the 
\begin_inset Formula $m:\:m>k\,\land\,m\%k=0$
\end_inset

 case):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

struct kmer_index_result 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private: 
\end_layout

\begin_layout Plain Layout

		class kmer_index_result_iterator {...}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// bool vector equivalent that 
\end_layout

\begin_layout Plain Layout

		// specifies for each position in _positions
\end_layout

\begin_layout Plain Layout

		// wether or not it should be used 
\end_layout

\begin_layout Plain Layout

		compressed_bitvector _bitmask;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// pointer to positions held by 
\end_layout

\begin_layout Plain Layout

		// map of kmer_index
\end_layout

\begin_layout Plain Layout

		std::vector<const std::vector<size_t>*> _positions;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		(...)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public:
\end_layout

\begin_layout Plain Layout

		// CTOR
\end_layout

\begin_layout Plain Layout

		kmer_index_result(...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// usable as range
\end_layout

\begin_layout Plain Layout

		kmer_index_result_iterator begin();
\end_layout

\begin_layout Plain Layout

		kmer_index_result_iterator end();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// member of kmer_index: search query of any length
\end_layout

\begin_layout Plain Layout

template<std::ranges::range query_t>
\end_layout

\begin_layout Plain Layout

kmer_index_result search(query_t&& query);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// in main: result simply usable as range
\end_layout

\begin_layout Plain Layout

auto index = kmer_index<...>(text);
\end_layout

\begin_layout Plain Layout

auto result = index.search(query);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for (auto position : result)
\end_layout

\begin_layout Plain Layout

	std::cout << result << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
The kmer index returns the above defined kmer_index_result.
 It can be used like any other range, here illustrated in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{//main}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

The result only holds the pointers to the corresponding vectors of positions
 inside the kmer index.
 This allows for construction of the result to be minimal, it only needs
 to move the pointers into 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{_positions}
\end_layout

\end_inset

 and initialize 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{_bitmask}
\end_layout

\end_inset

.
 During the search call, the kmer index signals to the result which positions
 should be used and which should be discarded, however none of them are
 actually removed from the vectors, instead when the results is evaluated
 later on, it only returns valid positions and skips past the ones marked
 as invalid <TODO: cite code>.
 This removes the need to allocate a vector of positions and improves search
 performance dramatically while not sacrificing usability.
 
\end_layout

\begin_layout Subsection
Choosing the fastes Pow Implementation
\end_layout

\begin_layout Standard
By the nature of the hash used to hash kmers in the kmer index, exponentiation
 (pow() in programming terms) is used everywhere, however exclusively with
 positive integers.
 Furthermore all pow functions need to be able to be evaluated at compile
 time (c.f.
 section <TODO>) It was thus imperative to choose the most optimal pow implement
ation.
 A benchmark was conducted for 4 different implementations and the results
 were compared:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{trivial_pow(base,n)}
\end_layout

\end_inset

: A trivial implementation calling base*base n -many times
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{recursive_pow(base,n)}
\end_layout

\end_inset

: Utilizing a recursive approach, the function calls itself recursively
 n-many times and then evaluates each call bottom-up to then return the
 correct result base on wether the exponent was odd or even
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{bit_pow(base,n)}
\end_layout

\end_inset

: Rather than using 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{operator*}
\end_layout

\end_inset

 for multiplication, this implementation utilizes equivalent bit operations
 which are generally more well-optimized on modern machines
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{switch_pow(base,n)}
\end_layout

\end_inset

: Instead of using a loop, this implementation has multiple switch cases
 with identical code, when the function is called a lookup in a constexpr
 table produces the correct first switch case to start with and then the
 results falls through the rest of them the correct number of times.
 Any exponentiation that would overflow the unsigned 64-bit integer result
 is immediately caught and 0 is returned instead.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/pow_vs_pow/pow_vs_pow.png
	lyxscale 15
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Boxplot showing runtime (y-axis log scaled) for different pow implementations.
 The notches represent the confidence interval around the median.
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As clearly evident from the benchmarks, the approach switch_pow took vastly
 outpaces the others and as such was used for the kmer_index implmentation
 wherever possible.
\end_layout

\begin_layout Subsection
Choosing the fastest Hash Implementation
\end_layout

\begin_layout Standard
Simiarly to pow, the result of the hash function transforming a kmer into
 a 64-bit integer is integral to the index function and optimizing it's
 runtime as much as possible is very advantageous.
 Two hash implementations were compared:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

constexpr uint8_t _sigma = alphabet_size<alphabet_t>;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static size_t hash_for(iterator_t query_begin)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	size_t hash = 0;
\end_layout

\begin_layout Plain Layout

	for (size_t i = 0; i < k; ++i)
\end_layout

\begin_layout Plain Layout

		hash += to_rank(*it++) * pow(_sigma, k-i-1)
\end_layout

\begin_layout Plain Layout

	return hash;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Trivial implementation for kmer hash utilizing a simple for loop
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

template<size_t...
 is>
\end_layout

\begin_layout Plain Layout

static size_t hash_fold_aux(iterator_t it, 
\end_layout

\begin_layout Plain Layout

	std::index_sequence<is...> sequence)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return (...
 + to_rank(*it) * pow(_sigma, k-is-1))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

static size_t hash_fold(iterator_t query_begin)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return hash_fold_aux(query_begin, std::make_index_sequence<k>()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation of hash function utilizing fold expression
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_fold}
\end_layout

\end_inset

 uses the fact that both k, 
\begin_inset Formula $\sigma$
\end_inset

 and pow are all available at compile time.
 This allows the compiler to unwrap the fold expression and calculate all
 factors 
\begin_inset Formula $pow(\sigma,\,k-i-1)\,:i\in\{0,1,2,...,k\}$
\end_inset

at compile time thus increasing runtime performance.
 To illustrate this a benchmark was conducted comparing both hash-implementation
 for randomized kmers of length 
\begin_inset Formula $k\in\{5,\,10,\,15,\,20,\,25\}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/hash_vs_hash/hash_vs_hash.png
	lyxscale 10
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Multiple boxplots for different k showing distribution of runtime results
 for hash implementations (y-axes have been normalized to the same scale
 to enable valid comparison between graphs) 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Benchmarks results show that for all tested k the fold-expression implemetation
 for the hash has superior median runtime
\begin_inset Foot
status open

\begin_layout Plain Layout
Datapoints outside of the 99.9% confidence interval (correspondingly for
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_fold}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_for}
\end_layout

\end_inset

 seperateley) have been discarded from the benchmark result times as they
 represent random interference caused by other processes of the OS the benchmark
 was run on.
 
\end_layout

\end_inset

.
 The relatively large variance in for all but 
\begin_inset Formula $k=5$
\end_inset

 is believed to be cause interference in the benchmark environment.
 For 
\begin_inset Formula $k=5$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_fold}
\end_layout

\end_inset

 is dramatically faster than 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_for}
\end_layout

\end_inset

 which may be attributed to cache-artifacts that allow the CPU to hold all
 factors of the precalculated hash sum in the L1 cache improving access
 times.
 These results are indicitave that the fold implementation is more performant
 and was thus choosen to be used by the kmer index whenever possible.
\end_layout

\begin_layout Subsection
Choosing the fastest Map
\end_layout

\begin_layout Standard
As an 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{unordered_map}
\end_layout

\end_inset

 with the keys as 64-bit hashes and the value a vector of text positions,
 ( 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::vector<uint32_t}
\end_layout

\end_inset

 by default) is the data structure used to assess the data inside the kmer
 index, choosing the most performant map implementation is of vital importance.
 As 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::unordered_map}
\end_layout

\end_inset

 did not proof sufficient enough, other maps were tested and evaluated specifica
lly for the context of use in a kmer index (that is with the key type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{size_t}
\end_layout

\end_inset

 and the value type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::vector<uint32_t>}
\end_layout

\end_inset

.
 Tested were
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::unordered_map}
\end_layout

\end_inset

 from the C++17 standard library <TODO https://en.cppreference.com/w/cpp/container
/unordered_map
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{boost::unordered_map}
\end_layout

\end_inset

 from the 1.65.1 Boost Library <TODO https://www.boost.org/doc/libs/1_65_0/doc/html/
boost/unordered_map.html
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{absl::node_hash_map}
\end_layout

\end_inset

 from Googles' Abseil <TODO: https://abseil.io/docs/cpp/guides/container#abslnode
_hash_map-and-abslnode_hash_set
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{robin_hood::unordered_map}
\end_layout

\end_inset

 as provided by Martin Ankerl <TODO: https://github.com/martinus/robin-hood-hashi
ng>
\end_layout

\begin_layout Standard
The choice of maps was largely based on availability and the opinions of
 other <todo: cite blog>.
 For the benchmark each map was filled with a fixed number of randomized
 elements and was then queried with it's given 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{at(size_t hash)}
\end_layout

\end_inset

 function.
 Only retrieval was tested here since after construction no insertion takes
 places during searching with the kmer index.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/map_vs_map/map_vs_map.png
	lyxscale 10
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
search performance for different map implementations
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As clearly evident, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{robin_hood::unordered_map}
\end_layout

\end_inset

 outperformed every other map tested and was as such used in the kmer index
 whenever possible.
\end_layout

\begin_layout Subsection
Choosing the right k(s)
\end_layout

\begin_layout Standard
Given the kmers inconsistent nature, picking the best possible k has a large
 impact on the search performance.
 While with a single k this is hard to do, given the option to have any
 number of k raises the question of how many and which to pick.
 
\end_layout

\begin_layout Section
Conclusion & Outlook
\end_layout

\begin_layout Subsection
Further Features
\end_layout

\begin_layout Subsubsection
mix k-results for different ks to cover rest optimally
\end_layout

\begin_layout Subsubsection
compress map to cover all k
\end_layout

\begin_layout Standard
each map takes #kmer * sizeof(hash_t) + text_size * position_t
\end_layout

\begin_layout Subsubsection
(each map takes #kmers * 64 for the keys + uint32_t * text_size for positions.
\end_layout

\begin_layout Subsubsection
sizeof(hash_t) > 64
\end_layout

\end_body
\end_document
