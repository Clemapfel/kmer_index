#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\definecolor{gray}{rgb}{0.5, 0.5, 0.5}
\definecolor{keyword}{RGB}{243, 60, 114}
\definecolor{comment}{RGB}{0, 215, 106}
\definecolor{background}{rgb}{0.9, 0.9, 0.9}

\usepackage{listings}
\usepackage{xparse}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams-chap-bytype
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "beramono" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "keywordstyle={\bfseries \color{keyword}},commentstyle={\color{comment}},caption={Search function for exact matches for a query of size 0 < m < k $^{[1]}$},captionpos=b,backgroundcolor={\color{background}},basicstyle={\ttfamily\small},language={C++},numbers=left,captionpos=b,tabsize=2"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Implementation and Performance Evaluation of a k-mer Index for exact String
 Matching
\end_layout

\begin_layout Author
Author: Clemens Cords, FU Berlin
\end_layout

\begin_layout Abstract
As demand for large-scale genomic sequence matching rises so does the ability
 to efficiently get the positions or number of occurences for an exact query
 of length k called kmer.
 A kmer index optimized for this purposes was implemented and it's performance
 evaluated.
 The implementation is capable of searching kmers with an abitrary k specified
 at run-time, utilizes parallization for faster construction and searching
 of multiple queries at once and it's internal structure can be further
 customized at compile time to achieve greater performance for certain query
 sizes.
 The exact nature of the implementation-defined optimizations is explained
 and it's performance benchmarked.
 Results indicate that for the purpose of searching for positions or number
 of occurences of kmers of the commonly used length 
\begin_inset Formula $k\in\{3,...,30\}$
\end_inset

 the kmer index performs up to 2 times faster than the fm-index regardless
 of text size.
 Further comparison for queries of greater length is made, it is observed
 that although the kmer index may perform better in some cases, it's performance
 is highly dependend on the text size and query length.
 Soft guidelines are formulated in what cases the kmer index may outperform
 the fm-index.
 It is concluded that the kmer index is to be always preferred for any exact
 string matching for queries of length 
\begin_inset Formula $k<30$
\end_inset

, for greater 
\begin_inset Formula $k$
\end_inset

 it's inconsistency doesn't lend it to general-purpose use however may proof
 useful in circumstances where the lengths of query are highly homogenous.
 
\end_layout

\begin_layout Section*
Motivation
\end_layout

\begin_layout Section
Construction
\end_layout

\begin_layout Standard
A k-mer (also known as 
\begin_inset Quotes eld
\end_inset

q-gram
\begin_inset Quotes erd
\end_inset

, henceforth written as 
\begin_inset Quotes eld
\end_inset

kmer
\begin_inset Quotes erd
\end_inset

) is any (usually) genomic sequence of length k.
 The kmer index then utilizes an unordered map data structure that saves
 the positions for each occurence of the kmer so a simple lookup can retrieve
 all of them.
 To save on memory the kmer are not saved in clear text but are converted
 to an unsigned integer with the following hash function:
\end_layout

\begin_layout LyX-Code
let 
\begin_inset Formula $kmer$
\end_inset

 = 
\begin_inset Formula $(q_{1},\,q_{2},\,...,q_{k})$
\end_inset

 where 
\begin_inset Formula $q\in A$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $hash(kmer)$
\end_inset

 = 
\begin_inset Formula $\sum_{i=0}^{k}\:rank(q_{i})\:\sigma^{k-i-1}$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout LyX-Code
where 
\begin_inset Formula $\sigma=\#A$
\end_inset

 , 
\begin_inset Formula $rank(q_{i})\in\{0,1,...,\sigma-1\}$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
This hash guarantees no hash collisions <TODO: citation> and was furthermore
 chosen because the kmer index is to be integrated and compared to the seqan3
 library <seqan citation> which uses the same hash function <todo: kmer
 hash header>.
 Constructing the kmer is fairly straight-forward: simply iterate through
 the text, creating a new entry for a kmer that wasn't seen before or if
 it was, adding the current position to that kmers entry:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

template<size_t k, typename position_t>
\end_layout

\begin_layout Plain Layout

class kmer_index { 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

private: unordered_map<uint64_t, std::vector<position_t> _data;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template<std::ranges::range text_t>
\end_layout

\begin_layout Plain Layout

public: void create(text_t text)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	auto hashes = text | views::kmer_hash<k>;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	size_t position = 0;
\end_layout

\begin_layout Plain Layout

	for (auto hash : hashes) {
\end_layout

\begin_layout Plain Layout

		if (_data.find(hash) == _data.end())
\end_layout

\begin_layout Plain Layout

			_data.insert(hash, std::vector<position_t>());
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		_data[hash].push_back(position);
\end_layout

\begin_layout Plain Layout

		++position;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Called during construction the create function iterates through the text,
 filling the index |
\begin_inset Formula $ยน$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Give a text of length 
\begin_inset Formula $n$
\end_inset

, 
\begin_inset Formula $n-k$
\end_inset

hashes will be generated and inserted into the index.
 Thus the creation function
\begin_inset Foot
status open

\begin_layout Plain Layout
All code examples henceforth used are edited for brevity only meant for
 the purpose of demonstrating the programs behavior and are not necessarily
 identical or representative to the code used in the actual implementation.
\end_layout

\end_inset

 has an amortized complexity of 
\begin_inset Formula $\Theta(n)$
\end_inset

 which is acceptable as for the purpose of indexing genomic data the texts
 are rarely dynamic, this construction will need to be done only once as
 the index can then be serialized and loaded from memory for later use.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Searching
\end_layout

\begin_layout Standard
To achieve greater flexibility, the kmer index implementation is capable
 of searching for queries of arbitrary length.
 While a k still needs to be specified at compile time, at runtime any query
 can be searched, the behavior and thus performance of the kmer index is
 dependend on the length of the query in relation to the k.
\end_layout

\begin_layout Subsection
query size m = k
\end_layout

\begin_layout Standard
The easiest and thus best performing <todo: citation to benchmarks> case
 are queries of lengths exactly k.
 For these a simple lookup can return all results at once: 
\end_layout

\begin_layout LyX-Code
\begin_inset listings
lstparams "language={[GNU]C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

unordered_map<uint64_t, std::vector<position_t> _data;
\end_layout

\begin_layout Plain Layout

uint64_t hash(...);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template<std::ranges::range range_t>
\end_layout

\begin_layout Plain Layout

std::vector<size_t> search_k(range_t& query)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	const auto* it = _data.at(hash(query));
\end_layout

\begin_layout Plain Layout

	if (it == _data.end())
\end_layout

\begin_layout Plain Layout

		return std::vector<size_t>();
\end_layout

\begin_layout Plain Layout

	else 
\end_layout

\begin_layout Plain Layout

		return *it;
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Search function for query of size k |
\begin_inset Formula $ยน$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
By the nature of using an unordered map, it has average constant-time complexity
 dependent on the number of entries of map 
\begin_inset Formula $\#H_{text}$
\end_inset

 (where 
\begin_inset Formula $H_{text}\coloneqq$
\end_inset

 set of different hashes occurring in text).
 Note that the runtime of this functions is nearly completely made up of
 the time it takes to translate the query into an int with 
\begin_inset ERT
status open

\begin_layout Plain Layout

lstinline{hash}
\end_layout

\end_inset

 and the time it takes for the unordered map 
\begin_inset ERT
status open

\begin_layout Plain Layout

lstinline{
\backslash
_data}
\end_layout

\end_inset

 to locate the appropriate vector of positions.
 This mode of searching is the kmer indices strength and queries of length
 k should be considered the best-case scenario.
\end_layout

\begin_layout Lemma
search performance for queries of size 
\begin_inset Formula $m:\,m\mod k=0$
\end_inset

 is optimal compared to other 
\begin_inset Formula $m$
\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
query size m < k
\end_layout

\begin_layout Standard
To be able to search a query of arbitrary length the index has to be able
 to search queries that have a length smaller than k but without modifying
 the structure of the index significantly one method to achieve this is
 by insted searching for occurences of all kmers that have a prefix equal
 to the query:
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $query=(q_{1},\,q_{2},\,...,\,q_{m})$
\end_inset

 where 
\begin_inset Formula $m<k$
\end_inset

 
\end_layout

\begin_layout Verse
for an arbitrary 
\begin_inset Formula $kmer=(s_{1},\,...,\,s_{k})$
\end_inset

 it holds true that 
\end_layout

\begin_layout Verse
iff 
\begin_inset Formula $\forall i\leq m:\:q_{i}=s_{i}$
\end_inset

 then any position 
\begin_inset Formula $pos$
\end_inset

 of 
\begin_inset Formula $kmer$
\end_inset

 is also a position of 
\begin_inset Formula $query$
\end_inset


\end_layout

\begin_layout Verse
because the 
\begin_inset Formula $m$
\end_inset

 characters proceeding 
\begin_inset Formula $pos$
\end_inset

 are 
\end_layout

\begin_layout Verse
\begin_inset Formula $s_{0},\,...,\,s_{m},\,...,\,s_{k}$
\end_inset

 and 
\begin_inset Formula $s_{0},\,...,\,s_{m}=q_{0},\,...,\,q_{m}=query$
\end_inset


\end_layout

\begin_layout Standard
\noindent
To avoid generating all kmers that contain 
\begin_inset Formula $query$
\end_inset

 as a prefix and then hashing them, we generate the hashes directly, skipping
 that step and increasing performance:
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $hash(q_{1},\,q_{1},\,...,\,q_{m})=\sum_{i=0}^{k}\:r(q_{i})\:\sigma^{k-i}=h_{q}$
\end_inset

, constant
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $H\subset\mathbb{Z}^{+}\coloneqq$
\end_inset

 set of all hashes of kmers with a prefix equal to 
\begin_inset Formula $query$
\end_inset


\end_layout

\begin_layout Verse
let 
\begin_inset Formula $h_{min},\:h_{max}:\:\forall h_{i}\in H:\:h_{min}\leq h_{i}\leq h_{max}$
\end_inset

 be the upper and lower bound for 
\begin_inset Formula $H$
\end_inset


\end_layout

\begin_layout Verse
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Verse
to find 
\begin_inset Formula $h_{min}$
\end_inset

 we observe that as 
\begin_inset Formula $h_{min}$
\end_inset

has a prefix equal to 
\begin_inset Formula $query$
\end_inset

 it holds true that 
\end_layout

\begin_layout Verse
\begin_inset Formula $hash(h_{min})\geq h_{p}$
\end_inset

 because the first 
\begin_inset Formula $m$
\end_inset

 summands of the hash are given by the prefix a
\end_layout

\begin_layout Verse
we choose the other summands 
\begin_inset Formula $r(q_{i>m})\:\sigma^{k-i-1}$
\end_inset

to all be as small as possible by using characters such that 
\begin_inset Formula $\forall q_{i}:\:r(q_{i})=0$
\end_inset

 
\end_layout

\begin_layout Verse
thus 
\begin_inset Formula $h_{min}=h_{p}+\sum_{i=m}^{k}\:0*\sigma^{k-i-1}=h_{p}$
\end_inset


\end_layout

\begin_layout Verse
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Verse
to find 
\begin_inset Formula $h_{max}$
\end_inset

 we observe that 
\begin_inset Formula $\#H=\sigma^{k-m}$
\end_inset

 
\end_layout

\begin_layout Verse
we furthermore observe that for two hashes 
\begin_inset Formula $h_{a},\,h_{b}\in H:\,h_{a}<h_{b}$
\end_inset


\end_layout

\begin_layout Verse
the difference between the hashes 
\begin_inset Formula $h_{a}-h_{b}\geq1$
\end_inset


\end_layout

\begin_layout Verse
This is because given 
\begin_inset Formula $q_{a}=(a_{1},\,...,\,a_{k-1},\,a_{k})\::hash(q_{a})=h_{a}$
\end_inset

to find the next smallest hash that is also in 
\begin_inset Formula $H$
\end_inset

, we replace 
\begin_inset Formula $a_{k}$
\end_inset

with 
\begin_inset Formula $\alpha_{k}$
\end_inset

such that 
\begin_inset Formula $r(a_{k})=r(\alpha_{k})+1$
\end_inset


\end_layout

\begin_layout Verse
This means that 
\begin_inset Formula $hash(q_{a})$
\end_inset

 increases by 
\begin_inset Formula $(r(a_{k})\:\sigma^{k-(k-1)})-(r(\alpha_{k})\:\sigma^{k-(k-1)})=1$
\end_inset


\end_layout

\begin_layout Verse
Given this information we can conclude 
\begin_inset Formula $H=\{h_{p},\,h_{p}+1,\,h_{p}+1,\,...,\,h_{p}+\sigma^{k-m}\}$
\end_inset

 
\end_layout

\begin_layout Standard
This gives us far less costly way to generate all hashes in a simple for-loop:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={[GNU]C++},numbers=left,basicstyle={\normalsize\ttfamily},tabsize=2"
inline false
status open

\begin_layout Plain Layout

// member of kmer index
\end_layout

\begin_layout Plain Layout

constexpr size_t _sigma = ...
 // alphabet size
\end_layout

\begin_layout Plain Layout

std::vector<size_t> check_last_kmer(...
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template<std::ranges::range range_t>
\end_layout

\begin_layout Plain Layout

std::vector<size_t> search_sub_k(range_t& query)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	size_t size = query.size();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// generate bounds of set of all hashes 
\end_layout

\begin_layout Plain Layout

	// for kmers that have query as prefix
\end_layout

\begin_layout Plain Layout

	size_t prefix_hash = hash(query);                      //h_p				
\end_layout

\begin_layout Plain Layout

	size_t lower_bound = 0 + prefix_hash;                  //h_min			
\end_layout

\begin_layout Plain Layout

	size_t upper_bound = prefix_hash + pow(_sigma, k-size);//h_max
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	// lookup each hash and return
\end_layout

\begin_layout Plain Layout

	std::vector<size_t> output_positions;
\end_layout

\begin_layout Plain Layout

	for (size_t h = lower_bound; h < upper_bound; ++h) 
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		for (size_t pos : _data.at(h))
\end_layout

\begin_layout Plain Layout

			output_positions.push_back(pos)
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	// cover edge case for last kmer
\end_layout

\begin_layout Plain Layout

	for (size_t pos : check_last_kmer(query))
\end_layout

\begin_layout Plain Layout

		output_positions.push_back(pos);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return output_positions;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Search function for exact matches for a query of size 0 < m < k |
\begin_inset Formula $ยน$
\end_inset

 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that after looking up all hashes dependend on the query, we also need
 to call 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{check_last_kmer}
\end_layout

\end_inset

.
 This is to cover an edge case were the query happens to be a substring
 of the last kmer in the text.
 As the query is compared against prefixes of all kmers there is no kmer
 with a position 
\begin_inset Formula $p>text.size()-k$
\end_inset

 so the query is manually compared against the last 
\begin_inset Formula $k-1$
\end_inset

 letters in the text each search call.
\end_layout

\begin_layout Standard
While this way of searching is more costly than just a simple lookup as
 done for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{query.size == k}
\end_layout

\end_inset

 it is feasable to search queries in a sufficiently fast way if the prefix
 is as long as possible.
\end_layout

\begin_layout Lemma
search performance for queries of size 
\begin_inset Formula $m:\,(k\mod m)\neq0\:\land m<k$
\end_inset

 is inversely proportional to 
\begin_inset Formula $k-m$
\end_inset


\end_layout

\begin_layout Standard
Initial observations recommend 
\begin_inset Formula $k-m$
\end_inset

 be no more than 
\begin_inset Formula $3$
\end_inset

 if possible.
 The actual implementation throws an exception if 
\begin_inset Formula $\sigma^{k-m}>10^{7}$
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
While somewhat arbitrarily chosen, 
\begin_inset Formula $10^{7}$
\end_inset

represents the case of 
\begin_inset Formula $k-m>11$
\end_inset

 for the dna alphabet (
\begin_inset Formula $\sigma=4$
\end_inset

) which should allow most users to be able to not encounter the exception
 during proper usage of the kmer index and notably will mean for 
\begin_inset Formula $k=10$
\end_inset

 queries of all length be accepted.
\end_layout

\end_inset

as if it was unchecked a badly chosen m and k combination could take many
 hours to complete because of the amount of kmers that have to be looked
 up.
\end_layout

\begin_layout Subsection
query size m > k
\end_layout

\begin_layout Standard
For longer queries the query is split into parts of length k.
 If 
\begin_inset Formula $m\mod k\neq0$
\end_inset

 there will also be a part (
\begin_inset Quotes eld
\end_inset

rest
\begin_inset Quotes erd
\end_inset

) with a length 
\begin_inset Formula $<k$
\end_inset

.
 We observer that the positions of the query are a subset of the positions
 of the first kmer 
\begin_inset Formula $p_{1}$
\end_inset

in the query.
 To confirm wether a positions of 
\begin_inset Formula $p_{1}$
\end_inset

is valid, we crossreference the positions with the next part:
\end_layout

\begin_layout Verse
let query 
\begin_inset Formula $q=(q_{1},\,q_{1},\,...,\,q_{m})$
\end_inset

 be of length 
\begin_inset Formula $m:\:m>k\,\land\,m\mod k\neq0$
\end_inset


\end_layout

\begin_layout Verse
let 
\begin_inset Formula $p_{i}=(q_{i},\,...,q_{i+k})$
\end_inset

 with 
\begin_inset Formula $i\in[0,\,(m-(m\mod k))/k]$
\end_inset

 be the i-th kmer in the query
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $r=(q_{m-(m\%k)},\,...,q_{m})$
\end_inset

 be the 
\begin_inset Quotes eld
\end_inset

rest
\begin_inset Quotes erd
\end_inset

 of length 
\begin_inset Formula $m\mod k$
\end_inset


\end_layout

\begin_layout Verse
then the query occurs at positions 
\begin_inset Formula $pos(q_{seed})\in pos(q_{1},...q_{k})=pos(p_{1})$
\end_inset

 iff
\end_layout

\begin_layout Verse
there exists at position 
\begin_inset Formula $\rho_{2}\in pos(p_{2})$
\end_inset

 such that 
\begin_inset Formula $\rho_{2}=q_{seed}+k$
\end_inset

, and there exists a position 
\begin_inset Formula $\rho_{3}\in pos(p_{3})$
\end_inset

 such that 
\begin_inset Formula $\rho_{3}=\rho_{2}+k$
\end_inset

, etc.
\end_layout

\begin_layout Verse
For 
\begin_inset Formula $\rho_{(m-(m\mod k))/k}$
\end_inset

 we also need to check for position 
\begin_inset Formula $\rho_{rest}\in pos(rest)$
\end_inset

 so that 
\begin_inset Formula $\rho_{rest}=\rho_{i+k}+k$
\end_inset


\end_layout

\begin_layout Standard
For perfomance purposes if at any point the program does not find a fitting
 
\begin_inset Formula $\rho_{i}$
\end_inset

, the current position in 
\begin_inset Formula $pos(q_{seed})$
\end_inset

 is marked as invalid the loop moves onto the next.
 While the worst-case performance (all position in 
\begin_inset Formula $pos(q_{seed})$
\end_inset

 are valid) is costly this behavior also provides a very important fact
 about searching query of length 
\begin_inset Formula $m>k$
\end_inset

:
\end_layout

\begin_layout Lemma
search time for queries of size 
\begin_inset Formula $m:\,m>k$
\end_inset

 scales inversely proportional to the number of results for the corresponding
 
\begin_inset Formula $p_{i}$
\end_inset


\end_layout

\begin_layout Subsection
Choosing the right k
\end_layout

\begin_layout Standard
In praxis usually both the texts size and the queries and thus their lengths
 are given and cannot be controlled.
 
\begin_inset Formula $k$
\end_inset

 however can be freely chosen.
 Give a fixed text size, longer sequences will have a lower number occurences
 than short sequences.
 Accordant to Lemma #3, this means k should be chosen as high as possible.
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that we are not only limited by the machines memory but also the fact
 that the kmer hashes have to fit in a 64-bit unsigned integer which necessitate
s an alphabet and k combination so that 
\begin_inset Formula $\sigma^{k}<2^{64}$
\end_inset

.
 For the 4-letter dna alphabet, this means k can at most be 31 while for
 bigger alphabets, k has to be chosen far lower.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Furthermore sets of queries with a relatively narrow distribution of query
 lengths should be preferred as in this case a 
\begin_inset Formula $k$
\end_inset

 should be chosen so that as many queries as possible are either divisible
 by 
\begin_inset Formula $k$
\end_inset

 (which is optimal c.f.
 Lemma #1) or if not, the rest of integer division 
\begin_inset Formula $m\mod k$
\end_inset

 should be as high as possible as this means accordant to Lemma #2 that
 the prefix is as long as possible and thus 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{search_k}
\end_layout

\end_inset

 has as few kmers to search as possible.
 However given practical examples the set of queries is rarely homogenous
 enough to be able to choose a single k that fullfills all of these criteria.
 Due to this the kmer index was implemented in a way where multiple k can
 be chosen at once, unifying multiple kmer indices for different k into
 one and letting the index choose the optimal k to search with.
\end_layout

\begin_layout Section
Multi-kmer Index
\end_layout

\begin_layout Standard
As evident from section 2, the search performance is highly variable depending
 on mostly the length of the query in relationship to kin the query and
 thus also on the text size itself.
 As well as the number of results for each kmer .
 To investigate this further a benchmark was conducted: 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/kmer_vs_fm_over_query_size/k10_search_over_query.png
	lyxscale 10
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Graph demonstrating the highly variable search performance of the kmer index
 based on query length.
 The inset graph is showing a 
\begin_inset Quotes eld
\end_inset

zoomed in
\begin_inset Quotes erd
\end_inset

 view of the are for query length 16 to 20.
 The grey dotted lines mark query length that are a multiple of k
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Benchmark results show a predicatble pattern, substantiating everything
 explained in <TODO: section 2>: Worst case performance is at 
\begin_inset Formula $k+1$
\end_inset

 (because that is where 
\begin_inset Formula $k-(k\mod m)$
\end_inset

 is maximal, c.f.
 <TODO: lemma 3>).
 The peaks of the worst case lower as the query size increases because given
 a fixed text size, the number of results for longer queries is statistically
 likely to be lower which means the 
\begin_inset Formula $m>k$
\end_inset

 search can 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{break}
\end_layout

\end_inset

 out of the crossreferencing loop discussed in <TODO: section> earlier.
 To mitigate these peaks, the kmer index was extended to hold the position
 data for multiple k (henceforth referred to as 
\begin_inset Quotes eld
\end_inset

multi-kmer index
\begin_inset Quotes erd
\end_inset

).
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// regular "single" kmer index
\end_layout

\begin_layout Plain Layout

template<size_t k>         
\end_layout

\begin_layout Plain Layout

class kmer_index_element { (...)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// multi-kmer index
\end_layout

\begin_layout Plain Layout

template<size_t...
 ks>
\end_layout

\begin_layout Plain Layout

class kmer_index : protected kmer_index_element<ks>...
 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

// multi-k search function
\end_layout

\begin_layout Plain Layout

result_t search(std::vector<alphabet_t> query) 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	// pick optimal k for query
\end_layout

\begin_layout Plain Layout

	std::vector<size_t> all_ks = {ks...};
\end_layout

\begin_layout Plain Layout

	size_t optimal_k = all_ks.at(0);
\end_layout

\begin_layout Plain Layout

	size_t m = query.size();
\end_layout

\begin_layout Plain Layout

	for (size_t k : all_ks) 
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		if (m % k == 0) {
\end_layout

\begin_layout Plain Layout

			optimal_k = k; 
\end_layout

\begin_layout Plain Layout

			break;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		else if ((m % k) > (m % optimal_k))
\end_layout

\begin_layout Plain Layout

			optimal_k = k;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// use the correct index element 
\end_layout

\begin_layout Plain Layout

	return kmer_index_element<optimal_k>::search(query);//*
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
C++-like *Pseudocode demonstrating multiple inheritance and behavior of
 search function for multi-kmer index
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Implementation defined Optimization
\end_layout

\begin_layout Standard
While few of the ideas here improve the theoretical performance of the kmer
 index, certain implementation choices contributed significantly to it having
 a chance to outpace the fm index.
 Picking C++ as the language of choice was an intentional decision made
 to allow the author to have flexibility <TODO>
\end_layout

\begin_layout Subsection
Returning by Reference
\end_layout

\begin_layout Standard
As we've seen in section <TODO>, for queries of length 
\begin_inset Formula $m:\:m=k$
\end_inset

 the returned positions of the query are simply the entry in the map for
 the corresponding hash.
 However for 
\begin_inset Formula $m:\:m>k\,\land\,m\%k=0$
\end_inset

 there may not be any entry in the map that exactly corresponds to the positions
 of the query, while all positions for it are from the corresponding vector
 in the map for hash of the first k characters, not all positions in the
 vector are correct, some have to be thrown out.
 For 
\begin_inset Formula $m:\:m<k$
\end_inset

 there may not be a single vector in the map that represents all positions,
 as all kmer with the prefix equal to query are valid positions, the resulting
 positions correspond to multiple vector in the actual map.
 Performance wise this proves problematic, copying many positions into a
 result vector as well as allocating that result vector introduce a huge
 overhead that is unexceptable.
 To fix this a result class was created that simply holds the references
 to the correct vectors as well as information about which results within
 those are valid (as needed for the 
\begin_inset Formula $m:\:m>k\,\land\,m\%k=0$
\end_inset

 case):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

struct kmer_index_result 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	private: 
\end_layout

\begin_layout Plain Layout

		class kmer_index_result_iterator {...}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// bool vector equivalent that 
\end_layout

\begin_layout Plain Layout

		// specifies for each position in _positions
\end_layout

\begin_layout Plain Layout

		// wether or not it should be used 
\end_layout

\begin_layout Plain Layout

		compressed_bitvector _bitmask;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// pointer to positions held by 
\end_layout

\begin_layout Plain Layout

		// map of kmer_index
\end_layout

\begin_layout Plain Layout

		std::vector<const std::vector<size_t>*> _positions;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		(...)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public:
\end_layout

\begin_layout Plain Layout

		// CTOR
\end_layout

\begin_layout Plain Layout

		kmer_index_result(...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// usable as range
\end_layout

\begin_layout Plain Layout

		kmer_index_result_iterator begin();
\end_layout

\begin_layout Plain Layout

		kmer_index_result_iterator end();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// member of kmer_index: search query of any length
\end_layout

\begin_layout Plain Layout

template<std::ranges::range query_t>
\end_layout

\begin_layout Plain Layout

kmer_index_result search(query_t&& query);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// in main: result simply usable as range
\end_layout

\begin_layout Plain Layout

auto index = kmer_index<...>(text);
\end_layout

\begin_layout Plain Layout

auto result = index.search(query);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for (auto position : result)
\end_layout

\begin_layout Plain Layout

	std::cout << result << "
\backslash
n";
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
The kmer index returns the above defined kmer_index_result.
 It can be used like any other range, here illustrated in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{//main}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

The result only holds the pointers to the corresponding vectors of positions
 inside the kmer index.
 This allows for construction of the result to be minimal, it only needs
 to move the pointers into 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{_positions}
\end_layout

\end_inset

 and initialize 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{_bitmask}
\end_layout

\end_inset

.
 During the search call, the kmer index signals to the result which positions
 should be used and which should be discarded, however none of them are
 actually removed from the vectors, instead when the results is evaluated
 later on, it only returns valid positions and skips past the ones marked
 as invalid <TODO: cite code>.
 This removes the need to allocate a vector of positions and improves search
 performance dramatically while not sacrificing usability.
 
\end_layout

\begin_layout Subsection
Choosing the fastes Pow Implementation
\end_layout

\begin_layout Standard
By the nature of the hash used to hash kmers in the kmer index, exponentiation
 (pow() in programming terms) is used everywhere, however exclusively with
 positive integers.
 Furthermore all pow functions need to be able to be evaluated at compile
 time (c.f.
 section <TODO>) It was thus imperative to choose the most optimal pow implement
ation.
 A benchmark was conducted for 4 different implementations and the results
 were compared:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{trivial_pow(base,n)}
\end_layout

\end_inset

: A trivial implementation calling base*base n -many times
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{recursive_pow(base,n)}
\end_layout

\end_inset

: Utilizing a recursive approach, the function calls itself recursively
 n-many times and then evaluates each call bottom-up to then return the
 correct result base on wether the exponent was odd or even
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{bit_pow(base,n)}
\end_layout

\end_inset

: Rather than using 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{operator*}
\end_layout

\end_inset

 for multiplication, this implementation utilizes equivalent bit operations
 which are generally more well-optimized on modern machines
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{switch_pow(base,n)}
\end_layout

\end_inset

: Instead of using a loop, this implementation has multiple switch cases
 with identical code, when the function is called a lookup in a constexpr
 table produces the correct first switch case to start with and then the
 results falls through the rest of them the correct number of times.
 Any exponentiation that would overflow the unsigned 64-bit integer result
 is immediately caught and 0 is returned instead.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/pow_vs_pow/pow_vs_pow.png
	lyxscale 15
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Boxplot showing runtime (y-axis log scaled) for different pow implementations.
 The notches represent the confidence interval around the median.
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As clearly evident from the benchmarks, the approach switch_pow took vastly
 outpaces the others and as such was used for the kmer_index implmentation
 wherever possible.
\end_layout

\begin_layout Subsection
Choosing the fastest Hash Implementation
\end_layout

\begin_layout Standard
Simiarly to pow, the result of the hash function transforming a kmer into
 a 64-bit integer is integral to the index function and optimizing it's
 runtime as much as possible is very advantageous.
 Two hash implementations were compared:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

constexpr uint8_t _sigma = alphabet_size<alphabet_t>;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static size_t hash_for(iterator_t query_begin)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	size_t hash = 0;
\end_layout

\begin_layout Plain Layout

	for (size_t i = 0; i < k; ++i)
\end_layout

\begin_layout Plain Layout

		hash += to_rank(*it++) * pow(_sigma, k-i-1)
\end_layout

\begin_layout Plain Layout

	return hash;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Trivial implementation for kmer hash utilizing a simple for loop
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

template<size_t...
 is>
\end_layout

\begin_layout Plain Layout

static size_t hash_fold_aux(iterator_t it, 
\end_layout

\begin_layout Plain Layout

	std::index_sequence<is...> sequence)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return (...
 + to_rank(*it) * pow(_sigma, k-is-1))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

static size_t hash_fold(iterator_t query_begin)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return hash_fold_aux(query_begin, std::make_index_sequence<k>()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation of hash function utilizing fold expression
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_fold}
\end_layout

\end_inset

 uses the fact that both k, 
\begin_inset Formula $\sigma$
\end_inset

 and pow are all available at compile time.
 This allows the compiler to unwrap the fold expression and calculate all
 factors 
\begin_inset Formula $pow(\sigma,\,k-i-1)\,:i\in\{0,1,2,...,k\}$
\end_inset

at compile time thus increasing runtime performance.
 To illustrate this a benchmark was conducted comparing both hash-implementation
 for randomized kmers of length 
\begin_inset Formula $k\in\{5,\,10,\,15,\,20,\,25\}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/hash_vs_hash/hash_vs_hash.png
	lyxscale 10
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Multiple boxplots for different k showing distribution of runtime results
 for hash implementations (y-axes have been normalized to the same scale
 to enable valid comparison between graphs) 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Benchmarks results show that for all tested k the fold-expression implemetation
 for the hash has superior median runtime
\begin_inset Foot
status open

\begin_layout Plain Layout
Datapoints outside of the 99.9% confidence interval (correspondingly for
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_fold}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_for}
\end_layout

\end_inset

 seperateley) have been discarded from the benchmark result times as they
 represent random interference caused by other processes of the OS the benchmark
 was run on.
 
\end_layout

\end_inset

.
 The relatively large variance in for all but 
\begin_inset Formula $k=5$
\end_inset

 is believed to be cause interference in the benchmark environment.
 For 
\begin_inset Formula $k=5$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_fold}
\end_layout

\end_inset

 is dramatically faster than 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_for}
\end_layout

\end_inset

 which may be attributed to cache-artifacts that allow the CPU to hold all
 factors of the precalculated hash sum in the L1 cache improving access
 times.
 These results are indicitave that the fold implementation is more performant
 and was thus choosen to be used by the kmer index whenever possible.
\end_layout

\begin_layout Subsection
Choosing the fastest Map
\end_layout

\begin_layout Standard
As an 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{unordered_map}
\end_layout

\end_inset

 with the keys as 64-bit hashes and the value a vector of text positions,
 ( 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::vector<uint32_t}
\end_layout

\end_inset

 by default) is the data structure used to assess the data inside the kmer
 index, choosing the most performant map implementation is of vital importance.
 As 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::unordered_map}
\end_layout

\end_inset

 did not proof sufficient enough, other maps were tested and evaluated specifica
lly for the context of use in a kmer index (that is with the key type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{size_t}
\end_layout

\end_inset

 and the value type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::vector<uint32_t>}
\end_layout

\end_inset

.
 Tested were
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::unordered_map}
\end_layout

\end_inset

 from the C++17 standard library <TODO https://en.cppreference.com/w/cpp/container
/unordered_map
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{boost::unordered_map}
\end_layout

\end_inset

 from the 1.65.1 Boost Library <TODO https://www.boost.org/doc/libs/1_65_0/doc/html/
boost/unordered_map.html
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{absl::node_hash_map}
\end_layout

\end_inset

 from Googles' Abseil <TODO: https://abseil.io/docs/cpp/guides/container#abslnode
_hash_map-and-abslnode_hash_set
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{robin_hood::unordered_map}
\end_layout

\end_inset

 as provided by Martin Ankerl <TODO: https://github.com/martinus/robin-hood-hashi
ng>
\end_layout

\begin_layout Standard
The choice of maps was largely based on availability and the opinions of
 other <todo: cite blog>.
 For the benchmark each map was filled with a fixed number of randomized
 elements and was then queried with it's given 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{at(size_t hash)}
\end_layout

\end_inset

 function.
 Only retrieval was tested here since after construction no insertion takes
 places during searching with the kmer index.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/map_vs_map/map_vs_map.png
	lyxscale 10
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
search performance for different map implementations
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As clearly evident, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{robin_hood::unordered_map}
\end_layout

\end_inset

 outperformed every other map tested and was as such used in the kmer index
 whenever possible.
\end_layout

\begin_layout Subsection
Choosing the right k(s)
\end_layout

\begin_layout Standard
Given the kmers inconsistent nature, picking the best possible k has a large
 impact on the search performance.
 While with a single k this is hard to do, given the option to have any
 number of k raises the question of how many and which to pick.
 
\end_layout

\begin_layout Section
Conclusion & Outlook
\end_layout

\begin_layout Subsection
Further Features
\end_layout

\begin_layout Subsubsection
mix k-results for different ks to cover rest optimally
\end_layout

\begin_layout Subsubsection
compress map to cover all k
\end_layout

\begin_layout Standard
each map takes #kmer * sizeof(hash_t) + text_size * position_t
\end_layout

\begin_layout Subsubsection
(each map takes #kmers * 64 for the keys + uint32_t * text_size for positions.
\end_layout

\begin_layout Subsubsection
sizeof(hash_t) > 64
\end_layout

\end_body
\end_document
