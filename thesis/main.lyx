#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\definecolor{gray}{rgb}{0.5, 0.5, 0.5}
\definecolor{keyword}{RGB}{243, 60, 114}
\definecolor{comment}{RGB}{0, 200, 101}
\definecolor{background}{rgb}{0.9, 0.9, 0.9}

\usepackage{listings}
\usepackage{xparse}

\usepackage{mathtools}
\usepackage{algorithm,algpseudocode}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams-chap-bytype
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "beramono" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "keywordstyle={\bfseries \color{keyword}},commentstyle={\color{comment}},caption={Search function for exact matches for a query of size 0 < m < k $^{[1]}$},captionpos=b,backgroundcolor={\color{background}},basicstyle={\ttfamily\small},language={C++},numbers=none,captionpos=b,tabsize=2"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Implementation and Performance Evaluation of a k-mer Index for exact String
 Matching
\end_layout

\begin_layout Author
Author: Clemens Cords, FU Berlin
\end_layout

\begin_layout Abstract
As demand for large-scale genomic sequence matching rises, so does the ability
 to efficiently get the positions or number of occurrences of a query of
 length k called a kmer.
 A kmer-index optimized for this purposes was implemented and it's performance
 evaluated.
 The implementation is capable of searching kmers of arbitrary length specified
 at runtime, utilizes parallelization for faster construction and it's internal
 structure can be further customized at compile time to achieve greater
 performance for certain query sizes.
 The nature of the internal structure and search functions is explained
 and their performant nature demonstrated through benchmarks.
 Results indicate that for the purpose of finding positions or number of
 occurrences for queries of the commonly used length 
\begin_inset Formula $k\in\{3,4,...,30\}$
\end_inset

 compared to the fm-index the kmer-index performs up to 60% faster and is
 thus recommended.
 For arbitrarily long queries the kmer-index was shown to exhibit speedup
 or slowdown of 
\begin_inset Formula $\pm5$
\end_inset

% depending on text length and is thus in it's current iteration applicable
 but not necessarily better suited for this purpose.
\end_layout

\begin_layout Abstract
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
A k-mer (also known as 
\begin_inset Quotes eld
\end_inset

q-gram
\begin_inset Quotes erd
\end_inset

, henceforth written as 
\begin_inset Quotes eld
\end_inset

kmer
\begin_inset Quotes erd
\end_inset

) is any genomic sequence of length 
\begin_inset Formula $k$
\end_inset

, usually in the context of being a sub-sequence of a longer genome.
 Analysis of kmers is used in a wide variety of contexts such as in de novo
 genome assembly
\begin_inset CommandInset citation
LatexCommand cite
key "kmer: megahit assembly,kmer: soapdenovo assembly"
literal "false"

\end_inset

, taxonomic profiling
\begin_inset CommandInset citation
LatexCommand cite
key "kmer: taxonomical profiling"
literal "false"

\end_inset

 and sequence classification
\begin_inset CommandInset citation
LatexCommand cite
key "kmer: kraken LCA"
literal "false"

\end_inset

.
 Furthermore kmer spectra (a graph of the multiplicity of each kmer in the
 set of pairwise different kmer in the reference) have been used to assess
 genome similarity
\begin_inset CommandInset citation
LatexCommand cite
key "kmer: spectrum dissimilarity"
literal "false"

\end_inset

 and to correct errors in sequence data
\begin_inset CommandInset citation
LatexCommand cite
key "kmer: spectrum error correction"
literal "false"

\end_inset

.
 Seqan3, a newly released version of the C++ API for sequence analysis has
 yet to implement a purpose-build index for kmer searching.
 This paper aims to access the viability of substituting seqan3s fm-index
\begin_inset CommandInset citation
LatexCommand cite
key "seqan3 fm-index master"
literal "false"

\end_inset

 with the presented kmer-index implementation not only for the purpose of
 searching small kmers but for exact string matching in general by comparing
 the indices performance to each other.
\end_layout

\begin_layout Section
Construction
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Verse

\series bold
Input
\series default
: text
\end_layout

\begin_layout Verse

\series bold
let
\series default
 
\begin_inset Formula $n$
\end_inset

 
\begin_inset Formula $\leftarrow$
\end_inset

 text.size()
\end_layout

\begin_layout Verse

\series bold
for
\series default
 
\begin_inset Formula $i$
\end_inset

 
\series bold
in
\series default
 
\begin_inset Formula $\{1,2,...,n\}$
\end_inset

 
\series bold
do
\end_layout

\begin_deeper
\begin_layout Verse

\series bold
let
\series default
 
\begin_inset Formula $h$
\end_inset

 
\begin_inset Formula $\leftarrow$
\end_inset

 hash(text.substring(
\begin_inset Formula $i,\:i+k$
\end_inset

))
\end_layout

\begin_layout Verse
index[
\begin_inset Formula $h$
\end_inset

] = 
\begin_inset Formula $(\text{index}[h],\:i)$
\end_inset


\end_layout

\end_deeper
\begin_layout Verse

\series bold
end
\end_layout

\begin_layout Verse

\series bold
return
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Construction of the kmer index.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The kmer-index utilizes an unordered map as it's central data structure
 which for each kmer saves the position of all occurrences in the text.
 To save on memory the kmers are converted to an unsigned integer via the
 following hash function and stored as such instead:
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $kmer$
\end_inset

 = 
\begin_inset Formula $(q_{1},\,q_{2},\,...,q_{k})$
\end_inset

 where 
\begin_inset Formula $q\in A$
\end_inset


\end_layout

\begin_layout Verse
\begin_inset Formula $hash(kmer)$
\end_inset

 = 
\begin_inset Formula $\sum_{i=0}^{k}\:r(q_{i})\:\sigma^{k-i-1}$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Verse
where 
\begin_inset Formula $\sigma=\#A$
\end_inset

 , 
\begin_inset Formula $r(q_{i})\in\{0,1,...,\sigma-1\}$
\end_inset

 the rank of 
\begin_inset Formula $q_{i}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
This hash guarantees no hash collisions
\begin_inset CommandInset citation
LatexCommand cite
key "seqan2 doctor arbeit"
literal "false"

\end_inset

 and was furthermore chosen because the kmer-index is to be integrated and
 compared to the Seqan3 library which uses the same hash function
\begin_inset CommandInset citation
LatexCommand cite
key "seqan3 docs: kmer hash"
literal "false"

\end_inset

.
 Constructing the kmer-index is fairly straight-forward: We can simply iterate
 through the text while keeping track of the current position and adding
 it to the end of the appropriate entry for the current kmer.
 Given a text of length 
\begin_inset Formula $n$
\end_inset

, 
\begin_inset Formula $n-k$
\end_inset

 hashes will be generated and inserted into the index.
 Construction therefore has linear amortized complexity which is acceptable
 because for genomic data index construction will usually be done only once
 after which the index is serialized and can be loaded directly if needed
 at a later point.
\end_layout

\begin_layout Section
Searching
\end_layout

\begin_layout Standard
To achieve greater flexibility the kmer-index implementation is capable
 of searching queries of arbitrary length regardless of the 
\begin_inset Formula $k$
\end_inset

 that is used to create it.
 While a k still needs to be specified at compile time, at runtime any query
 can be searched; however the search functions performance will vary drastically
 depended on the queries length in relation to 
\begin_inset Formula $k$
\end_inset

.
 
\end_layout

\begin_layout Subsection
Query Size m = k
\end_layout

\begin_layout Standard
The best performing cases are queries of length exactly 
\begin_inset Formula $k$
\end_inset

.
 For these a simple lookup in the indices unordered map will return all
 results at once:
\begin_inset Foot
status open

\begin_layout Plain Layout
All code examples henceforth are edited for brevity and only meant for the
 purpose of demonstrating the programs behavior unless otherwise specified.
 The actual implementations makes many concessions for the sake of performance
 that can be viewed in it's entirety in the actual code
\begin_inset CommandInset citation
LatexCommand cite
key "my github"
literal "false"

\end_inset

 and would be too lengthy to print here.
\end_layout

\end_inset

 
\end_layout

\begin_layout LyX-Code
\begin_inset listings
lstparams "language={[GNU]C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

unordered_map<size_t, std::vector<uint32_t>> _data;
\end_layout

\begin_layout Plain Layout

uint64_t hash((...) query) const {(...)};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template<std::ranges::range query_t>
\end_layout

\begin_layout Plain Layout

std::vector<size_t>& search_k(query_t& query) const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	const auto* it = _data.at(hash(query));
\end_layout

\begin_layout Plain Layout

	if (it == _data.end())
\end_layout

\begin_layout Plain Layout

		return std::vector<size_t>();
\end_layout

\begin_layout Plain Layout

	else 
\end_layout

\begin_layout Plain Layout

		return *it;
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Search function for queries of size k.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
By nature of using an unordered map, querying a single entry has constant-time
 amortized complexity dependent on the number of pairwise different kmers
 in the text and therefore the number of different entries in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{_data}
\end_layout

\end_inset

.
 C++s return value optimization
\begin_inset CommandInset citation
LatexCommand cite
key "cpp RVO"
literal "false"

\end_inset

 ensures that the positions are never actually copied and only a reference
 to them is moved between functions which other than the time it takes for
 the hash-function to return, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{search_k}
\end_layout

\end_inset

s runtime is very close to that of a single lookup in the map.
 This is the kmer-indices main strength and queries of length 
\begin_inset Formula $k$
\end_inset

 should be considered a best-case scenario.
\end_layout

\begin_layout Lemma
Search performance for queries of size 
\begin_inset Formula $m:\,m=k$
\end_inset

 is dependent on the absolute number of pairwise different hashes in the
 text
\end_layout

\begin_layout Subsection
Query Size m < k
\end_layout

\begin_layout Standard
To be able to search queries of arbitrary length without modifying the indices
 internal structure for queries of length 
\begin_inset Formula $m<k$
\end_inset

 we need to apply a different approach: As we cannot get the results for
 the query directly we instead return the positions of all kmers that have
 the query as a prefix.
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $query=(q_{1},q_{2},...,q_{m})$
\end_inset

 where 
\begin_inset Formula $m<k$
\end_inset

 
\end_layout

\begin_layout Verse
for an arbitrary 
\begin_inset Formula $kmer=(s_{1},...,s_{k})$
\end_inset

 it holds true that:
\end_layout

\begin_layout Verse
iff 
\begin_inset Formula $\forall i\leq m:\:q_{i}=s_{i}$
\end_inset

 then any position 
\begin_inset Formula $pos$
\end_inset

 of 
\begin_inset Formula $kmer$
\end_inset

 is also a position of 
\begin_inset Formula $query$
\end_inset


\end_layout

\begin_layout Verse
because the 
\begin_inset Formula $m$
\end_inset

 characters proceeding 
\begin_inset Formula $pos$
\end_inset

 are 
\end_layout

\begin_layout Verse
\begin_inset Formula $s_{0},...,s_{m},...,s_{k}$
\end_inset

 and 
\begin_inset Formula $s_{0},...,s_{m}=q_{0},...,\,q_{m}=query$
\end_inset


\end_layout

\begin_layout Standard
\noindent
To avoid generating all kmers that contain 
\begin_inset Formula $query$
\end_inset

 as a prefix and then hashing them we instead generate the hashes directly.
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $hash(q_{1},q_{1},...,q_{m})=\sum_{i=0}^{k}\:r(q_{i})\:\sigma^{k-i}=h_{q}$
\end_inset

 constant as given by 
\begin_inset Formula $query$
\end_inset


\end_layout

\begin_layout Verse
let 
\begin_inset Formula $H\subset\mathbb{Z}^{+}\coloneqq$
\end_inset

 set of all hashes of kmer with a prefix equal to 
\begin_inset Formula $query$
\end_inset


\end_layout

\begin_layout Verse
let 
\begin_inset Formula $h_{min},\:h_{max}:\:\forall h_{i}\in H:\:h_{min}\leq h_{i}<h_{max}$
\end_inset

 be the lower and upper bound of 
\begin_inset Formula $H$
\end_inset


\end_layout

\begin_layout Verse
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Verse
to find 
\begin_inset Formula $h_{min}$
\end_inset

 we observe that as the query 
\begin_inset Formula $q_{min}:\,r(q_{min})=h_{min}$
\end_inset

 has a prefix equal to 
\begin_inset Formula $query$
\end_inset

 it holds true that 
\end_layout

\begin_layout Verse
\begin_inset Formula $hash(h_{min})\geq h_{p}$
\end_inset

 because the first 
\begin_inset Formula $m$
\end_inset

 summands 
\begin_inset Formula $r(q_{min,j})\:\sigma^{k-j-1}:1\leq j\leq m$
\end_inset

 of the hash are given by the prefix
\end_layout

\begin_layout Verse
we choose the other summands 
\begin_inset Formula $r(q_{i})\:\sigma^{k-i-1}:i>m$
\end_inset

 to all be as small as possible by choosing characters such that 
\begin_inset Formula $\forall q_{i}:\:r(q_{i})=0$
\end_inset

 
\end_layout

\begin_layout Verse
thus 
\begin_inset Formula $h_{min}=h_{p}+\sum_{i=m+1}^{k}\:0*\sigma^{k-i-1}=h_{p}$
\end_inset


\end_layout

\begin_layout Verse
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Verse
to find 
\begin_inset Formula $h_{max}$
\end_inset

 we observe that 
\begin_inset Formula $\#H=\sigma^{k-m}$
\end_inset

 because 
\begin_inset Formula $m$
\end_inset

 characters of each query are given by the prefix
\end_layout

\begin_layout Verse
we furthermore observe that for two hashes 
\begin_inset Formula $h_{a},\,h_{b}\in H:\,h_{a}<h_{b}$
\end_inset

the difference between the hashes 
\begin_inset Formula $h_{a}-h_{b}\geq1$
\end_inset


\end_layout

\begin_layout Verse
this is because given 
\begin_inset Formula $q_{a}=(a_{1},\,...,\,a_{k-1},\,a_{k})\::hash(q_{a})=h_{a}\neq h_{max}-1$
\end_inset

 to find the next smallest hash that is also in 
\begin_inset Formula $H$
\end_inset

, we replace the last letter 
\begin_inset Formula $a_{k}$
\end_inset

 with 
\begin_inset Formula $\alpha_{k}$
\end_inset

 such that 
\begin_inset Formula $r(a_{k})=r(\alpha_{k})+1$
\end_inset

.
 If 
\begin_inset Formula $r(a_{k})=\sigma-1$
\end_inset

 we instead substitute 
\begin_inset Formula $a_{k-1}$
\end_inset

, etc.
\end_layout

\begin_layout Verse
this means 
\begin_inset Formula $hash(q_{a})$
\end_inset

 increases by 
\begin_inset Formula $(r(a_{k})\:\sigma^{k-(k-1)})-(r(\alpha_{k})\:\sigma^{k-(k-1)})=1$
\end_inset


\end_layout

\begin_layout Verse
Given this information we can conclude 
\begin_inset Formula $H=\{h_{p},\,h_{p}+1,\,...,\,h_{p}+\sigma^{k-m}-1\}$
\end_inset


\end_layout

\begin_layout Verse
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Verse
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
This gives us far less costly way to generate all hashes in a simple for-loop:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={[GNU]C++},tabsize=2"
inline false
status open

\begin_layout Plain Layout

std::vector<size_t> check_last_kmer((...)) const;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template<std::ranges::range range_t>
\end_layout

\begin_layout Plain Layout

std::vector<size_t> search_sub_k(range_t& query) const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	size_t h_p = hash(query);                     			
\end_layout

\begin_layout Plain Layout

	size_t h_min = 0 + h_p;                 			
\end_layout

\begin_layout Plain Layout

	size_t h_max = h_p + pow(_sigma, k-query.size());
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	// lookup each hash
\end_layout

\begin_layout Plain Layout

	std::vector<size_t> output_positions;
\end_layout

\begin_layout Plain Layout

	for (size_t h = h_min; h < h_max; ++h) 
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		for (size_t pos : _data.at(h))
\end_layout

\begin_layout Plain Layout

			output_positions.push_back(pos);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	// cover edge case for last kmer
\end_layout

\begin_layout Plain Layout

	for (size_t pos : check_last_kmer(query))
\end_layout

\begin_layout Plain Layout

		output_positions.push_back(pos);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return output_positions;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Search function for queries of size 0 < m < k 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that after looking up all hashes depended on the query we also need
 to call 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{check_last_kmer}
\end_layout

\end_inset

.
 This is to cover an edge case were the query happens to be a sub-string
 of the last kmer in the text.
 As the query is compared against prefixes of all kmers and there is no
 kmer with a position 
\begin_inset Formula $p>text.size()-k$
\end_inset

 the query is instead manually compared against the last 
\begin_inset Formula $k-1$
\end_inset

 letters of the text.
\end_layout

\begin_layout Standard
While searching queries of length 
\begin_inset Formula $m<k$
\end_inset

 is more costly than just a simple lookup it is feasible to search queries
 in a adequately fast manner if 
\begin_inset Formula $k-m$
\end_inset

 is sufficiently small as this means the given prefix is in turn longer
 which means 
\begin_inset Formula $\#H$
\end_inset

 and thus the number of hashes that need to be searched is minimal.
\end_layout

\begin_layout Lemma
search performance for queries of size 
\begin_inset Formula $m:\,(k\mod m)\neq0\:\land m<k$
\end_inset

 is inversely proportional to 
\begin_inset Formula $k-m$
\end_inset


\end_layout

\begin_layout Standard
The actual implementation throws an exception if 
\begin_inset Formula $\sigma^{k-m}>10^{7}$
\end_inset

 in order to avoid a badly chosen 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $k$
\end_inset

 combination taking hours to complete given the amount of hashes that would
 have to be looked up.
\begin_inset Foot
status open

\begin_layout Plain Layout
While somewhat arbitrarily chosen, 
\begin_inset Formula $10^{7}$
\end_inset

represents the case of 
\begin_inset Formula $k-m>11$
\end_inset

 for the nucleotide alphabet (
\begin_inset Formula $\sigma=4$
\end_inset

) which should allow most users to be able to not encounter the exception
 during proper usage of the kmer-index and notably will mean for 
\begin_inset Formula $k=10$
\end_inset

 queries of all length be accepted.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Query Size m > k
\end_layout

\begin_layout Standard
To search queries of length 
\begin_inset Formula $m>k$
\end_inset

 the query is split into parts of length 
\begin_inset Formula $k$
\end_inset

 which will then be searched individually.
 If 
\begin_inset Formula $m\mod k\neq0$
\end_inset

 there will also be a part at the end (
\begin_inset Quotes eld
\end_inset

rest
\begin_inset Quotes erd
\end_inset

) with a length smaller than 
\begin_inset Formula $k$
\end_inset

.
 
\end_layout

\begin_layout Standard
We observe that the set of positions for a specific query of length 
\begin_inset Formula $m>k$
\end_inset

 is a subset of the positions of the first kmer 
\begin_inset Formula $p_{1}$
\end_inset

, the queries prefix of length 
\begin_inset Formula $k$
\end_inset

.
 To confirm whether a specific position of 
\begin_inset Formula $p_{1}$
\end_inset

 is valid we cross-reference the positions of the following parts as such:
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Verse
let query 
\begin_inset Formula $q=(q_{1},\,q_{1},\,...,\,q_{m})$
\end_inset

 be of length 
\begin_inset Formula $m:\:(m>k)\,\land(\,m\mod k\neq\text{0})$
\end_inset


\end_layout

\begin_layout Verse
let 
\begin_inset Formula $p_{i}=(q_{i},\,...,q_{i+k})$
\end_inset

 with 
\begin_inset Formula $i\in[1,\,(m-(m\mod k))/k]\subset\mathbb{N}$
\end_inset

 be the 
\begin_inset Formula $i$
\end_inset

-th 
\begin_inset Formula $k$
\end_inset

-long part of the query
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $r=(q_{m-(m\mod k)/k},\,...,q_{m})$
\end_inset

 be the rest of length 
\begin_inset Formula $(m\mod k)$
\end_inset


\end_layout

\begin_layout Verse
then the query occurs at positions 
\begin_inset Formula $\rho_{seed}\in pos(q_{1},...q_{k})=pos(p_{1})$
\end_inset

 iff
\end_layout

\begin_layout Verse
for all 
\begin_inset Formula $i$
\end_inset

 there exists a position 
\begin_inset Formula $\rho_{2}\in pos(p_{2})$
\end_inset

 such that 
\begin_inset Formula $\rho_{2}=\rho_{seed}+k$
\end_inset

, and there exists a position 
\begin_inset Formula $\rho_{3}\in pos(p_{3})$
\end_inset

 such that 
\begin_inset Formula $\rho_{3}=\rho_{2}+k$
\end_inset

, etc.
\end_layout

\begin_layout Verse
For 
\begin_inset Formula $\rho_{(m-(m\mod k))/k}\in pos(p_{last})$
\end_inset

 we need to check for a position 
\begin_inset Formula $\rho_{rest}\in pos(rest)$
\end_inset

 so that 
\begin_inset Formula $\rho_{rest}=\rho_{(m-(m\mod k))/k}+k$
\end_inset


\end_layout

\begin_layout Verse
If a 
\begin_inset Formula $\rho$
\end_inset

 is found for all parts of the query is confirmed to occur at 
\begin_inset Formula $\rho_{seed}$
\end_inset


\end_layout

\begin_layout Standard
For performance purposes if at any point the program does not find a fitting
 
\begin_inset Formula $\rho_{i}$
\end_inset

, the current position 
\begin_inset Formula $\rho_{seed}$
\end_inset

 is marked as invalid and the loop moves onto the next.
 While in the worst-case (all position in 
\begin_inset Formula $\rho_{seed}$
\end_inset

 are valid) performance would be relatively costly, in praxis this is rarely
 the case, especially for longer queries.
 We observe:
\end_layout

\begin_layout Lemma
Search time for queries of size 
\begin_inset Formula $m:\,m>k$
\end_inset

 scales inversely proportional to the number of results for the corresponding
 
\begin_inset Formula $p_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
Searching queries of length 
\begin_inset Formula $m:m\mod k=0$
\end_inset

 (which do not have a rest) should be preferred as to find the positions
 of the rest we will need to employ 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{search_subk}
\end_layout

\end_inset

 which can result in a significant runtime increase, especially if the rest
 is short.
 
\end_layout

\begin_layout Section
Multi kmer-Index
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
To further investigate the behavior implied by Lemmas 1 - 3 a benchmark
 was conducted.
 Queries of length 
\begin_inset Formula $\{6,7,...,50\}$
\end_inset

 were searched by a kmer-index with a single 
\begin_inset Formula $k=10$
\end_inset

 and the search calls duration to return was measured:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/multi_vs_single/single_only.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Average duration to get all occurences of a query of given length using
 a kmer-index for 
\begin_inset Formula $k=\{10\}$
\end_inset

.
 The inset graph shows a 
\begin_inset Quotes eld
\end_inset

zoomed in
\begin_inset Quotes erd
\end_inset

 view of the area of query lengths 
\begin_inset Formula $[16,29]$
\end_inset

.
 The dotted lines mark query lengths that are a multiples of 
\begin_inset Formula $k$
\end_inset

.
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The results show a predictable pattern substantiating the above mentioned
 lemmas.
 Best performance is only achieved for query sizes 
\begin_inset Formula $m:\:m\mod k=0$
\end_inset

 as this avoids having to search a rest with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{search_subk}
\end_layout

\end_inset

.
 While queries of length 
\begin_inset Formula $(n*k)-1,\,(n*k)-2:\:n\in\{1,2,...\}$
\end_inset

 still show acceptable performance, as the absolute difference between 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $k$
\end_inset

 increases the performance becomes worse (in accordance with Lemma 2).
 For queries of length 
\begin_inset Formula $m=(n*k)+1$
\end_inset

 results suggest a runtime increase of up to 
\begin_inset Formula $6⁷\approx280\,000$
\end_inset

 times compared to best-case performance.
 Note that the peaks at 
\begin_inset Formula $(n*k)+1$
\end_inset

 reduce in severity as query length increases.
 This is because with an increase in query length given a text of fixed
 size the number of results per query decreases and as stated in Lemma 3
 performance will improve slightly.
\end_layout

\begin_layout Standard
Given this behavior if we want to choose more 
\begin_inset Formula $k$
\end_inset

 to improve average performance the most obvious addition would be to cover
 the previous 
\begin_inset Formula $k$
\end_inset

s worst case performance: for example for 
\begin_inset Formula $k_{1}=10$
\end_inset

 we would additionally choose 
\begin_inset Formula $k_{2}=k_{1}+1=11$
\end_inset

, 
\begin_inset Formula $k_{3}=k_{2}+1$
\end_inset

 and so on.
 Ideally we would just use every possible 
\begin_inset Formula $k$
\end_inset

 in one index however due to memory limitations this is sometimes not feasible.
 As observed above, runtime for 
\begin_inset Formula $m=k-1$
\end_inset

 was still satisfactory and thus 
\begin_inset Formula $k_{i}=\{5,7,9,...,27,29,31\}$
\end_inset

 was chosen as a substitute to a multi kmer-index with perfect coverage:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/multi_vs_single/multi_vs_single.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Average search performance of multi and single kmer-index to find all occurrence
s of a query of given length in a text of size 
\begin_inset Formula $10^{6}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Despite the sub-optimal coverage of the multi kmer-index, performance is
 still very close to optimal.
 Note how at query length 10 the single kmer-index shows faster performance
 than the multi kmer-index (c.f.
 the red vertical line in Figure 2).
 This illustrates the slight difference in performance between 
\begin_inset Formula $k=m$
\end_inset

 (which is true for the single kmer-index for 
\begin_inset Formula $m=10$
\end_inset

) and 
\begin_inset Formula $k=m+1$
\end_inset

 (which is true for the multi kmer-index).
 Note further how after 
\begin_inset Formula $m=33$
\end_inset

 (which results in 3 search calls with 
\begin_inset Formula $k=11$
\end_inset

 and no rest and thus still performs adequately) runtime increases significantly.
 To investigate the multi-kmers index behavior for queries that cannot be
 searched as a single kmer we first need to detail how longer queries are
 handled outside of a single-k context.
\end_layout

\begin_layout Subsection
How to choose the appropriate k
\end_layout

\begin_layout Standard
The success of the multi kmer-index relies heavily on both being provided
 a well-chosen set 
\begin_inset Formula $ks$
\end_inset

 of 
\begin_inset Formula $k_{i}$
\end_inset

 and furthermore using the appropriate 
\begin_inset Formula $k_{i}$
\end_inset

 for a given query length.
 The latter is achieved by a table that at construction computes for every
 possible query length 
\begin_inset Formula $m$
\end_inset

 a set of 
\begin_inset Formula $\{k_{a},k_{b},...\}$
\end_inset

 such that 
\begin_inset Formula $k_{a}+k_{b}+...=m$
\end_inset

.
 To achieve best performance we want the minimal set (in regards to cardinality)
 of 
\begin_inset Formula $k_{i}$
\end_inset

 for and we furthermore want the 
\begin_inset Formula $k_{i}$
\end_inset

 are chosen as big as possible which accordant with Lemma 3 reduces runtime
 for longer queries.
 The table is constructed with a simple dynamic programming approach where
 to find the set of 
\begin_inset Formula $k_{i}$
\end_inset

 for a given query 
\begin_inset Formula $m_{j}$
\end_inset

 the already computed set for a queries 
\begin_inset Formula $m_{a},m_{b}<m_{j}:m_{a}+m_{b}=m_{j}$
\end_inset

 are referenced back to.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features booktabs="true" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
query length
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
summands
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
29
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9+9+11
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13+17
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
31
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9+9+13
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n/a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
33
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9+11+13
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Set of 
\begin_inset Formula $k_{i}$
\end_inset

 for certain query lengths chosen from 
\begin_inset Formula $k\in\{9,11,13,17\}.$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Depending on the set of 
\begin_inset Formula $k_{i}$
\end_inset

 supplied, not all query lengths may be possible to be represented with
 only summands.
 In this case the kmer index falls back on having to call 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{search_subk}
\end_layout

\end_inset

 for one of the summands.
 To find a set of 
\begin_inset Formula $k_{i}$
\end_inset

 that covers most of the queries supplied by the user, the following recommendat
ions should be kept in mind: 
\end_layout

\begin_layout Itemize
no 
\begin_inset Formula $k_{i}$
\end_inset

 should be a multiple of another: 
\begin_inset Formula $\lnot\exists k_{j}:k_{i}\mod k_{j}=0$
\end_inset

.
 This is to avoid redundancy as the higher 
\begin_inset Formula $k_{i}$
\end_inset

will always be chosen
\end_layout

\begin_layout Itemize
all 
\begin_inset Formula $k_{i}$
\end_inset

 should be as big as possible.
 As stated above this will decrease runtime however depending on memory
 limitations it may not always be possible
\end_layout

\begin_layout Itemize
small 
\begin_inset Formula $k_{i}$
\end_inset

 should be avoided completey.
 If 
\begin_inset Formula $k_{1}=3$
\end_inset

 is provided and is used for a sum, the index will have to crossreference
 all results for a single 3mer which depending on the text length may be
 far slower than just searching that query with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{search_subk}
\end_layout

\end_inset

.
 Initial results suggest to not use any 
\begin_inset Formula $k_{i}<10$
\end_inset

 and while they can still be supplied, the index will not use them for searching
 queries of bigger lengths unless unavoidable.
\end_layout

\begin_layout Standard
The author recommends for the set of 
\begin_inset Formula $k_{i}$
\end_inset

 to be a subset of 
\begin_inset Formula $\{9,11,13,17,19,21,23,27,29,31\}$
\end_inset

, primes are preferable because most queries will be able to be factorized
 into a subset of them.
 For example 
\begin_inset Formula $\{11,13,17,19,21\}$
\end_inset

 will cover every query length 
\begin_inset Formula $31<m\leq10000$
\end_inset

 and the 
\begin_inset Formula $k$
\end_inset

 are small enough to be stored on less capable machines even with bigger
 texts such as an entire genome.
 Note that if searching for occurences of queries of length 
\begin_inset Formula $m\in[3,31]$
\end_inset

 the query length should be directly supplied to the set of 
\begin_inset Formula $k_{i}$
\end_inset

 as a length smaller than 
\begin_inset Formula $min(ks)$
\end_inset

 cannot be represented as a sum of 
\begin_inset Formula $k_{i}$
\end_inset

s.
 
\end_layout

\begin_layout Subsection
Comparison with fm-Index
\end_layout

\begin_layout Standard
To put the absolute values of the above figures into perspective, a comparative
 analysis of the fm-index
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that for exact string matching there's is no relevant performance differenc
e between the fm- and bi-fm-index.
\end_layout

\end_inset

 and a multi kmer-index was conducted and the relative speedup measured:
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $t_{fm<i>},t_{kmer<i>}$
\end_inset

 the search runtime for searching a query of length 
\begin_inset Formula $i$
\end_inset

 with the corresponding index
\end_layout

\begin_layout Verse
then 
\begin_inset Formula $\text{{speedup}}(i)=\begin{cases}
+(1-(t_{kmer<i>}/t_{fm<i>})) & \text{{if}\;}t_{kmer<i>}>t_{fm<i>}\\
-(1-(t_{fm<i>}/t_{kmer<i>})) & \text{{if}\;}t_{kmer<i>}<t_{fm<i>}\\
\,0 & \text{{else}}
\end{cases}$
\end_inset

|
\begin_inset Foot
status open

\begin_layout Plain Layout
to clarify, if 
\begin_inset Formula $speedup(a,b)=+75\%$
\end_inset

 then 
\begin_inset Formula $b$
\end_inset

 has a runtime of 1.75 the runtime of 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $a$
\end_inset

 is 75% faster than 
\begin_inset Formula $b$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
For Query Lengths 
\begin_inset Formula $m\in[3,30]$
\end_inset

 
\end_layout

\begin_layout Standard
When searching for smaller queries the approriate 
\begin_inset Formula $k$
\end_inset

 should be directly supplied.
 The relative performance for a multi kmer-index with all 
\begin_inset Formula $k\in\{$
\end_inset

3,4,...,30,31} was benchmarked and compared against the fm-index:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/just_k/relative_speedup.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Relative speedup (in %) for search calls of the kmer-index vs.
 the fm-index per query length with a text size of 
\begin_inset Formula $10⁸$
\end_inset

.
 The inset plot shows the absolute runtime (in ns).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Results indicate that for bigger texts the kmer index will only perform
 better for relatively small 
\begin_inset Formula $k$
\end_inset

.
 This is because the indices map is limited to a size of 
\begin_inset Formula $\sigma^{k}$
\end_inset

 and as the kmer indices runtime for searching a single kmer is indepent
 from the number of results for that query, for bigger text higher 
\begin_inset Formula $k$
\end_inset

 will vastly increase the maps size and thus the time it takes to traverse
 it.
 For sufficiently small texts however, all 
\begin_inset Formula $k\in\{3,30\}$
\end_inset

will be faster to search and the overall speedup for short queries like
 these suggests that the kmer index should be preferred to search small
 kmers.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features booktabs="true" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="0pt">
<column alignment="decimal" decimal_point="." valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
text size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mean speedup
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kmer faster while
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10³$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20.99%
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 31
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10⁴$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19.30%
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 31
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10⁵$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17.35%
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 31
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10⁶$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16.77%
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 31
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10⁷$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9.43%
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 22
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10⁸$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8.17%
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 17
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10⁹$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
< 7%
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 11
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Average 
\begin_inset Formula $speedup(t_{kmer},t_{fm})$
\end_inset

 in the interval 
\begin_inset Formula $[3,30]$
\end_inset

 per text length.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
For arbitrary Query Lengths
\end_layout

\begin_layout Standard
To investigate the multi kmer-indices ability to be applied in general-purpose
 exact string matching scenarios a large-scale benchmark was conducted.
 For different text sizes, queries were searched with both indices and their
 relative performance measured:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
^
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/multi_kmer_vs_fm/5_1000/runtime_diff_over_text_size.png
	lyxscale 40
	width 100text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Graphs showing 
\begin_inset Formula $speedup(t_{kmer},t_{fm})$
\end_inset

 over query lengths for different text sizes.
 The grey area highlights query lengths [5, 30] which were excluded for
 the depicted median speedup.
 The multi kmer-index used all 
\begin_inset Formula $k\in$
\end_inset

 {5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31}.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The benchmark suggests that for longer queries the kmer-index provides a
 slight speedup over the fm-index.
 With increasing text size this speedup decreases however.
 This is because as mentioned in section 3.3.1 the kmer at the higher end
 of [3,30] take a longer time to search for bigger texts which in turn means
 that the individuals kmers the queries are made for whom the multi kmer-index
 prioritizes the bigger k will take longer as well.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
In summary, the kmer-index has proofed superior for searching appropriately
 small kmers given the text length detailed in Table 2.
 While more testing will have to be done it seems reasonable to assume that
 kmer-index will always performa better for queries of length 
\begin_inset Formula $m<10$
\end_inset

.
 For exact string matching of queries of arbitrary length the kmer index
 in it's current iteration should be preferred for smaller text sizes (
\begin_inset Formula $<10⁸$
\end_inset

) while the fm-index should proof more consistently performant for larger
 texts.
 However it may be possible to improve the kmer index with further features
 and if that achieves for example an additional speedup of 5% for longer
 queries, the kmer index should perform better than the fm-index for all
 relevant text sizes such as entire genomes.
 
\end_layout

\begin_layout Section
Outlook
\end_layout

\begin_layout Standard
To further improve performance and make the implementation generally more
 consistentlsapplicable the following additional features are proposed:
\end_layout

\begin_layout Subsection
>64 bit Hash
\end_layout

\begin_layout Standard
As mentioned above the datatype of the hashes is currently 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{uint64_t}
\end_layout

\end_inset

.
 64 bit integers were chosen because the standard C++ library does not currently
 support >64 bit integers natively and seqan3s kmer hash also uses them
\begin_inset CommandInset citation
LatexCommand cite
key "seqan3 docs: kmer hash"
literal "false"

\end_inset

.
 However the size of the integer used for the hashes is arbitrary and expanding
 it to 128 or 256 bit would improve the maximum k that can still be searched
 with the overall faster 
\begin_inset Formula $m=k$
\end_inset

 search function as it is currently limited to 
\begin_inset Formula $<31$
\end_inset

 for the smallest relevant nucleotide alphabet.
 This may be especially important when working with bigger alphabets such
 as the complete list of IUPAC codes for nucleotides 
\begin_inset CommandInset citation
LatexCommand cite
key "dna15 codes"
literal "false"

\end_inset

 or clear text for which 
\begin_inset Formula $\sigma=255$
\end_inset

.
 Furthermore in the application of read-mapping nowadays reads are often
 of relatively short length and being able to for example find all positions
 of a 50mer or 75mer could give programs in this application a significant
 speedup compared to factorizing these queries into multiple smaller kmer.
 Further research will have to be done to verify wether abstracting the
 hash type for the kmer-index to use for example integers of up to 1024
 bit from boosts 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{multiprecision}
\end_layout

\end_inset

 header
\begin_inset CommandInset citation
LatexCommand cite
key "boost multiprecision"
literal "false"

\end_inset

 could proof valuable as it may not be feasible due to memory limitation
 or runtime overhead inherent to these integer types.
 Furthermore as the k and thus the number of possible hashes increases the
 indices maps maximum size will also increase and as observed in section
 3.3.2 for larger texts bigger k do not result in a significane speedup.
 
\end_layout

\begin_layout Subsection
Multi kmer-index Compression 
\end_layout

\begin_layout Standard
As discussed in section 3, using multiple k for the same index vastly increases
 the search performance for a broad variety of queries.
 Ideally we would want to just choose every possible k however memory limitation
s make this difficult.
 The kmer-index from section 3 offered decent coverage of every second k
 but for a text size of 10⁸ already occupied about 80gb of memory.
 While this is not unfeasible for stronger machines, as each map uses about
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\#H*64*n*32$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 (where 
\begin_inset Formula $H$
\end_inset

 is the set of all pairwise different hashes, 
\begin_inset Formula $n$
\end_inset

 is the text size) many bytes which for bigger text such as an entire genome
 means using every possible 
\begin_inset Formula $k$
\end_inset

 is currently not practical.
 To remedy this it could be possible to implement a way to compress the
 single kmer-indices contained in the multi kmer-index.
 Each index contains all positions of the text in it's map exactly once
 which means in a multi kmer-index with 5 ks, the individual indices contain
 at least 
\begin_inset Formula $(5-1)n*32$
\end_inset

 many bits of redundant entries in the form of the vectors of positions
 for each hash.
 If a version of the kmer-index is implemented that only contains all the
 texts positions once while still allowing for adequate runtime performance
 an all-purpose kmer-index could be proposed that simply holds information
 for all possible ks regardless of user configuration.
\end_layout

\begin_layout Subsection
Hybrid Approach
\end_layout

\begin_layout Standard
As detailed above the performance peaks of the kmer-index are fairly consistentl
y predictable.
 A two-pronged approach is proposed in which for queries for whom we know
 the kmer-index will perform poorly the searching is instead done by a desperate
 fm-index.
 This allows for the now hybrid-index to have the speedup the kmer offers
 while also covering the inherent inconsistency by instead using the fm-index
 which performs highly consistently if sometimes worse.
 We can thus precalculate which queries should be searched with which index.
 The fm-index should be used to search a query of length 
\begin_inset Formula $m$
\end_inset

 if and only if at least one of the following is true:
\end_layout

\begin_layout Itemize
the text size is 
\begin_inset Formula $>10⁸$
\end_inset

 and 
\begin_inset Formula $m>15$
\end_inset


\end_layout

\begin_layout Itemize
there is no set 
\begin_inset Formula $\{k_{a},k_{b},...\}$
\end_inset

 such that 
\begin_inset Formula $k_{a}+k_{b}+...=m$
\end_inset


\end_layout

\begin_layout Standard
In all other cases preferring the kmer-index component may result in an
 overall speedup, however further research is needed to develop a better
 tested heuristic that substantiates these recommendations and is capable
 of determining a more exact text size (which may also be dependent on the
 alphabet used) which when exceeded might proof use of the hybrid index
 to be more trouble than it is worth given the need for increased memory
 capacity.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
The current kmer-index implementation is stable, reasonably well optimized
 and the indices performance is superior for searching kmers of relatively
 small length 
\begin_inset Formula $m<30$
\end_inset

 (or less than 30 for bigger texts as detailed in Section 3).
 For this purpose it achieved a performance increase of up to 50% and is
 thus well suited for it and should be preferred to more generalist indices
 like the fm-index if runtime performance is important.
 For query lengths past 30 the kmer-index has been shown to have a neglible
 performance increase while for bigger texts great than 
\begin_inset Formula $10^{8}$
\end_inset

 an overall performance decrease was observed.
 It may be possible to achieve better speedup with further features and
 optimizations that may make the kmer-index the better performing index
 for exact string matching in most situations.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection*
TODO3,
\end_layout

\begin_layout Standard
In praxis both the texts size and the queries and thus their lengths are
 given and cannot be controlled by the user.
 
\begin_inset Formula $k$
\end_inset

 however can be freely chosen.
 Given Lemma #1 we should choose 
\begin_inset Formula $k$
\end_inset

 as small as possible as this means the size of the map will be limited.
 For example it is reasonable to assume that unlike for 
\begin_inset Formula $k=25$
\end_inset

 in a text of length 
\begin_inset Formula $10^{7}$
\end_inset

 all 
\begin_inset Formula $5$
\end_inset

-mers will occur at least once which limits the map to a size of 
\begin_inset Formula $\sigma^{5}=1024$
\end_inset

 (note that the number of results per entry do not factor into the performance
 of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{search_k}
\end_layout

\end_inset

).
 Lemma #3 however implies we should choose 
\begin_inset Formula $k$
\end_inset

s that are used to search longer queries as big as possible
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that we are not only limited by the machines memory but also the fact
 that the kmer hashes have to fit in a 64 bit unsigned integer which necessitate
s an alphabet and k combination so that 
\begin_inset Formula $\sigma^{k}<2^{64}$
\end_inset

.
 For the 4-letter DNA alphabet, this means k can at most be 31 while for
 bigger alphabets, k has to be chosen far lower.
\end_layout

\end_inset

 as for a bigger k statistically the absolute number of occurrences per
 kmer and thus the number of results for each 
\begin_inset Formula $p_{i}$
\end_inset

 that have to be cross referenced will decrease.
 Furthermore 
\begin_inset Formula $k$
\end_inset

 should be chosen so the most amount of queries are directly of length 
\begin_inset Formula $k$
\end_inset

 or divisible by 
\begin_inset Formula $k$
\end_inset

.
 
\end_layout

\begin_layout Standard
In praxis it's rarely possible to find a single k that fulfills all of these
 conditions.
 To address this the kmer-index implementation was extended to (instead
 of using a single 
\begin_inset Formula $k$
\end_inset

) unify multiple kmer indices at once.
 This 
\begin_inset Quotes eld
\end_inset

multi kmer-index
\begin_inset Quotes erd
\end_inset

 is then able to autonomously choose which 
\begin_inset Formula $k$
\end_inset

 would be optimal to use for any given query.
 Specifying multiple 
\begin_inset Formula $k$
\end_inset

 will thus vastly increase performance for a wider array of query lengths.
\end_layout

\begin_layout Standard
The multi-kmer indices success in being more performant relies on taking
 advantage of the higher flexibility of being provided multiple 
\begin_inset Formula $k$
\end_inset

.
 A trivial approach would simple choose one of those 
\begin_inset Formula $k_{i}$
\end_inset

 and return a result identical to that of a single kmer-index that only
 had access to that 
\begin_inset Formula $k_{i}$
\end_inset

.
 However greater performance can be achieved by instead using multiple 
\begin_inset Formula $k_{i}$
\end_inset

 per query.
 At construction the multi kmer-index creates a table that, for each possible
 query length 
\begin_inset Formula $m_{j}$
\end_inset

 choose 
\begin_inset Formula $k_{i}\in\{k_{a},k_{b},...\}$
\end_inset

 such that 
\begin_inset Formula $k_{a}+k_{b}+...=m_{j}$
\end_inset

, that is the index tries to divide the query into multiple parts of different
 lengths so that it can search each part with the corresponding single kmer-inde
x to then much like a single kmer-index would for a query of length 
\begin_inset Formula $m>k$
\end_inset

 crossreference each part and thuse verify which of the positions of the
 first 
\begin_inset Formula $k_{i}$
\end_inset

mer are also occurences of the query.
 Creating this table is very similar to the change making problem <TODO:
 reference> in which given an amount of money (
\begin_inset Formula $m_{j}$
\end_inset

) we need to find the minimum number of coins (
\begin_inset Formula $k_{a},k_{b},...$
\end_inset

) that add up to exactly that amount.
 Note that choosing the number of 
\begin_inset Quotes eld
\end_inset

coins
\begin_inset Quotes erd
\end_inset

 to be as small as possible is paramount as the less kmers the index has
 to look up, the better the performance will be.
 Furthermore the index should prioritize bigger 
\begin_inset Formula $k_{i}$
\end_inset

 since as stated in Lemma 3 with a bigger 
\begin_inset Formula $k_{i}$
\end_inset

 given a fixed text size the number of results will be lower.
 Creating this table was achieved with a simple dynamic programming approach
 where to find the 
\begin_inset Formula $k_{i}$
\end_inset

 that add up to 
\begin_inset Formula $m$
\end_inset

, we reference back to previous results to find 
\begin_inset Formula $\{m_{memory1},m_{2},...\}:\sum_{i}m_{i}=m$
\end_inset

.
 Depending on the set of 
\begin_inset Formula $ks$
\end_inset

 this may not be possible for every number in the given range.
 In this case we will have to fall back on the considerably slower 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{search_subk}
\end_layout

\end_inset

 however intial testing has revealed that with a well picked set of 
\begin_inset Formula $k$
\end_inset

 the number of queries that cannot be covered in this fairly low.
 For example 
\begin_inset Formula $k\in\{9,11,15,17\}$
\end_inset

 will cover every query length 
\begin_inset Formula $m<2000$
\end_inset

 which means in the application of a read mapper the kmer index will be
 able to lookup all sizes of reads <TODO:https://www.illumina.com/science/technolo
gy/next-generation-sequencing/plan-experiments/read-length.html>.
 Note that if memory limitations permit to do so, the 
\begin_inset Formula $k$
\end_inset

 should be chosen as long as possible.
 
\end_layout

\begin_layout Subsection
Comparison with FM-Index
\end_layout

\begin_layout Standard
To put the absolute values of the above figures into perspective, a comparative
 analysis of the fm-index
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that for exact string matching there's is no relevant performance differenc
e between the fm- and bi-fm-index.
\end_layout

\end_inset

 and a multi kmer-index using every 
\begin_inset Formula $k\in\{3,30\}$
\end_inset

 was conducted and the relative speedup measured:
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $t_{fm<i>},t_{kmer<i>}$
\end_inset

 the search runtime for searching a query of length 
\begin_inset Formula $i$
\end_inset

 with the corresponding index
\end_layout

\begin_layout Verse
then 
\begin_inset Formula $\text{{speedup}}(i)=\begin{cases}
+(1-(t_{kmer<i>}/t_{fm<i>})) & \text{{if}\;}t_{kmer<i>}>t_{fm<i>}\\
-(1-(t_{fm<i>}/t_{kmer<i>})) & \text{{if}\;}t_{kmer<i>}<t_{fm<i>}\\
\,0 & \text{{else}}
\end{cases}$
\end_inset

|
\begin_inset Foot
status open

\begin_layout Plain Layout
to clarify, if 
\begin_inset Formula $speedup(a,b)=+75\%$
\end_inset

 then 
\begin_inset Formula $b$
\end_inset

 has a runtime of 1.75 the runtime of 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $a$
\end_inset

 is 75% faster than 
\begin_inset Formula $b$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For bigger text sizes the kmer-index exhibits more speedup in the lower
 end of 
\begin_inset Formula $k\in\{3,...,30\}$
\end_inset

.
 This behavior can be explained by Lemma 1: for small 
\begin_inset Formula $k$
\end_inset

 the indices unordered map is at maximum capacity and thus lookup time seizes
 to stop scaling with the texts size.
 
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
The point at which the kmer-index starts to perform worse than the fm-index
 is dependent on the text size as such:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Results indicate that using the kmer-index with optimal coverage to find
 occurrences of kmers for 
\begin_inset Formula $k\in\{3,...,30\}$
\end_inset

 results in an overall performance boost for smaller texts, for larger texts
 (
\begin_inset Formula $>10⁷$
\end_inset

) bigger k may result in overall performance decrease however if 
\begin_inset Formula $k$
\end_inset

 is chosen adequately low the kmer-index will still perform well and should
 be preferred to the fm-index.
 Notably for 
\begin_inset Formula $k\leq10$
\end_inset

 the kmer-index should always be preferred.
 
\end_layout

\begin_layout Subsection
General Purpose Exact String Matching
\end_layout

\begin_layout Standard
While the kmer-index proved to be well-suited for searching commonly used
 kmers of length 
\begin_inset Formula $k\in\{3,...,30\}$
\end_inset

, it is also able to search queries of arbitrary length.
 To investigate the applicability of the kmer-index for general-purpose
 exact string matching a benchmark was conducted that measured search time
 for queries of length 
\begin_inset Formula $m\in\{5,6,...,1000\}$
\end_inset

:
\end_layout

\begin_layout Standard
Results indicate that the kmer-index performs comparatively well for smaller
 texts while the bigger the text the wores the relative performance becomes.
 This is because for bigger queries no query can be covered directly and
 thus Lemma 3 makes the search performance highly dependent on the number
 of results.
 Noticeable for all text sizes are performance spikes around primes (for
 example in the above figure, notice how at 211 significant decrease in
 performance happens regardless of text size).
 Overall while using the kmer-index may result in speedup some of the time
 it's inconsistency for queries longer than 31 makes it hard to recommend
 for general-purpose use.
 If, however, the query lengths are known and relatively homogeneous with
 proper choice of k the kmer-index may proof useful in achieving greater
 performance.
 
\end_layout

\begin_layout Section
Addendum: Implementation Defined Optimization
\end_layout

\begin_layout Standard
Implementation of the kmer-index was guided at every step by benchmarking
 newly implemented components comparing their performance against other
 implementations.
 In this section the most relevant of these decisions are explained.
 C++20 was used for all performance relevant code.
\end_layout

\begin_layout Subsection
Choosing the fastest Pow Implementation
\end_layout

\begin_layout Standard
By the nature of the hash used exponentiation (henceforth referred to as
 
\begin_inset Quotes eld
\end_inset

pow
\begin_inset Quotes erd
\end_inset

 in reference to the commonly used 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::pow}
\end_layout

\end_inset

) is used every search call, sometimes multiple times.
 Note that the pow function has to be able to be evaluated at compile time
 and will only ever take unsigned integers as arguments.
 Four different versions of pow were implemented and their performance evaluated
:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{trivial_pow(base,n)}
\end_layout

\end_inset

: A trivial implementation calling 
\begin_inset Formula $base*base$
\end_inset

 
\begin_inset Formula $n$
\end_inset

-many times
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{recursive_pow(base,n)}
\end_layout

\end_inset

: Utilizing a recursive approach, this function calls itself recursively
 
\begin_inset Formula $n$
\end_inset

-many times and then evaluates each call from the inside out to return the
 correct result based on whether the exponent was odd or even
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{bit_pow(base,n)}
\end_layout

\end_inset

: Utilizes bit-operations which are generally more well-optimized on most
 modern machines
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{switch_pow(base,n)}
\end_layout

\end_inset

: Instead of using a loop, this implementation has multiple switch cases
 with identical code, when the function is called a lookup in a pre-calculated
 table produces the correct first switch case to start with.
 The result 
\begin_inset Quotes eld
\end_inset

falls through
\begin_inset Quotes erd
\end_inset

 the rest of the switch cases the correct number of times.
 Any exponentiation that would overflow the unsigned 64 bit integer result
 is immediately caught and 0 is returned instead.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/pow_vs_pow/pow_vs_pow.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Boxplot showing runtime distribution of average time to compute 
\begin_inset Formula $x^{y}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Results indicate that the implementation utilizing the fall-through switch
 is overall faster and was thus used for the index whenever possible.
\end_layout

\begin_layout Subsection
Choosing the fastest Hash Implementation
\end_layout

\begin_layout Standard
Having chosen the fastest pow function we next turn to the function hashing
 a kmer.
 A trivial approach would calculate the sum of ranks with a simple for loop.
 Instead the kmer-index implementation utilizes a fold expression:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

constexpr uint8_t to_rank(...
\end_layout

\begin_layout Plain Layout

constexpr size_t pow(...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template<size_t...
 is>
\end_layout

\begin_layout Plain Layout

static size_t hash_fold_aux(iterator_t it, 
\end_layout

\begin_layout Plain Layout

	std::index_sequence<is...> sequence)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return (...
 + to_rank(*it) * pow(_sigma, k-is-1));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

static size_t hash_fold(iterator_t query_it)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return hash_fold_aux(query_it, std::make_index_sequence<k>()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation of hash function utilizing a fold expression.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As 
\begin_inset Formula $k$
\end_inset

, 
\begin_inset Formula $\sigma$
\end_inset

 and the return value of pow can all be evaluated at compile time using
 the fold expression allows the the compiler to unwrap part of the sum and
 compute parts of the sum and compile time thus increasing performance.
 To illustrate this a benchmark was conducted comparing both hash-implementation
:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/hash_vs_hash/hash_vs_hash.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Multiple boxplots showing distribution of average runtime results (in ns)
 for hash implementations for different 
\begin_inset Formula $k$
\end_inset

 (y-axes have been normalized to the same scale to enable valid comparison
 between graphs).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Results indicate that the fold expression achieves the predicted performance
 increase.
 Note how for 
\begin_inset Formula $k=5$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_fold}
\end_layout

\end_inset

 vastly outpaces the trivial implementation.
 This may be due to cache artifacts, as k is small all possible parts of
 the sum fit in the L1 cache of the machine allowing for faster access at
 runtime.
 
\end_layout

\begin_layout Subsection
Choosing the fastest Map
\end_layout

\begin_layout Standard
The unordered map is the data structure at the center of the kmer-index
 and as such, fast access time for elements even for very large map sizes
 was necessary.
 As 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::unordered_map}
\end_layout

\end_inset

 did not proof sufficiently fast enough, other maps implemented by 3rd parties
 were tested and evaluated specifically in the context of use in a kmer-index:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::unordered_map}
\end_layout

\end_inset

 from the C++17 standard library
\begin_inset CommandInset citation
LatexCommand cite
key "std::unordered_map"
literal "false"

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{boost::unordered_map}
\end_layout

\end_inset

 from the 1.65.1 Boost Library
\begin_inset CommandInset citation
LatexCommand cite
key "boost::unordered_map"
literal "false"

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{absl::node_hash_map}
\end_layout

\end_inset

 from Googles Abseil
\begin_inset CommandInset citation
LatexCommand cite
key "absl::unordered_map"
literal "false"

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{robin_hood::unordered_map}
\end_layout

\end_inset

 as provided by Martin Ankerl et.
 al.
\begin_inset CommandInset citation
LatexCommand cite
key "robin_hood::unordered_map"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
Each map was filled with a fixed number of randomized elements it's time
 to return a specific element was benchmarked.
 Only retrieval was tested here since after construction in the context
 of the kmer-index no insertion will take place.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/map_vs_map/map_vs_map.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Search performance for different map implementations.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Results indicate that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{robin_hood::unordered_map}
\end_layout

\end_inset

 performed best irregardless of the number of elements contained and was
 as such used as the central data structure for the kmer-index.
\end_layout

\begin_layout Subsection
Parallelization
\end_layout

\begin_layout Standard
Apart from the amount of memory needed the only true disadvantage of using
 the multi kmer-index is the fact that the time it takes to construct increase
 a number of times as the number of 
\begin_inset Formula $k$
\end_inset

s rises.
 To address this a general purpose thread pool was implemented that allows
 all of the single kmer-index elements to be constructed in parallel:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

template<std::ranges::range text_t>             
\end_layout

\begin_layout Plain Layout

multi_kmer_index(text_t& text)
\end_layout

\begin_layout Plain Layout

	: single_kmer_index<ks>()...
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	auto pool = thread_pool{(...)};
\end_layout

\begin_layout Plain Layout

	std::vector<std::future<(...)>> futures;
\end_layout

\begin_layout Plain Layout

	(futures.emplace_back(
\end_layout

\begin_layout Plain Layout

		pool.execute(&single_kmer_index<ks>::create, text)), ...);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	// wait to finish
\end_layout

\begin_layout Plain Layout

	for (auto& f : futures)
\end_layout

\begin_layout Plain Layout

		f.get();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Paralell invocation of the create function for individual kmer-index elements
 during construction of the multi kmer-index.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As the number of possible ks is currently restricted to at most 31, modern
 systems with 32 or more CPUs are capable of constructing one multi kmer-index
 with optimal coverage with no additional runtime overhead.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: megahit assembly"
literal "false"

\end_inset

 https://academic.oup.com/bioinformatics/article/31/10/1674/177884
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: soapdenovo assembly"
literal "false"

\end_inset

 https://academic.oup.com/bioinformatics/article/30/12/1660/380938
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: taxonomical profiling"
literal "false"

\end_inset

https://msystems.asm.org/content/1/3/e00020-16
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: kraken LCA"
literal "false"

\end_inset

https://genomebiology.biomedcentral.com/articles/10.1186/gb-2014-15-3-r46
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: spectrum dissimilarity"
literal "false"

\end_inset

https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-015-0875-7
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: spectrum error correction"
literal "false"

\end_inset

https://academic.oup.com/bioinformatics/article/29/3/308/257257
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "seqan3 fm-index master"
literal "false"

\end_inset

Pockrandt, C.
 M.
 Generic implementation of a bidirectional FM-index in SeqAn and applications.
 Diss.
 Master’s thesis, Freie Universität Berlin, 2015.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "seqan3 docs"
literal "false"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "seqan3 docs: kmer hash"
literal "false"

\end_inset

 http://docs.seqan.de/seqan/3-master-user/group__views.html#ga6e598d6a021868f704d39
df73252974f
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "seqan3 docs: fm index"
literal "false"

\end_inset

 http://docs.seqan.de/seqan/3-master-user/group__submodule__fm__index.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "seqan2 doctor arbeit"
literal "false"

\end_inset

 https://refubium.fu-berlin.de/bitstream/handle/fub188/12704/Thesis.Gogol-Doring.Seq
An.2009.pdf?sequence=1&isAllowed=y page 143 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "dna15 codes"
literal "false"

\end_inset

https://www.bioinformatics.org/sms/iupac.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "my github"
literal "false"

\end_inset

https://github.com/Clemapfel/kmer_index/blob/master/kmer_index.hpp 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "cpp RVO"
literal "false"

\end_inset

https://en.cppreference.com/w/cpp/language/copy_elision
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "std::unordered_map"
literal "false"

\end_inset

https://en.cppreference.com/w/cpp/container/unordered_map
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "boost::unordered_map"
literal "false"

\end_inset

 https://www.boost.org/doc/libs/1_65_0/doc/html/boost/unordered_map.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "absl::unordered_map"
literal "false"

\end_inset

 https://abseil.io/docs/cpp/guides/container#abslnode_hash_map-and-abslnode_hash_
set
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "robin_hood::unordered_map"
literal "false"

\end_inset

 https://github.com/martinus/robin-hood-hashing
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "boost multiprecision"
literal "false"

\end_inset

https://www.boost.org/doc/libs/1_62_0/libs/multiprecision/doc/html/boost_multiprec
ision/tut/ints/cpp_int.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-5"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-6"

\end_inset


\end_layout

\end_body
\end_document
