#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\definecolor{gray}{rgb}{0.5, 0.5, 0.5}
\definecolor{keyword}{RGB}{243, 60, 114}
\definecolor{comment}{RGB}{0, 200, 101}
\definecolor{background}{rgb}{0.9, 0.9, 0.9}

\usepackage{listings}
\usepackage{xparse}

\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams-chap-bytype
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "beramono" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "keywordstyle={\bfseries \color{keyword}},commentstyle={\color{comment}},caption={Search function for exact matches for a query of size 0 < m < k $^{[1]}$},captionpos=b,backgroundcolor={\color{background}},basicstyle={\ttfamily\small},language={C++},numbers=none,captionpos=b,tabsize=2"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Implementation and Performance Evaluation of a k-mer Index for exact String
 Matching
\end_layout

\begin_layout Author
Author: Clemens Cords, FU Berlin
\end_layout

\begin_layout Abstract
As demand for large-scale genomic sequence matching rises so does the ability
 to efficiently get the positions or number of occurrences of a query of
 length k called a kmer.
 A kmer-index optimized for this purposes was implemented and it's performance
 evaluated.
 The implementation is capable of searching kmers of arbitrary length specified
 at runtime, utilizes parallelization for faster construction and searching
 of multiple queries at once and it's internal structure can be further
 customized at compile time to achieve greater performance for certain query
 sizes.
 The exact nature of the implementation-defined optimizations is explained
 and their performant nature demonstrated through benchmarks.
 Results indicate that for the purpose of finding positions or number of
 occurrences for queries of arbitrary length including the commonly used
 
\begin_inset Formula $k\in\{3,4,...,30\}$
\end_inset

 compared to the fm-index the kmer-index performs up to 70% times faster
 for smaller text sizes (
\begin_inset Formula $<10⁸$
\end_inset

), for arbitrarily large texts (
\begin_inset Formula $>10⁸$
\end_inset

) the kmer-index should only be considered to search smaller queries of
 length 
\begin_inset Formula $m\leq10$
\end_inset

.
 Overall the kmer-index should provide a more performant alternative for
 searching short kmer if appropriately applied may also proof useful for
 general-purpose exact string matching of sequences of arbitrary length
 in smaller texts.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section*
Motivation
\end_layout

\begin_layout Standard
A k-mer (also known as 
\begin_inset Quotes eld
\end_inset

q-gram
\begin_inset Quotes erd
\end_inset

, henceforth written as 
\begin_inset Quotes eld
\end_inset

kmer
\begin_inset Quotes erd
\end_inset

) is any genomic sequence of length 
\begin_inset Formula $k$
\end_inset

, usually in the context of being a sub-sequence of a longer genome.
 Analysis of kmers is used in a wide variety of contexts such as in de novo
 genome assembly
\begin_inset CommandInset citation
LatexCommand cite
key "kmer: megahit assembly,kmer: soapdenovo assembly"
literal "false"

\end_inset

, taxonomic profiling
\begin_inset CommandInset citation
LatexCommand cite
key "kmer: taxonomical profiling"
literal "false"

\end_inset

 and sequence classification
\begin_inset CommandInset citation
LatexCommand cite
key "kmer: kraken LCA"
literal "false"

\end_inset

.
 Furthermore kmer spectra (a graph of the multiplicity of each kmer in the
 set of pairwise different kmer in the reference) have been used to assess
 genome similarity
\begin_inset CommandInset citation
LatexCommand cite
key "kmer: spectrum dissimilarity"
literal "false"

\end_inset

 and to correct errors in sequence data
\begin_inset CommandInset citation
LatexCommand cite
key "kmer: spectrum error correction"
literal "false"

\end_inset

.
 Seqan3, a newly released version of the C++ API for sequence analysis has
 yet to implement a purpose-build index for kmer searching.
 This paper aims to access the viability of substituting seqan3s fm-index
\begin_inset CommandInset citation
LatexCommand cite
key "seqan3 fm-index master"
literal "false"

\end_inset

 with the presented kmer-index implementation not only for the purpose of
 searching kmers but for exact string matching in general by comparing the
 indices performance to each other.
\end_layout

\begin_layout Section
Construction
\end_layout

\begin_layout Standard
The kmer-index utilizes an unordered map as it's central data structure
 which for each kmer saves the position of all occurrences in the text.
 To save on memory the kmers are converted to an unsigned integer via the
 following hash function and stored as such instead:
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $kmer$
\end_inset

 = 
\begin_inset Formula $(q_{1},\,q_{2},\,...,q_{k})$
\end_inset

 where 
\begin_inset Formula $q\in A$
\end_inset


\end_layout

\begin_layout Verse
\begin_inset Formula $hash(kmer)$
\end_inset

 = 
\begin_inset Formula $\sum_{i=0}^{k}\:r(q_{i})\:\sigma^{k-i-1}$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Verse
where 
\begin_inset Formula $\sigma=\#A$
\end_inset

 , 
\begin_inset Formula $r(q_{i})\in\{0,1,...,\sigma-1\}$
\end_inset

 the rank of 
\begin_inset Formula $q_{i}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
This hash guarantees no hash collisions
\begin_inset CommandInset citation
LatexCommand cite
key "seqan2 doctor arbeit"
literal "false"

\end_inset

 and was furthermore chosen because the kmer-index is to be integrated and
 compared to the Seqan3 library which uses the same hash function
\begin_inset CommandInset citation
LatexCommand cite
key "seqan3 docs: kmer hash"
literal "false"

\end_inset

.
 Constructing the kmer-index is fairly straight-forward: We can simply iterate
 through the text while keeping track of the current position and adding
 it to the end of the appropriate entry for the current kmer.
 Given a text of length 
\begin_inset Formula $n$
\end_inset

, 
\begin_inset Formula $n-k$
\end_inset

 hashes will be generated and inserted into the index.
 Construction therefore has linear amortized complexity which is acceptable
 because for genomic data index construction will usually be done only once
 after which the index is serialized and can be loaded directly if needed
 at a later point.
\end_layout

\begin_layout Section
Searching
\end_layout

\begin_layout Standard
To achieve greater flexibility the kmer-index implementation is capable
 of searching queries of arbitrary length irregardless of the 
\begin_inset Formula $k$
\end_inset

 that is used to create it.
 While a specific k still needs to be specified at compile time, at run
 time any query can be searched however the search functions performance
 will vary drastically depended on the queries length in relation to 
\begin_inset Formula $k$
\end_inset

.
 
\end_layout

\begin_layout Subsection
Query Size m = k
\end_layout

\begin_layout Standard
The best performing cases are queries of length exactly 
\begin_inset Formula $k$
\end_inset

.
 For these a simple lookup in the indices unordered map will return all
 results at once:
\begin_inset Foot
status open

\begin_layout Plain Layout
All code examples henceforth are edited for brevity and only meant for the
 purpose of demonstrating the programs behavior unless otherwise specified.
 The actual implementations makes many concessions for the sake of performance
 that can be viewed in it's entirety in the actual code
\begin_inset CommandInset citation
LatexCommand cite
key "my github"
literal "false"

\end_inset

 and would be too lengthy to print here.
\end_layout

\end_inset

 
\end_layout

\begin_layout LyX-Code
\begin_inset listings
lstparams "language={[GNU]C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

unordered_map<size_t, std::vector<uint32_t>> _data;
\end_layout

\begin_layout Plain Layout

uint64_t hash((...) query) const {(...)};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template<std::ranges::range query_t>
\end_layout

\begin_layout Plain Layout

std::vector<size_t>& search_k(query_t& query) const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	const auto* it = _data.at(hash(query));
\end_layout

\begin_layout Plain Layout

	if (it == _data.end())
\end_layout

\begin_layout Plain Layout

		return std::vector<size_t>();
\end_layout

\begin_layout Plain Layout

	else 
\end_layout

\begin_layout Plain Layout

		return *it;
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Search function for queries of size k.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
By nature of using an unordered map, querying a single entry has constant-time
 amortized complexity dependent on the number of pairwise different kmers
 in the text and therefore the number of different entries in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{_data}
\end_layout

\end_inset

.
 C++s return value optimization
\begin_inset CommandInset citation
LatexCommand cite
key "cpp RVO"
literal "false"

\end_inset

 ensures that the positions are never actually copied and only a reference
 to them is moved between functions which other than the time it takes for
 the hash-function to return, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{search_k}
\end_layout

\end_inset

s runtime is very close to that of a single lookup in the map.
 This is the kmer-indices main strength and queries of length 
\begin_inset Formula $k$
\end_inset

 should be considered a best-case scenario.
\end_layout

\begin_layout Lemma
Search performance for queries of size 
\begin_inset Formula $m:\,m=k$
\end_inset

 is dependent on the absolute number of pairwise different hashes in the
 text
\end_layout

\begin_layout Subsection
Query Size m < k
\end_layout

\begin_layout Standard
To be able to search queries of arbitrary length without modifying the indices
 internal structure for queries of length 
\begin_inset Formula $m<k$
\end_inset

 we need to apply a different approach: As we cannot get the results for
 the query directly we instead return the positions of all kmers that have
 the query as a prefix.
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $query=(q_{1},q_{2},...,q_{m})$
\end_inset

 where 
\begin_inset Formula $m<k$
\end_inset

 
\end_layout

\begin_layout Verse
for an arbitrary 
\begin_inset Formula $kmer=(s_{1},...,s_{k})$
\end_inset

 it holds true that:
\end_layout

\begin_layout Verse
iff 
\begin_inset Formula $\forall i\leq m:\:q_{i}=s_{i}$
\end_inset

 then any position 
\begin_inset Formula $pos$
\end_inset

 of 
\begin_inset Formula $kmer$
\end_inset

 is also a position of 
\begin_inset Formula $query$
\end_inset


\end_layout

\begin_layout Verse
because the 
\begin_inset Formula $m$
\end_inset

 characters proceeding 
\begin_inset Formula $pos$
\end_inset

 are 
\end_layout

\begin_layout Verse
\begin_inset Formula $s_{0},...,s_{m},...,s_{k}$
\end_inset

 and 
\begin_inset Formula $s_{0},...,s_{m}=q_{0},...,\,q_{m}=query$
\end_inset


\end_layout

\begin_layout Standard
\noindent
To avoid generating all kmers that contain 
\begin_inset Formula $query$
\end_inset

 as a prefix and then hashing them we instead generate the hashes directly.
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $hash(q_{1},q_{1},...,q_{m})=\sum_{i=0}^{k}\:r(q_{i})\:\sigma^{k-i}=h_{q}$
\end_inset

 constant as given by 
\begin_inset Formula $query$
\end_inset


\end_layout

\begin_layout Verse
let 
\begin_inset Formula $H\subset\mathbb{Z}^{+}\coloneqq$
\end_inset

 set of all hashes of kmer with a prefix equal to 
\begin_inset Formula $query$
\end_inset


\end_layout

\begin_layout Verse
let 
\begin_inset Formula $h_{min},\:h_{max}:\:\forall h_{i}\in H:\:h_{min}\leq h_{i}<h_{max}$
\end_inset

 be the lower and upper bound of 
\begin_inset Formula $H$
\end_inset


\end_layout

\begin_layout Verse
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Verse
to find 
\begin_inset Formula $h_{min}$
\end_inset

 we observe that as the query 
\begin_inset Formula $q_{min}:\,r(q_{min})=h_{min}$
\end_inset

 has a prefix equal to 
\begin_inset Formula $query$
\end_inset

 it holds true that 
\end_layout

\begin_layout Verse
\begin_inset Formula $hash(h_{min})\geq h_{p}$
\end_inset

 because the first 
\begin_inset Formula $m$
\end_inset

 summands 
\begin_inset Formula $r(q_{min,j})\:\sigma^{k-j-1}:1\leq j\leq m$
\end_inset

 of the hash are given by the prefix
\end_layout

\begin_layout Verse
we choose the other summands 
\begin_inset Formula $r(q_{i})\:\sigma^{k-i-1}:i>m$
\end_inset

 to all be as small as possible by choosing characters such that 
\begin_inset Formula $\forall q_{i}:\:r(q_{i})=0$
\end_inset

 
\end_layout

\begin_layout Verse
thus 
\begin_inset Formula $h_{min}=h_{p}+\sum_{i=m+1}^{k}\:0*\sigma^{k-i-1}=h_{p}$
\end_inset


\end_layout

\begin_layout Verse
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Verse
to find 
\begin_inset Formula $h_{max}$
\end_inset

 we observe that 
\begin_inset Formula $\#H=\sigma^{k-m}$
\end_inset

 because 
\begin_inset Formula $m$
\end_inset

 characters of each query are given by the prefix
\end_layout

\begin_layout Verse
we furthermore observe that for two hashes 
\begin_inset Formula $h_{a},\,h_{b}\in H:\,h_{a}<h_{b}$
\end_inset

the difference between the hashes 
\begin_inset Formula $h_{a}-h_{b}\geq1$
\end_inset


\end_layout

\begin_layout Verse
this is because given 
\begin_inset Formula $q_{a}=(a_{1},\,...,\,a_{k-1},\,a_{k})\::hash(q_{a})=h_{a}\neq h_{max}-1$
\end_inset

 to find the next smallest hash that is also in 
\begin_inset Formula $H$
\end_inset

, we replace the last letter 
\begin_inset Formula $a_{k}$
\end_inset

 with 
\begin_inset Formula $\alpha_{k}$
\end_inset

 such that 
\begin_inset Formula $r(a_{k})=r(\alpha_{k})+1$
\end_inset

.
 If 
\begin_inset Formula $r(a_{k})=\sigma-1$
\end_inset

 we instead substitute 
\begin_inset Formula $a_{k-1}$
\end_inset

, etc.
\end_layout

\begin_layout Verse
this means 
\begin_inset Formula $hash(q_{a})$
\end_inset

 increases by 
\begin_inset Formula $(r(a_{k})\:\sigma^{k-(k-1)})-(r(\alpha_{k})\:\sigma^{k-(k-1)})=1$
\end_inset


\end_layout

\begin_layout Verse
Given this information we can conclude 
\begin_inset Formula $H=\{h_{p},\,h_{p}+1,\,...,\,h_{p}+\sigma^{k-m}-1\}$
\end_inset


\end_layout

\begin_layout Verse
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Verse
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
This gives us far less costly way to generate all hashes in a simple for-loop:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={[GNU]C++},tabsize=2"
inline false
status open

\begin_layout Plain Layout

std::vector<size_t> check_last_kmer((...)) const;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template<std::ranges::range range_t>
\end_layout

\begin_layout Plain Layout

std::vector<size_t> search_sub_k(range_t& query) const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	size_t h_p = hash(query);                     			
\end_layout

\begin_layout Plain Layout

	size_t h_min = 0 + h_p;                 			
\end_layout

\begin_layout Plain Layout

	size_t h_max = h_p + pow(_sigma, k-query.size());
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	// lookup each hash
\end_layout

\begin_layout Plain Layout

	std::vector<size_t> output_positions;
\end_layout

\begin_layout Plain Layout

	for (size_t h = h_min; h < h_max; ++h) 
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		for (size_t pos : _data.at(h))
\end_layout

\begin_layout Plain Layout

			output_positions.push_back(pos);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	// cover edge case for last kmer
\end_layout

\begin_layout Plain Layout

	for (size_t pos : check_last_kmer(query))
\end_layout

\begin_layout Plain Layout

		output_positions.push_back(pos);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return output_positions;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Search function for queries of size 0 < m < k 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that after looking up all hashes depended on the query we also need
 to call 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{check_last_kmer}
\end_layout

\end_inset

.
 This is to cover an edge case were the query happens to be a sub-string
 of the last kmer in the text.
 As the query is compared against prefixes of all kmers and there is no
 kmer with a position 
\begin_inset Formula $p>text.size()-k$
\end_inset

 the query is instead manually compared against the last 
\begin_inset Formula $k-1$
\end_inset

 letters of the text.
\end_layout

\begin_layout Standard
While searching queries of length 
\begin_inset Formula $m<k$
\end_inset

 is more costly than just a simple lookup it is feasible to search queries
 in a adequately fast manner if 
\begin_inset Formula $k-m$
\end_inset

 is sufficiently small as this means the given prefix is in turn longer
 which means 
\begin_inset Formula $\#H$
\end_inset

 and thus the number of hashes that need to be searched is minimal.
\end_layout

\begin_layout Lemma
search performance for queries of size 
\begin_inset Formula $m:\,(k\mod m)\neq0\:\land m<k$
\end_inset

 is inversely proportional to 
\begin_inset Formula $k-m$
\end_inset


\end_layout

\begin_layout Standard
The actual implementation throws an exception if 
\begin_inset Formula $\sigma^{k-m}>10^{7}$
\end_inset

 in order to avoid a badly chosen 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $k$
\end_inset

 combination taking hours to complete given the amount of hashes that would
 have to be looked up.
\begin_inset Foot
status open

\begin_layout Plain Layout
While somewhat arbitrarily chosen, 
\begin_inset Formula $10^{7}$
\end_inset

represents the case of 
\begin_inset Formula $k-m>11$
\end_inset

 for the nucleotide alphabet (
\begin_inset Formula $\sigma=4$
\end_inset

) which should allow most users to be able to not encounter the exception
 during proper usage of the kmer-index and notably will mean for 
\begin_inset Formula $k=10$
\end_inset

 queries of all length be accepted.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Query Size m > k
\end_layout

\begin_layout Standard
To search queries of length 
\begin_inset Formula $m>k$
\end_inset

 the query is split into parts of length 
\begin_inset Formula $k$
\end_inset

 which will then be searched individually.
 If 
\begin_inset Formula $m\mod k\neq0$
\end_inset

 there will also be a part at the end (
\begin_inset Quotes eld
\end_inset

rest
\begin_inset Quotes erd
\end_inset

) with a length smaller than 
\begin_inset Formula $k$
\end_inset

.
 
\end_layout

\begin_layout Standard
We observe that the set of positions for a specific query of length 
\begin_inset Formula $m>k$
\end_inset

 is a subset of the positions of the first kmer 
\begin_inset Formula $p_{1}$
\end_inset

, the queries prefix of length 
\begin_inset Formula $k$
\end_inset

.
 To confirm whether a specific position of 
\begin_inset Formula $p_{1}$
\end_inset

 is valid we cross-reference the positions of the following parts as such:
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Verse
let query 
\begin_inset Formula $q=(q_{1},\,q_{1},\,...,\,q_{m})$
\end_inset

 be of length 
\begin_inset Formula $m:\:(m>k)\,\land(\,m\mod k\neq\text{0})$
\end_inset


\end_layout

\begin_layout Verse
let 
\begin_inset Formula $p_{i}=(q_{i},\,...,q_{i+k})$
\end_inset

 with 
\begin_inset Formula $i\in[1,\,(m-(m\mod k))/k]\subset\mathbb{N}$
\end_inset

 be the 
\begin_inset Formula $i$
\end_inset

-th 
\begin_inset Formula $k$
\end_inset

-long part of the query
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $r=(q_{m-(m\mod k)/k},\,...,q_{m})$
\end_inset

 be the rest of length 
\begin_inset Formula $(m\mod k)$
\end_inset


\end_layout

\begin_layout Verse
then the query occurs at positions 
\begin_inset Formula $\rho_{seed}\in pos(q_{1},...q_{k})=pos(p_{1})$
\end_inset

 iff
\end_layout

\begin_layout Verse
for all 
\begin_inset Formula $i$
\end_inset

 there exists a position 
\begin_inset Formula $\rho_{2}\in pos(p_{2})$
\end_inset

 such that 
\begin_inset Formula $\rho_{2}=\rho_{seed}+k$
\end_inset

, and there exists a position 
\begin_inset Formula $\rho_{3}\in pos(p_{3})$
\end_inset

 such that 
\begin_inset Formula $\rho_{3}=\rho_{2}+k$
\end_inset

, etc.
\end_layout

\begin_layout Verse
For 
\begin_inset Formula $\rho_{(m-(m\mod k))/k}\in pos(p_{last})$
\end_inset

 we need to check for a position 
\begin_inset Formula $\rho_{rest}\in pos(rest)$
\end_inset

 so that 
\begin_inset Formula $\rho_{rest}=\rho_{(m-(m\mod k))/k}+k$
\end_inset


\end_layout

\begin_layout Verse
If a 
\begin_inset Formula $\rho$
\end_inset

 is found for all parts of the query is confirmed to occur at 
\begin_inset Formula $\rho_{seed}$
\end_inset


\end_layout

\begin_layout Standard
For performance purposes if at any point the program does not find a fitting
 
\begin_inset Formula $\rho_{i}$
\end_inset

, the current position 
\begin_inset Formula $\rho_{seed}$
\end_inset

 is marked as invalid and the loop moves onto the next.
 While in the worst-case (all position in 
\begin_inset Formula $\rho_{seed}$
\end_inset

 are valid) performance would be relatively costly, in praxis this is rarely
 the case, especially for longer queries.
 We observe:
\end_layout

\begin_layout Lemma
Search time for queries of size 
\begin_inset Formula $m:\,m>k$
\end_inset

 scales inversely proportional to the number of results for the corresponding
 
\begin_inset Formula $p_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
Searching queries of length 
\begin_inset Formula $m:m\mod k=0$
\end_inset

 (which do not have a rest) should be preferred as to find the positions
 of the rest we will need to employ 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{search_subk}
\end_layout

\end_inset

 which can result in a significant runtime increase, especially if the rest
 is short.
 
\end_layout

\begin_layout Subsection
Choosing the right k
\end_layout

\begin_layout Standard
In praxis both the texts size and the queries and thus their lengths are
 given and cannot be controlled by the user.
 
\begin_inset Formula $k$
\end_inset

 however can be freely chosen.
 Given Lemma #1 we should choose 
\begin_inset Formula $k$
\end_inset

 as small as possible as this means the size of the map will be limited.
 For example it is reasonable to assume that unlike for 
\begin_inset Formula $k=25$
\end_inset

 in a text of length 
\begin_inset Formula $10^{7}$
\end_inset

 all 
\begin_inset Formula $5$
\end_inset

-mers will occur at least once which limits the map to a size of 
\begin_inset Formula $\sigma^{5}=1024$
\end_inset

 (note that the number of results per entry do not factor into the performance
 of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{search_k}
\end_layout

\end_inset

).
 Lemma #3 however implies we should choose 
\begin_inset Formula $k$
\end_inset

s that are used to search longer queries as big as possible
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that we are not only limited by the machines memory but also the fact
 that the kmer hashes have to fit in a 64 bit unsigned integer which necessitate
s an alphabet and k combination so that 
\begin_inset Formula $\sigma^{k}<2^{64}$
\end_inset

.
 For the 4-letter DNA alphabet, this means k can at most be 31 while for
 bigger alphabets, k has to be chosen far lower.
\end_layout

\end_inset

 as for a bigger k statistically the absolute number of occurrences per
 kmer and thus the number of results for each 
\begin_inset Formula $p_{i}$
\end_inset

 that have to be cross referenced will decrease.
 Furthermore 
\begin_inset Formula $k$
\end_inset

 should be chosen so the most amount of queries are directly of length 
\begin_inset Formula $k$
\end_inset

 or divisible by 
\begin_inset Formula $k$
\end_inset

.
 
\end_layout

\begin_layout Standard
In praxis it's rarely possible to find a single k that fulfills all of these
 conditions.
 To address this the kmer-index implementation was extended to (instead
 of using a single 
\begin_inset Formula $k$
\end_inset

) unify multiple kmer indices at once.
 This 
\begin_inset Quotes eld
\end_inset

multi kmer-index
\begin_inset Quotes erd
\end_inset

 is then able to autonomously choose which 
\begin_inset Formula $k$
\end_inset

 would be optimal to use for any given query.
 Specifying multiple 
\begin_inset Formula $k$
\end_inset

 will thus vastly increase performance for a wider array of query lengths.
\end_layout

\begin_layout Section
Multi kmer-Index
\end_layout

\begin_layout Standard
To further investigate the behavior implied by Lemmas 1 - 3 a benchmark
 was conducted.
 Queries of length 
\begin_inset Formula $\{6,7,...,50\}$
\end_inset

 were searched by a kmer-index with a single 
\begin_inset Formula $k=10$
\end_inset

 and the search calls duration to return was measured:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/multi_vs_single/single_only.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Average duration to get all occurences of a query of given length using
 a kmer-index for 
\begin_inset Formula $k=\{10\}$
\end_inset

.
 The inset graph shows a 
\begin_inset Quotes eld
\end_inset

zoomed in
\begin_inset Quotes erd
\end_inset

 view of the area of query lengths 
\begin_inset Formula $[16,29]$
\end_inset

.
 The dotted lines mark query lengths that are a multiple of 
\begin_inset Formula $k$
\end_inset

.
 
\end_layout

\end_inset


\end_layout

\end_inset

The results show a predictable pattern substantiating the above mentioned
 lemmas.
 Best performance is only achieved for query sizes 
\begin_inset Formula $m:\:m\mod k=0$
\end_inset

 as this avoids having to search a rest with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{search_subk}
\end_layout

\end_inset

.
 While queries of length 
\begin_inset Formula $(n*k)-1,\,(n*k)-2:\:n\in\{1,2,...\}$
\end_inset

 still show acceptable performance, as the absolute difference between 
\begin_inset Formula $m$
\end_inset

 and 
\begin_inset Formula $k$
\end_inset

 increases the performance becomes worse (in accordance with Lemma 2).
 For queries of length 
\begin_inset Formula $m=(n*k)+1$
\end_inset

 results suggest a runtime increase of up to 
\begin_inset Formula $6⁷\approx280\,000$
\end_inset

 times compared to best-case performance.
 Note that the peaks at 
\begin_inset Formula $(n*k)+1$
\end_inset

 reduce in severity as query length increases.
 This is because with an increase in query length given a text of fixed
 size the number of results per query decreases and as stated in Lemma 3
 performance will improve slightly.
\end_layout

\begin_layout Standard
Given this behavior if we want to choose more 
\begin_inset Formula $k$
\end_inset

 to improve average performance the most obvious addition would be to cover
 the previous 
\begin_inset Formula $k$
\end_inset

s worst case performance: for example for 
\begin_inset Formula $k_{1}=10$
\end_inset

 we would additionally choose 
\begin_inset Formula $k_{2}=k_{1}+1=11$
\end_inset

, 
\begin_inset Formula $k_{3}=k_{2}+1$
\end_inset

 and so on.
 Ideally we would just use every possible 
\begin_inset Formula $k$
\end_inset

 in one index however due to memory limitations this is sometimes not feasible.
 As observed above, runtime for 
\begin_inset Formula $m=k-1$
\end_inset

 was still satisfactory and thus 
\begin_inset Formula $k_{i}=\{5,7,9,...,27,29\}$
\end_inset

 was chosen as a substitute to a multi kmer-index with perfect coverage:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/multi_vs_single/multi_vs_single.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Average search performance of multi and single kmer-index to find all occurrence
s of a query of given length in a text of size 
\begin_inset Formula $10^{6}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Despite the sub-optimal coverage of the multi kmer-index, performance is
 still very close to optimal.
 Note how at query length 10 the single kmer-index shows faster performance
 than the multi kmer-index (c.f.
 the red vertical line in Figure 2).
 This illustrates the slight difference in performance between 
\begin_inset Formula $k=m$
\end_inset

 (which is true for the single kmer-index for 
\begin_inset Formula $m=10$
\end_inset

) and 
\begin_inset Formula $k=m+1$
\end_inset

 (which is true for the multi kmer-index).
 Note further how after 
\begin_inset Formula $m=33$
\end_inset

 (which results in 3 search calls with 
\begin_inset Formula $k=11$
\end_inset

 and no rest and thus still performs adequately) runtime increases significantly.
 Furthermore at 
\begin_inset Formula $m=47$
\end_inset

 runtime spikes to an unacceptable level due to 47 being a prime which means
 there is no a 
\begin_inset Formula $k\in\{5,7,...,31\}$
\end_inset

 that it is divisible by.
 Similar runtime increases will always be observed for primes bigger than
 31 (or less than 31 depending on the alphabet size and thus the maximum
 possible k).
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset

To put the absolute values of the above figures into perspective, a comparative
 analysis of the fm-index
\begin_inset Foot
status open

\begin_layout Plain Layout
Note that for exact string matching there's is no relevant performance differenc
e between the fm- and bi-fm-index.
\end_layout

\end_inset

 and a multi kmer-index using every 
\begin_inset Formula $k\in\{3,30\}$
\end_inset

 was conducted and the relative speedup measured:
\end_layout

\begin_layout Verse
let 
\begin_inset Formula $t_{fm<i>},t_{kmer<i>}$
\end_inset

 the search runtime for searching a query of length 
\begin_inset Formula $i$
\end_inset

 with the corresponding index
\end_layout

\begin_layout Verse
then 
\begin_inset Formula $\text{{speedup}}(i)=\begin{cases}
+(1-(t_{kmer<i>}/t_{fm<i>})) & \text{{if}\;}t_{kmer<i>}>t_{fm<i>}\\
-(1-(t_{fm<i>}/t_{kmer<i>})) & \text{{if}\;}t_{kmer<i>}<t_{fm<i>}\\
\,0 & \text{{else}}
\end{cases}$
\end_inset

|
\begin_inset Foot
status open

\begin_layout Plain Layout
to clarify, if 
\begin_inset Formula $speedup(a,b)=+75\%$
\end_inset

 then 
\begin_inset Formula $b$
\end_inset

 has a runtime of 1.75 the runtime of 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $a$
\end_inset

 is 75% faster than 
\begin_inset Formula $b$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/just_k/relative_speedup.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Relative speedup (in %) for search calls of the kmer-index vs.
 the fm-index per query length with a text size of 
\begin_inset Formula $10⁸$
\end_inset

.
 The inset plot shows the absolute runtime (in ns).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
For bigger text sizes the kmer-index exhibits more speedup in the lower
 end of 
\begin_inset Formula $k\in\{3,...,30\}$
\end_inset

.
 This behavior can be explained by Lemma 1: for small 
\begin_inset Formula $k$
\end_inset

 the indices unordered map is at maximum capacity and thus lookup time seizes
 to stop scaling with the texts size.
 
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
The point at which the kmer-index starts to perform worse than the fm-index
 is dependent on the text size as such:
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features booktabs="true" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="0pt">
<column alignment="decimal" decimal_point="." valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
text size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mean speedup in 
\begin_inset Formula $[3,30]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kmer faster while
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10³$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20.99%
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 31
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10⁴$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19.30%
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 31
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10⁵$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17.35%
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 31
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10⁶$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16.77%
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 31
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10⁷$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9.43%
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 22
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10⁸$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8.17%
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 17
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10⁹$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
< 7%
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
k < 11
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Results indicate that using the kmer-index with optimal coverage to find
 occurrences of kmers for 
\begin_inset Formula $k\in\{3,...,30\}$
\end_inset

 results in an overall performance boost for smaller texts, for larger texts
 (
\begin_inset Formula $>10⁷$
\end_inset

) bigger k may result in overall performance decrease however if 
\begin_inset Formula $k$
\end_inset

 is chosen adequately low the kmer-index will still perform well and should
 be preferred to the fm-index.
 Notably for 
\begin_inset Formula $k\leq10$
\end_inset

 the kmer-index should always be preferred.
 
\end_layout

\begin_layout Section
Outlook
\end_layout

\begin_layout Standard
To further improve performance and make the implementation generally more
 consistent and applicable in areas it is currently not the following additional
 features are proposed:
\end_layout

\begin_layout Subsection
>64 bit Hash
\end_layout

\begin_layout Standard
As mentioned above the datatype of the hashes is currently 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{uint64_t}
\end_layout

\end_inset

.
 64 bit integers were chosen because the standard C++ library does not currently
 support >64 bit integers natively and seqan3s kmer hash also uses them
\begin_inset CommandInset citation
LatexCommand cite
key "seqan3 docs: kmer hash"
literal "false"

\end_inset

.
 However the size of the integer used for the hashes is arbitrary and expanding
 it to 128 or 256 bit would improve the maximum k that can still be searched
 with the overall faster 
\begin_inset Formula $m=k$
\end_inset

 search function as it is currently limited to 
\begin_inset Formula $<31$
\end_inset

 for the smallest relevant nucleotide alphabet.
 This may be especially important when working with bigger alphabets such
 as the complete list of IUPAC codes for nucleotides 
\begin_inset CommandInset citation
LatexCommand cite
key "dna15 codes"
literal "false"

\end_inset

 or clear text for which 
\begin_inset Formula $\sigma=255$
\end_inset

.
 Abstracting the hash type for the kmer-index to use for example integers
 of up to 1024 bit from boosts 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{multiprecision}
\end_layout

\end_inset

 header
\begin_inset CommandInset citation
LatexCommand cite
key "boost multiprecision"
literal "false"

\end_inset

 could proof valuable, even if these types introduce a small overhead compared
 to 64 bit sized integers.
 
\end_layout

\begin_layout Subsection
Multi kmer-index Compression 
\end_layout

\begin_layout Standard
As discussed in section 3, using multiple k for the same index vastly increases
 the search performance for a broad variety of queries.
 Ideally we would want to just choose every possible k however memory limitation
s make this difficult.
 The kmer-index from section 3 offered decent coverage of every second k
 but for a text size of 10⁸ already occupied about 60gb of memory.
 While this is not unfeasible for stronger machines, as each map uses about
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\#H*64*n*32$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 (where 
\begin_inset Formula $H$
\end_inset

 is the set of all pairwise different hashes, 
\begin_inset Formula $n$
\end_inset

 is the text size) many bytes which for bigger text such as an entire genome
 means achieving optimal coverage is all but impossible.
 To remedy this it could be possible to implement a way to compress the
 single kmer-indices contained in the multi kmer-index.
 Each index contains all positions of the text in it's map exactly once
 which means in a multi kmer-index with 5 ks, the individual indices contain
 at least 
\begin_inset Formula $(5-1)n*32$
\end_inset

 many bits of redundant entries in the form of the vectors of positions
 for each hash.
 If a version of the kmer-index is implemented that only contains all the
 texts positions once while still allowing for adequate runtime performance
 an all-purpose kmer-index could be proposed that simply holds information
 for all possible ks.
 To assure near optimal runtime and no overhead introduced the current implement
ation of the kmer-index does not currently allow for any compression.
\end_layout

\begin_layout Subsection
General Purpose Exact String Matching
\end_layout

\begin_layout Standard
While the kmer-index proved to be well-suited for searching commonly used
 kmers of length 
\begin_inset Formula $k\in\{3,...,30\}$
\end_inset

, it is also able to search queries of arbitrary length.
 To investigate the applicability of the kmer-index for general-purpose
 exact string matching a benchmark was conducted that measured search time
 for queries of length 
\begin_inset Formula $m\in\{5,6,...,1000\}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/multi_kmer_vs_fm/5_1000/runtime_diff_over_text_size.png
	lyxscale 40
	width 100text%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Relative speedup over query length for different text sizes.
 (y-axis log scaled)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Results indicate that the kmer-index performs comparatively well for smaller
 texts while the bigger the text the wores the relative performance becomes.
 This is because for bigger queries no query can be covered directly and
 thus Lemma 3 makes the search performance highly dependent on the number
 of results.
 Noticeable for all text sizes are performance spikes around primes (for
 example in the above figure, notice how at 211 significant decrease in
 performance happens regardless of text size).
 Overall while using the kmer-index may result in speedup some of the time
 it's inconsistency for queries longer than 31 makes it hard to recommend
 for general-purpose use.
 If, however, the query lengths are known and relatively homogeneous with
 proper choice of k the kmer-index may proof useful in achieving greater
 performance.
 
\end_layout

\begin_layout Subsection
Hybrid Approach
\end_layout

\begin_layout Standard
As detailed above the performance peaks of the kmer-index are fairly consistentl
y predictable.
 A two-pronged approach is proposed in which for queries for whom we know
 the kmer-index will perform poorly the searching is instead done by a desperate
 fm-index.
 This allows for the now hybrid-index to have the speedup the kmer offers
 while also covering the inherent inconsistency by instead using the fm-index
 which performs highly consistently if sometimes worse.
 We can thus precalculate which queries should be searched with which index.
 The fm-index should be used to search a query of length 
\begin_inset Formula $m$
\end_inset

 if and only if at least one of the following is true:
\end_layout

\begin_layout Itemize
the text size is 
\begin_inset Formula $>10⁸$
\end_inset

 and 
\begin_inset Formula $m>15$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $m$
\end_inset

 is a prime
\end_layout

\begin_layout Itemize
there is no 
\begin_inset Formula $k_{i}:m\mod k_{i}=0$
\end_inset

 and 
\begin_inset Formula $m>max(k_{i})$
\end_inset


\end_layout

\begin_layout Standard
In all other cases preferring the kmer-index component may result in an
 overall speedup, however further research is needed to develop a better
 tested heuristic that substantiates these recommendations and is capable
 of determining a more exact text size (which may also be dependent on the
 alphabet used) which when exceed might proof use of the hybrid index to
 be more trouble than it is worth given the need for increased memory capacity.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
The current kmer-index implementation is stable, reasonably well optimized
 and the indices performance is superior for searching kmers of relatively
 small length 
\begin_inset Formula $m<30$
\end_inset

 (or less than 30 for bigger texts, c.f.
 Section 3).
 For this purpose it is well suited and should be preferred to more generalist
 indices like the fm-index if runtime performance is important.
 For query lengths past 30 the kmer-index was shown to have an inconsistent
 performance increase that (in it's current form) makes it rarely applicable
 for general-purpose exact string matching.
 However it was also shown that it is possible to predict for a query whether
 or not the kmer index will result in an overall speedup and it was furthermore
 demonstrated that that speedup may be significant.
 It is therefore recommend to consider the hybrid index approach detailed
 above for further research and implementation as it may result in overall
 speedup compared to using either of the indices on their own.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Addendum: Implementation Defined Optimization
\end_layout

\begin_layout Standard
Implementation of the kmer-index was guided at every step by benchmarking
 newly implemented components comparing their performance against other
 implementations.
 In this section the most relevant of these decisions are explained.
 C++20 was used for all performance relevant code.
\end_layout

\begin_layout Subsection
Choosing the fastest Pow Implementation
\end_layout

\begin_layout Standard
By the nature of the hash used exponentiation (henceforth referred to as
 
\begin_inset Quotes eld
\end_inset

pow
\begin_inset Quotes erd
\end_inset

 in reference to the commonly used 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::pow}
\end_layout

\end_inset

) is used every search call, sometimes multiple times.
 Note that the pow function has to be able to be evaluated at compile time
 and will only ever take unsigned integers as arguments.
 Four different versions of pow were implemented and their performance evaluated
:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{trivial_pow(base,n)}
\end_layout

\end_inset

: A trivial implementation calling 
\begin_inset Formula $base*base$
\end_inset

 
\begin_inset Formula $n$
\end_inset

-many times
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{recursive_pow(base,n)}
\end_layout

\end_inset

: Utilizing a recursive approach, this function calls itself recursively
 
\begin_inset Formula $n$
\end_inset

-many times and then evaluates each call from the inside out to return the
 correct result based on whether the exponent was odd or even
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{bit_pow(base,n)}
\end_layout

\end_inset

: Utilizes bit-operations which are generally more well-optimized on most
 modern machines
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{switch_pow(base,n)}
\end_layout

\end_inset

: Instead of using a loop, this implementation has multiple switch cases
 with identical code, when the function is called a lookup in a pre-calculated
 table produces the correct first switch case to start with.
 The result 
\begin_inset Quotes eld
\end_inset

falls through
\begin_inset Quotes erd
\end_inset

 the rest of the switch cases the correct number of times.
 Any exponentiation that would overflow the unsigned 64 bit integer result
 is immediately caught and 0 is returned instead.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/pow_vs_pow/pow_vs_pow.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Boxplot showing runtime distribution of average time to compute 
\begin_inset Formula $x^{y}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Results indicate that the implementation utilizing the fall-through switch
 is overall faster and was thus used for the index whenever possible.
\end_layout

\begin_layout Subsection
Choosing the fastest Hash Implementation
\end_layout

\begin_layout Standard
Having chosen the fastest pow function we next turn to the function hashing
 a kmer.
 A trivial approach would calculate the sum of ranks with a simple for loop.
 Instead the kmer-index implementation utilizes a fold expression:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

constexpr uint8_t to_rank(...
\end_layout

\begin_layout Plain Layout

constexpr size_t pow(...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template<size_t...
 is>
\end_layout

\begin_layout Plain Layout

static size_t hash_fold_aux(iterator_t it, 
\end_layout

\begin_layout Plain Layout

	std::index_sequence<is...> sequence)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return (...
 + to_rank(*it) * pow(_sigma, k-is-1));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

static size_t hash_fold(iterator_t query_it)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	return hash_fold_aux(query_it, std::make_index_sequence<k>()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Implementation of hash function utilizing a fold expression.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As 
\begin_inset Formula $k$
\end_inset

, 
\begin_inset Formula $\sigma$
\end_inset

 and the return value of pow can all be evaluated at compile time using
 the fold expression allows the the compiler to unwrap part of the sum and
 compute parts of the sum and compile time thus increasing performance.
 To illustrate this a benchmark was conducted comparing both hash-implementation
:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/hash_vs_hash/hash_vs_hash.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Multiple boxplots showing distribution of average runtime results (in ns)
 for hash implementations for different 
\begin_inset Formula $k$
\end_inset

 (y-axes have been normalized to the same scale to enable valid comparison
 between graphs).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Results indicate that the fold expression achieves the predicted performance
 increase.
 Note how for 
\begin_inset Formula $k=5$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{hash_fold}
\end_layout

\end_inset

 vastly outpaces the trivial implementation.
 This may be due to cache artifacts, as k is small all possible parts of
 the sum fit in the L1 cache of the machine allowing for faster access at
 runtime.
 
\end_layout

\begin_layout Subsection
Choosing the fastest Map
\end_layout

\begin_layout Standard
The unordered map is the data structure at the center of the kmer-index
 and as such, fast access time for elements even for very large map sizes
 was necessary.
 As 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::unordered_map}
\end_layout

\end_inset

 did not proof sufficiently fast enough, other maps implemented by 3rd parties
 were tested and evaluated specifically in the context of use in a kmer-index:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{std::unordered_map}
\end_layout

\end_inset

 from the C++17 standard library
\begin_inset CommandInset citation
LatexCommand cite
key "std::unordered_map"
literal "false"

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{boost::unordered_map}
\end_layout

\end_inset

 from the 1.65.1 Boost Library
\begin_inset CommandInset citation
LatexCommand cite
key "boost::unordered_map"
literal "false"

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{absl::node_hash_map}
\end_layout

\end_inset

 from Googles Abseil
\begin_inset CommandInset citation
LatexCommand cite
key "absl::unordered_map"
literal "false"

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{robin_hood::unordered_map}
\end_layout

\end_inset

 as provided by Martin Ankerl et.
 al.
\begin_inset CommandInset citation
LatexCommand cite
key "robin_hood::unordered_map"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
Each map was filled with a fixed number of randomized elements it's time
 to return a specific element was benchmarked.
 Only retrieval was tested here since after construction in the context
 of the kmer-index no insertion will take place.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/clem/Workspace/kmer_index/source/benchmarks/map_vs_map/map_vs_map.png
	lyxscale 40
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Search performance for different map implementations.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Results indicate that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{robin_hood::unordered_map}
\end_layout

\end_inset

 performed best irregardless of the number of elements contained and was
 as such used as the central data structure for the kmer-index.
\end_layout

\begin_layout Subsection
Parallelization
\end_layout

\begin_layout Standard
Apart from the amount of memory needed the only true disadvantage of using
 the multi kmer-index is the fact that the time it takes to construct increase
 a number of times as the number of 
\begin_inset Formula $k$
\end_inset

s rises.
 To address this a general purpose thread pool was implemented that allows
 all of the single kmer-index elements to be constructed in parallel:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

template<std::ranges::range text_t>             
\end_layout

\begin_layout Plain Layout

multi_kmer_index(text_t& text)
\end_layout

\begin_layout Plain Layout

	: single_kmer_index<ks>()...
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	auto pool = thread_pool{(...)};
\end_layout

\begin_layout Plain Layout

	std::vector<std::future<(...)>> futures;
\end_layout

\begin_layout Plain Layout

	(futures.emplace_back(
\end_layout

\begin_layout Plain Layout

		pool.execute(&single_kmer_index<ks>::create, text)), ...);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	// wait to finish
\end_layout

\begin_layout Plain Layout

	for (auto& f : futures)
\end_layout

\begin_layout Plain Layout

		f.get();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Paralell invocation of the create function for individual kmer-index elements
 during construction of the multi kmer-index.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As the number of possible ks is currently restricted to at most 31, modern
 systems with 32 or more CPUs are capable of constructing one multi kmer-index
 with optimal coverage with no additional runtime overhead.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: megahit assembly"
literal "false"

\end_inset

 https://academic.oup.com/bioinformatics/article/31/10/1674/177884
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: soapdenovo assembly"
literal "false"

\end_inset

 https://academic.oup.com/bioinformatics/article/30/12/1660/380938
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: taxonomical profiling"
literal "false"

\end_inset

https://msystems.asm.org/content/1/3/e00020-16
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: kraken LCA"
literal "false"

\end_inset

https://genomebiology.biomedcentral.com/articles/10.1186/gb-2014-15-3-r46
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: spectrum dissimilarity"
literal "false"

\end_inset

https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-015-0875-7
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "kmer: spectrum error correction"
literal "false"

\end_inset

https://academic.oup.com/bioinformatics/article/29/3/308/257257
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "seqan3 fm-index master"
literal "false"

\end_inset

Pockrandt, C.
 M.
 Generic implementation of a bidirectional FM-index in SeqAn and applications.
 Diss.
 Master’s thesis, Freie Universität Berlin, 2015.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "seqan3 docs"
literal "false"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "seqan3 docs: kmer hash"
literal "false"

\end_inset

 http://docs.seqan.de/seqan/3-master-user/group__views.html#ga6e598d6a021868f704d39
df73252974f
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "seqan3 docs: fm index"
literal "false"

\end_inset

 http://docs.seqan.de/seqan/3-master-user/group__submodule__fm__index.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "seqan2 doctor arbeit"
literal "false"

\end_inset

 https://refubium.fu-berlin.de/bitstream/handle/fub188/12704/Thesis.Gogol-Doring.Seq
An.2009.pdf?sequence=1&isAllowed=y page 143 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "dna15 codes"
literal "false"

\end_inset

https://www.bioinformatics.org/sms/iupac.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "my github"
literal "false"

\end_inset

https://github.com/Clemapfel/kmer_index/blob/master/kmer_index.hpp 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "cpp RVO"
literal "false"

\end_inset

https://en.cppreference.com/w/cpp/language/copy_elision
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "std::unordered_map"
literal "false"

\end_inset

https://en.cppreference.com/w/cpp/container/unordered_map
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "boost::unordered_map"
literal "false"

\end_inset

 https://www.boost.org/doc/libs/1_65_0/doc/html/boost/unordered_map.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "absl::unordered_map"
literal "false"

\end_inset

 https://abseil.io/docs/cpp/guides/container#abslnode_hash_map-and-abslnode_hash_
set
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "robin_hood::unordered_map"
literal "false"

\end_inset

 https://github.com/martinus/robin-hood-hashing
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "boost multiprecision"
literal "false"

\end_inset

https://www.boost.org/doc/libs/1_62_0/libs/multiprecision/doc/html/boost_multiprec
ision/tut/ints/cpp_int.html
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-5"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-6"

\end_inset


\end_layout

\end_body
\end_document
